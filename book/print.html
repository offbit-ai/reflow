<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Reflow Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the Reflow workflow automation platform">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>â†</kbd> or <kbd>â†’</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Reflow Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="reflow-documentation"><a class="header" href="#reflow-documentation">Reflow Documentation</a></h1>
<p>Welcome to the Reflow documentation! Reflow is a powerful, actor-based workflow execution engine built in Rust that supports multi-language scripting and cross-platform deployment.</p>
<h2 id="what-is-reflow"><a class="header" href="#what-is-reflow">What is Reflow?</a></h2>
<p>Reflow is a modular workflow engine that uses the actor model for concurrent, message-passing execution. It supports:</p>
<ul>
<li><strong>Multi-Language Scripting</strong>: JavaScript (Deno), Python, and WebAssembly</li>
<li><strong>Actor-Based Architecture</strong>: Isolated, concurrent actors with message passing</li>
<li><strong>Graph-Based Workflows</strong>: Visual workflow representation with history/undo</li>
<li><strong>Cross-Platform</strong>: Native Rust execution + WebAssembly for browsers</li>
<li><strong>Real-Time Capabilities</strong>: Networking, WebSockets, and live data processing</li>
</ul>
<h2 id="documentation-structure"><a class="header" href="#documentation-structure">Documentation Structure</a></h2>
<h3 id="-getting-started"><a class="header" href="#-getting-started">ğŸš€ <a href="./getting-started/README.html">Getting Started</a></a></h3>
<p>Quick start guide, installation, and basic concepts</p>
<h3 id="-architecture"><a class="header" href="#-architecture">ğŸ—ï¸ <a href="./architecture/overview.html">Architecture</a></a></h3>
<p>System architecture, actor model, and design patterns</p>
<h3 id="-core-api"><a class="header" href="#-core-api">ğŸ“š <a href="./api/actors/creating-actors.html">Core API</a></a></h3>
<p>Detailed API documentation for actors, messaging, and graphs</p>
<h3 id="-scripting"><a class="header" href="#-scripting">ğŸ”§ <a href="./scripting/javascript/deno-runtime.html">Scripting</a></a></h3>
<p>Multi-language runtime support (Deno, Python, WASM)</p>
<h3 id="-components"><a class="header" href="#-components">ğŸ“¦ <a href="./components/standard-library.html">Components</a></a></h3>
<p>Standard component library and custom component creation</p>
<h3 id="-deployment"><a class="header" href="#-deployment">ğŸš€ <a href="./deployment/native-deployment.html">Deployment</a></a></h3>
<p>Deployment options and operational considerations</p>
<h3 id="-tutorials"><a class="header" href="#-tutorials">ğŸ¯ <a href="./tutorials/building-visual-editor.html">Tutorials</a></a></h3>
<p>Visual editor tutorial and performance optimization</p>
<h3 id="-reference"><a class="header" href="#-reference">ğŸ“– <a href="./reference/api-reference.html">Reference</a></a></h3>
<p>Complete API reference and configuration options</p>
<h3 id="-examples"><a class="header" href="#-examples">ğŸ’¡ <a href="./examples/README.html">Examples</a></a></h3>
<p>Tutorials, use cases, and code samples</p>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><a href="./getting-started/installation.html">Installation Guide</a></li>
<li><a href="./getting-started/first-workflow.html">First Workflow Tutorial</a></li>
<li><a href="./api/actors/creating-actors.html">Actor Creation Guide</a></li>
<li><a href="./components/standard-library.html">Component Library</a></li>
<li><a href="./deployment/native-deployment.html">Deployment Guide</a></li>
</ul>
<h2 id="community-and-support"><a class="header" href="#community-and-support">Community and Support</a></h2>
<ul>
<li><strong>GitHub Issues</strong>: Report bugs and request features</li>
<li><strong>Discussions</strong>: Community Q&amp;A and announcements</li>
<li><strong>Contributing</strong>: See CONTRIBUTING.md for development guidelines</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-reflow"><a class="header" href="#getting-started-with-reflow">Getting Started with Reflow</a></h1>
<p>Welcome to Reflow! This guide will help you get up and running with the actor-based workflow engine.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<p>This getting started guide covers:</p>
<ol>
<li><strong><a href="getting-started/./installation.html">Installation</a></strong> - Setting up Reflow on your system</li>
<li><strong><a href="getting-started/./basic-concepts.html">Basic Concepts</a></strong> - Understanding actors, messages, and workflows</li>
<li><strong><a href="getting-started/./development-setup.html">Development Setup</a></strong> - Setting up your development environment</li>
<li><strong><a href="getting-started/./first-workflow.html">First Workflow</a></strong> - Creating your first workflow</li>
</ol>
<h2 id="quick-overview"><a class="header" href="#quick-overview">Quick Overview</a></h2>
<p>Reflow is an actor-based workflow engine that allows you to:</p>
<ul>
<li>Create <strong>actors</strong> that process data and communicate via messages</li>
<li>Connect actors into <strong>workflows</strong> that define data flow and processing logic</li>
<li>Execute workflows with <strong>multi-language support</strong> (JavaScript/Deno, Python, WASM)</li>
<li>Deploy workflows <strong>natively</strong> or in <strong>WebAssembly</strong> environments</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before getting started with Reflow, you should have:</p>
<ul>
<li><strong>Rust</strong> (1.70 or later) - for building and running Reflow</li>
<li><strong>Basic understanding</strong> of concurrent programming concepts</li>
<li><strong>Familiarity</strong> with at least one of: JavaScript, Python, or Rust</li>
</ul>
<h2 id="architecture-at-a-glance"><a class="header" href="#architecture-at-a-glance">Architecture at a Glance</a></h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Actor A   â”‚â”€â”€â”€â–¶â”‚   Actor B   â”‚â”€â”€â”€â–¶â”‚   Actor C   â”‚
â”‚ (JavaScript)â”‚    â”‚  (Python)   â”‚    â”‚    (Rust)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                  â”‚                  â”‚
       â–¼                  â–¼                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Message Bus &amp; Routing                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<ul>
<li><strong>Actor</strong>: An isolated unit of computation that processes messages</li>
<li><strong>Message</strong>: Data passed between actors</li>
<li><strong>Port</strong>: Input/output connections on actors</li>
<li><strong>Workflow</strong>: A graph of connected actors</li>
<li><strong>Runtime</strong>: The execution environment (Deno, Python, etc.)</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ol>
<li>Start with <strong><a href="getting-started/./installation.html">Installation</a></strong> to set up Reflow</li>
<li>Read <strong><a href="getting-started/./basic-concepts.html">Basic Concepts</a></strong> to understand the fundamentals</li>
<li>Follow the <strong><a href="getting-started/./first-workflow.html">First Workflow</a></strong> tutorial</li>
<li>Explore the <strong><a href="getting-started/../examples/README.html">Examples</a></strong> for more complex use cases</li>
</ol>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li>Check the <strong><a href="getting-started/../reference/troubleshooting-guide.html">Troubleshooting Guide</a></strong></li>
<li>Browse the <strong><a href="getting-started/../reference/api-reference.html">API Reference</a></strong></li>
<li>Look at <strong><a href="getting-started/../examples/README.html">Examples</a></strong> for working code</li>
<li>Open an issue on GitHub for bugs or feature requests</li>
</ul>
<p>Ready to start? Let's <strong><a href="getting-started/./installation.html">install Reflow</a></strong>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide covers installing and setting up Reflow on your system.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before installing Reflow, ensure you have:</p>
<h3 id="required"><a class="header" href="#required">Required</a></h3>
<ul>
<li><strong>Rust</strong> 1.70 or later</li>
<li><strong>Git</strong> for cloning the repository</li>
</ul>
<h3 id="optional-for-scripting-support"><a class="header" href="#optional-for-scripting-support">Optional (for scripting support)</a></h3>
<ul>
<li><strong>Deno</strong> 1.30+ for JavaScript/TypeScript actors</li>
<li><strong>Python</strong> 3.8+ for Python actors</li>
<li><strong>Docker</strong> for isolated Python execution</li>
</ul>
<h2 id="installation-methods"><a class="header" href="#installation-methods">Installation Methods</a></h2>
<h3 id="method-1-install-from-cratesio-recommended"><a class="header" href="#method-1-install-from-cratesio-recommended">Method 1: Install from Crates.io (Recommended)</a></h3>
<pre><code class="language-bash">cargo install reflow
</code></pre>
<h3 id="method-2-build-from-source"><a class="header" href="#method-2-build-from-source">Method 2: Build from Source</a></h3>
<ol>
<li>
<p><strong>Clone the repository:</strong></p>
<pre><code class="language-bash">git clone https://github.com/your-org/reflow.git
cd reflow
</code></pre>
</li>
<li>
<p><strong>Build the project:</strong></p>
<pre><code class="language-bash">cargo build --release
</code></pre>
</li>
<li>
<p><strong>Install globally (optional):</strong></p>
<pre><code class="language-bash">cargo install --path .
</code></pre>
</li>
</ol>
<h3 id="method-3-use-as-a-library"><a class="header" href="#method-3-use-as-a-library">Method 3: Use as a Library</a></h3>
<p>Add Reflow to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
reflow_network = "0.1.0"
reflow_script = { version = "0.1.0", features = ["deno"] }
reflow_components = "0.1.0"
</code></pre>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>Reflow uses feature flags to control which runtimes are included:</p>
<pre><code class="language-toml">[dependencies]
reflow_script = { 
    version = "0.1.0", 
    features = [
        "deno",      # JavaScript/TypeScript support via Deno
        "python",    # Python script support
        "extism"     # WebAssembly plugin support
    ] 
}
</code></pre>
<h3 id="available-features"><a class="header" href="#available-features">Available Features</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th><th>Requirements</th></tr></thead><tbody>
<tr><td><code>deno</code></td><td>JavaScript/TypeScript runtime</td><td>Deno installed</td></tr>
<tr><td><code>python</code></td><td>Python script execution</td><td>Python 3.8+</td></tr>
<tr><td><code>extism</code></td><td>WebAssembly plugin support</td><td>None</td></tr>
<tr><td><code>flowtrace</code></td><td>Debug tracing support</td><td>None</td></tr>
</tbody></table>
</div>
<h2 id="runtime-dependencies"><a class="header" href="#runtime-dependencies">Runtime Dependencies</a></h2>
<h3 id="javascripttypescript-deno"><a class="header" href="#javascripttypescript-deno">JavaScript/TypeScript (Deno)</a></h3>
<p>Install Deno:</p>
<pre><code class="language-bash"># macOS/Linux
curl -fsSL https://deno.land/x/install/install.sh | sh

# Windows (PowerShell)
iwr https://deno.land/x/install/install.ps1 -useb | iex

# Using package managers
brew install deno          # macOS
scoop install deno         # Windows
snap install deno          # Linux
</code></pre>
<h3 id="python-support"><a class="header" href="#python-support">Python Support</a></h3>
<p>Install Python 3.8+:</p>
<pre><code class="language-bash"># macOS
brew install python

# Ubuntu/Debian
sudo apt update
sudo apt install python3 python3-pip

# Windows
# Download from https://python.org
</code></pre>
<p>For Docker-based Python execution:</p>
<pre><code class="language-bash"># Install Docker
# macOS/Windows: Docker Desktop
# Linux: docker.io package
sudo apt install docker.io  # Ubuntu/Debian
</code></pre>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>Verify your installation:</p>
<pre><code class="language-bash"># If installed globally
reflow --version

# If built from source
./target/release/reflow --version

# Test basic functionality
reflow test-actors
</code></pre>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<ul>
<li>Use Homebrew for easy dependency management</li>
<li>Xcode Command Line Tools required for Rust compilation</li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>Ensure <code>build-essential</code> is installed</li>
<li>Some distributions may need <code>pkg-config</code> and <code>libssl-dev</code></li>
</ul>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt install build-essential pkg-config libssl-dev

# CentOS/RHEL
sudo yum groupinstall "Development Tools"
sudo yum install openssl-devel
</code></pre>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<ul>
<li>Use Windows Subsystem for Linux (WSL) for best experience</li>
<li>Visual Studio Build Tools required for Rust compilation</li>
<li>Consider using <code>scoop</code> or <code>chocolatey</code> for dependency management</li>
</ul>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>Set these environment variables for optimal performance:</p>
<pre><code class="language-bash"># Enable shared Python environment (optional)
export USE_SHARED_ENV=true

# Set Python path (if needed)
export PYTHON_PATH=/usr/bin/python3

# Configure Deno permissions (optional)
export DENO_PERMISSIONS="--allow-all"
</code></pre>
<h3 id="config-file"><a class="header" href="#config-file">Config File</a></h3>
<p>Create a <code>reflow.toml</code> configuration file:</p>
<pre><code class="language-toml">[runtime]
default_engine = "deno"
enable_networking = true
enable_filesystem = true

[deno]
allow_all = false
allow_net = true
allow_read = true

[python]
use_docker = false
shared_environment = true

[performance]
thread_pool_size = 8
max_memory_mb = 1024
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that Reflow is installed:</p>
<ol>
<li><strong>Learn the basics</strong>: Read <a href="getting-started/./basic-concepts.html">Basic Concepts</a></li>
<li><strong>Set up development</strong>: Follow <a href="getting-started/./development-setup.html">Development Setup</a></li>
<li><strong>Create your first workflow</strong>: Try <a href="getting-started/./first-workflow.html">First Workflow</a></li>
<li><strong>Explore examples</strong>: Check out the <a href="getting-started/../examples/README.html">Examples</a></li>
</ol>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Rust compilation errors:</strong></p>
<pre><code class="language-bash"># Update Rust to latest version
rustup update
</code></pre>
<p><strong>Deno not found:</strong></p>
<pre><code class="language-bash"># Add Deno to PATH
export PATH="$HOME/.deno/bin:$PATH"
</code></pre>
<p><strong>Python import errors:</strong></p>
<pre><code class="language-bash"># Install required Python packages
pip install numpy pandas  # or other dependencies
</code></pre>
<p><strong>Permission denied errors:</strong></p>
<pre><code class="language-bash"># Fix file permissions
chmod +x reflow
</code></pre>
<p>For more troubleshooting, see the <a href="getting-started/../reference/troubleshooting-guide.html">Troubleshooting Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic Concepts</a></h1>
<p>This guide introduces the fundamental concepts of Reflow's actor-based workflow engine.</p>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="actors"><a class="header" href="#actors">Actors</a></h3>
<p><strong>Actors</strong> are the building blocks of Reflow workflows. Each actor is an isolated unit of computation that:</p>
<ul>
<li>Processes incoming messages</li>
<li>Maintains its own state</li>
<li>Communicates only through message passing</li>
<li>Runs concurrently with other actors</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Simple actor that doubles numbers (using actor macro)
use std::collections::HashMap;
use reflow_network::{
    actor::ActorContext,
    message::Message,
};
use actor_macro::actor;

#[actor(
    DoublerActor,
    inports::&lt;100&gt;(number),
    outports::&lt;50&gt;(result)
)]
async fn doubler_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    if let Some(Message::Integer(n)) = payload.get("number") {
        Ok([
            ("result".to_owned(), Message::Integer(n * 2))
        ].into())
    } else {
        Err(anyhow::anyhow!("Expected integer input"))
    }
}

// Alternative: Manual implementation
use reflow_network::actor::{Actor, ActorBehavior, Port, ActorLoad};
use parking_lot::Mutex;
use std::sync::Arc;

pub struct ManualDoublerActor {
    inports: Port,
    outports: Port,
    load: Arc&lt;Mutex&lt;ActorLoad&gt;&gt;,
}

impl ManualDoublerActor {
    pub fn new() -&gt; Self {
        Self {
            inports: flume::unbounded(),
            outports: flume::unbounded(),
            load: Arc::new(Mutex::new(ActorLoad::new(0))),
        }
    }
}

impl Actor for ManualDoublerActor {
    fn get_behavior(&amp;self) -&gt; ActorBehavior {
        Box::new(|context: ActorContext| {
            Box::pin(async move {
                let payload = context.get_payload();
                if let Some(Message::Integer(n)) = payload.get("number") {
                    Ok([
                        ("result".to_owned(), Message::Integer(n * 2))
                    ].into())
                } else {
                    Err(anyhow::anyhow!("Expected integer input"))
                }
            })
        })
    }
    
    fn get_inports(&amp;self) -&gt; Port { self.inports.clone() }
    fn get_outports(&amp;self) -&gt; Port { self.outports.clone() }
    fn load_count(&amp;self) -&gt; Arc&lt;Mutex&lt;ActorLoad&gt;&gt; { self.load.clone() }
    
    fn create_process(&amp;self) -&gt; std::pin::Pin&lt;Box&lt;dyn std::future::Future&lt;Output = ()&gt; + 'static + Send&gt;&gt; {
        // Process creation implementation...
        todo!("See creating-actors.md for complete implementation")
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="messages"><a class="header" href="#messages">Messages</a></h3>
<p><strong>Messages</strong> are the data that flows between actors. Reflow supports various message types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Message {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Array(Vec&lt;Message&gt;),
    Object(HashMap&lt;String, Message&gt;),
    Binary(Vec&lt;u8&gt;),
    Null,
    Error(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ports"><a class="header" href="#ports">Ports</a></h3>
<p><strong>Ports</strong> are the communication channels between actors:</p>
<ul>
<li><strong>Input ports (inports)</strong>: Receive messages from other actors</li>
<li><strong>Output ports (outports)</strong>: Send messages to other actors</li>
</ul>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Actor    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Logic â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚             â”‚
â”‚ in1 â”€â”€â”€â”€â”€â”€â†’ â”‚ â”€â”€â”€â”€â”€â”€â†’ out1
â”‚ in2 â”€â”€â”€â”€â”€â”€â†’ â”‚ â”€â”€â”€â”€â”€â”€â†’ out2
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="workflows-graphs"><a class="header" href="#workflows-graphs">Workflows (Graphs)</a></h3>
<p><strong>Workflows</strong> are directed graphs of connected actors that define:</p>
<ul>
<li>Data flow between actors</li>
<li>Processing logic and transformations</li>
<li>Execution order and dependencies</li>
</ul>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Source  â”‚â”€â”€â”€â–¶â”‚Transformâ”‚â”€â”€â”€â–¶â”‚  Sink   â”‚
â”‚ Actor   â”‚    â”‚ Actor   â”‚    â”‚ Actor   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h3 id="actor-state"><a class="header" href="#actor-state">Actor State</a></h3>
<p>Each actor can maintain its own <strong>state</strong> that persists between message processing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Counter actor with state (using actor macro)
use reflow_network::actor::MemoryState;

#[actor(
    CounterActor,
    state(MemoryState),
    inports::&lt;100&gt;(increment),
    outports::&lt;50&gt;(count)
)]
async fn counter_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    let state = context.get_state();
    
    let mut state_guard = state.lock();
    let memory_state = state_guard
        .as_mut_any()
        .downcast_mut::&lt;MemoryState&gt;()
        .expect("Expected MemoryState");
    
    // Initialize state if needed
    if !memory_state.contains_key("count") {
        memory_state.insert("count", serde_json::json!(0));
    }
    
    // Get current count
    let current_count = memory_state.get("count")
        .and_then(|v| v.as_i64())
        .unwrap_or(0);
    
    // Increment by 1 or by specified amount
    let increment_by = if let Some(Message::Integer(amount)) = payload.get("increment") {
        *amount
    } else {
        1 // Default increment
    };
    
    let new_count = current_count + increment_by;
    
    // Update state
    memory_state.insert("count", serde_json::json!(new_count));
    
    Ok([
        ("count".to_owned(), Message::Integer(new_count))
    ].into())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="actor-types"><a class="header" href="#actor-types">Actor Types</a></h2>
<h3 id="native-actors-rust"><a class="header" href="#native-actors-rust">Native Actors (Rust)</a></h3>
<p>Built directly in Rust for maximum performance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ProcessorActor {
    // Implementation in Rust
}
<span class="boring">}</span></code></pre></pre>
<h3 id="script-actors"><a class="header" href="#script-actors">Script Actors</a></h3>
<p>Execute scripts in various languages:</p>
<h4 id="javascripttypescript-deno-1"><a class="header" href="#javascripttypescript-deno-1">JavaScript/TypeScript (Deno)</a></h4>
<pre><code class="language-javascript">// JavaScript actor function
function process(inputs, context) {
    const data = inputs.data;
    return { result: data.toUpperCase() };
}
</code></pre>
<h4 id="python"><a class="header" href="#python">Python</a></h4>
<pre><code class="language-python"># Python actor script
import numpy as np

inputs = Context.get_inputs()
data = np.array(inputs["data"])
__return_value = data.sum()
</code></pre>
<h4 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WASM actor (compiled from Rust, C++, etc.)
#[no_mangle]
pub extern "C" fn process(input: &amp;str) -&gt; String {
    // Process input and return result
    format!("Processed: {}", input)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-passing-patterns"><a class="header" href="#message-passing-patterns">Message Passing Patterns</a></h2>
<h3 id="point-to-point"><a class="header" href="#point-to-point">Point-to-Point</a></h3>
<p>One actor sends to one specific actor:</p>
<pre><code>Actor A â”€â”€â”€â”€â”€â”€â”€â–¶ Actor B
</code></pre>
<h3 id="broadcast"><a class="header" href="#broadcast">Broadcast</a></h3>
<p>One actor sends to multiple actors:</p>
<pre><code>        â”Œâ”€â”€â”€â”€â”€â–¶ Actor B
Actor A â”¤
        â””â”€â”€â”€â”€â”€â–¶ Actor C
</code></pre>
<h3 id="collectmerge"><a class="header" href="#collectmerge">Collect/Merge</a></h3>
<p>Multiple actors send to one actor:</p>
<pre><code>Actor A â”
        â”œâ”€â”€â”€â”€â”€â–¶ Actor C
Actor B â”˜
</code></pre>
<h2 id="concurrency-model"><a class="header" href="#concurrency-model">Concurrency Model</a></h2>
<h3 id="actor-isolation"><a class="header" href="#actor-isolation">Actor Isolation</a></h3>
<ul>
<li>Each actor runs in its own execution context</li>
<li>No shared memory between actors</li>
<li>Thread-safe by design</li>
</ul>
<h3 id="message-processing"><a class="header" href="#message-processing">Message Processing</a></h3>
<ul>
<li>Actors process messages asynchronously</li>
<li>Messages are queued for processing</li>
<li>Backpressure handling prevents overflow</li>
</ul>
<h3 id="parallelism"><a class="header" href="#parallelism">Parallelism</a></h3>
<ul>
<li>Multiple actors can run simultaneously</li>
<li>Work is distributed across available CPU cores</li>
<li>Network can span multiple machines</li>
</ul>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="actor-level-errors"><a class="header" href="#actor-level-errors">Actor-Level Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Errors are returned as Error messages
Err(anyhow::anyhow!("Processing failed"))
<span class="boring">}</span></code></pre></pre>
<h3 id="network-level-errors"><a class="header" href="#network-level-errors">Network-Level Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Error propagation through the network
HashMap::from([
    ("error".to_string(), Message::Error("Network timeout".to_string()))
])
<span class="boring">}</span></code></pre></pre>
<h3 id="recovery-patterns"><a class="header" href="#recovery-patterns">Recovery Patterns</a></h3>
<ul>
<li>Dead letter queues for failed messages</li>
<li>Circuit breakers for failing actors</li>
<li>Supervisor actors for monitoring</li>
</ul>
<h2 id="lifecycle-management"><a class="header" href="#lifecycle-management">Lifecycle Management</a></h2>
<h3 id="actor-creation"><a class="header" href="#actor-creation">Actor Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let actor = MyActor::new(config);
let process = actor.create_process();
tokio::spawn(process);
<span class="boring">}</span></code></pre></pre>
<h3 id="actor-termination"><a class="header" href="#actor-termination">Actor Termination</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Graceful shutdown
drop(inports); // Closes input channels
// Actor completes current message and exits
<span class="boring">}</span></code></pre></pre>
<h3 id="state-persistence"><a class="header" href="#state-persistence">State Persistence</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// State can be persisted and restored
let state = actor.get_state();
// Serialize state for persistence
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-concepts"><a class="header" href="#advanced-concepts">Advanced Concepts</a></h2>
<h3 id="hot-code-reloading"><a class="header" href="#hot-code-reloading">Hot Code Reloading</a></h3>
<ul>
<li>Script actors can be updated without stopping the workflow</li>
<li>State preservation during updates</li>
</ul>
<h3 id="multi-tenancy"><a class="header" href="#multi-tenancy">Multi-tenancy</a></h3>
<ul>
<li>Isolated workspaces for different users/projects</li>
<li>Resource quotas and permissions</li>
</ul>
<h3 id="distributed-execution"><a class="header" href="#distributed-execution">Distributed Execution</a></h3>
<ul>
<li>Actors can run on different machines</li>
<li>Network-transparent message passing</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="actor-design"><a class="header" href="#actor-design">Actor Design</a></h3>
<ul>
<li>Keep actors small and focused</li>
<li>Avoid blocking operations in actor logic</li>
<li>Use async/await for I/O operations</li>
</ul>
<h3 id="message-design"><a class="header" href="#message-design">Message Design</a></h3>
<ul>
<li>Use typed messages when possible</li>
<li>Keep messages small and serializable</li>
<li>Include error context in error messages</li>
</ul>
<h3 id="workflow-design"><a class="header" href="#workflow-design">Workflow Design</a></h3>
<ul>
<li>Design for failure (circuit breakers, timeouts)</li>
<li>Monitor actor performance and health</li>
<li>Use appropriate parallelism levels</li>
</ul>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you understand the basic concepts:</p>
<ol>
<li><strong>Set up development</strong>: <a href="getting-started/./development-setup.html">Development Setup</a></li>
<li><strong>Create your first workflow</strong>: <a href="getting-started/./first-workflow.html">First Workflow</a></li>
<li><strong>Learn about specific actors</strong>: <a href="getting-started/../api/actors/creating-actors.html">Actor API</a></li>
<li><strong>Explore scripting</strong>: <a href="getting-started/../scripting/javascript/deno-runtime.html">JavaScript Runtime</a></li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="getting-started/../architecture/actor-model.html">Actor Model Theory</a></li>
<li><a href="getting-started/../architecture/message-passing.html">Message Passing Details</a></li>
<li><a href="getting-started/../architecture/performance-considerations.html">Performance Considerations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h1>
<p>This guide helps you set up a development environment for building workflows with Reflow.</p>
<h2 id="development-environment"><a class="header" href="#development-environment">Development Environment</a></h2>
<h3 id="recommended-tools"><a class="header" href="#recommended-tools">Recommended Tools</a></h3>
<ul>
<li><strong>IDE</strong>: Visual Studio Code or RustRover</li>
<li><strong>Version Control</strong>: Git</li>
<li><strong>Package Manager</strong>: Cargo for Rust dependencies</li>
<li><strong>Terminal</strong>: Modern terminal with good Unicode support</li>
</ul>
<h3 id="vs-code-extensions"><a class="header" href="#vs-code-extensions">VS Code Extensions</a></h3>
<p>For the best development experience with VS Code:</p>
<pre><code class="language-json">{
  "recommendations": [
    "rust-lang.rust-analyzer",
    "vadimcn.vscode-lldb",
    "serayuzgur.crates",
    "tamasfe.even-better-toml",
    "ms-vscode.vscode-json"
  ]
}
</code></pre>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<h3 id="creating-a-new-reflow-project"><a class="header" href="#creating-a-new-reflow-project">Creating a New Reflow Project</a></h3>
<pre><code class="language-bash"># Create a new Rust project
cargo new my-reflow-app
cd my-reflow-app

# Add Reflow dependencies
cargo add reflow_network reflow_script reflow_components
</code></pre>
<h3 id="recommended-project-structure"><a class="header" href="#recommended-project-structure">Recommended Project Structure</a></h3>
<pre><code>my-reflow-app/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ actors/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ custom_actor.rs
â”‚   â”œâ”€â”€ workflows/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ data_pipeline.rs
â”‚   â””â”€â”€ scripts/
â”‚       â”œâ”€â”€ process.js
â”‚       â””â”€â”€ transform.py
â”œâ”€â”€ config/
â”‚   â””â”€â”€ reflow.toml
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ integration_tests.rs
â””â”€â”€ examples/
    â””â”€â”€ basic_workflow.rs
</code></pre>
<h3 id="cargotoml-configuration"><a class="header" href="#cargotoml-configuration">Cargo.toml Configuration</a></h3>
<pre><code class="language-toml">[package]
name = "my-reflow-app"
version = "0.1.0"
edition = "2021"

[dependencies]
reflow_network = "0.1.0"
reflow_script = { version = "0.1.0", features = ["deno", "python"] }
reflow_components = "0.1.0"
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"

[dev-dependencies]
tokio-test = "0.4"

[[example]]
name = "basic_workflow"
path = "examples/basic_workflow.rs"
</code></pre>
<h2 id="development-workflow"><a class="header" href="#development-workflow">Development Workflow</a></h2>
<h3 id="1-setting-up-the-main-application"><a class="header" href="#1-setting-up-the-main-application">1. Setting Up the Main Application</a></h3>
<p>Create <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use reflow_network::network::Network;
use reflow_script::{ScriptActor, ScriptConfig, ScriptRuntime, ScriptEnvironment};
use tokio;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize logging
    env_logger::init();
    
    // Create a network
    let mut network = Network::new();
    
    // Add actors to the network
    // ... your workflow setup
    
    // Start the network
    network.start().await?;
    
    Ok(())
}</code></pre></pre>
<h3 id="2-creating-custom-actors"><a class="header" href="#2-creating-custom-actors">2. Creating Custom Actors</a></h3>
<p>Create <code>src/actors/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod custom_actor;

pub use custom_actor::CustomActor;
<span class="boring">}</span></code></pre></pre>
<p>Create <code>src/actors/custom_actor.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::actor::{Actor, ActorBehavior, ActorContext, Port};
use reflow_network::message::Message;
use std::collections::HashMap;

pub struct CustomActor {
    inports: Port,
    outports: Port,
}

impl CustomActor {
    pub fn new() -&gt; Self {
        Self {
            inports: flume::unbounded(),
            outports: flume::unbounded(),
        }
    }
}

impl Actor for CustomActor {
    fn get_behavior(&amp;self) -&gt; ActorBehavior {
        Box::new(|context: ActorContext| {
            Box::pin(async move {
                let payload = context.get_payload();
                
                // Your processing logic here
                let result = HashMap::from([
                    ("output".to_string(), Message::String("processed".to_string()))
                ]);
                
                Ok(result)
            })
        })
    }
    
    fn get_inports(&amp;self) -&gt; Port {
        self.inports.clone()
    }
    
    fn get_outports(&amp;self) -&gt; Port {
        self.outports.clone()
    }
    
    fn create_process(&amp;self) -&gt; std::pin::Pin&lt;Box&lt;dyn std::future::Future&lt;Output = ()&gt; + 'static + Send&gt;&gt; {
        // Default implementation from trait
        todo!("Implement process creation")
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-organizing-workflows"><a class="header" href="#3-organizing-workflows">3. Organizing Workflows</a></h3>
<p>Create <code>src/workflows/mod.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod data_pipeline;

pub use data_pipeline::create_data_pipeline;
<span class="boring">}</span></code></pre></pre>
<p>Create <code>src/workflows/data_pipeline.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::network::Network;
use crate::actors::CustomActor;

pub async fn create_data_pipeline() -&gt; Result&lt;Network, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut network = Network::new();
    
    // Create actors
    let source_actor = CustomActor::new();
    let transform_actor = CustomActor::new();
    let sink_actor = CustomActor::new();
    
    // Add actors to network
    network.add_actor("source", Box::new(source_actor)).await?;
    network.add_actor("transform", Box::new(transform_actor)).await?;
    network.add_actor("sink", Box::new(sink_actor)).await?;
    
    // Connect actors
    network.connect("source", "output", "transform", "input").await?;
    network.connect("transform", "output", "sink", "input").await?;
    
    Ok(network)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-setup"><a class="header" href="#testing-setup">Testing Setup</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<p>Create <code>src/actors/custom_actor.rs</code> with tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    
    #[tokio::test]
    async fn test_custom_actor() {
        let actor = CustomActor::new();
        let behavior = actor.get_behavior();
        
        // Create test context
        let payload = HashMap::from([
            ("input".to_string(), Message::String("test".to_string()))
        ]);
        
        // Test behavior
        // Note: You'll need to create proper ActorContext for testing
        let result = behavior(/* test context */).await;
        assert!(result.is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>Create <code>tests/integration_tests.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use my_reflow_app::workflows::create_data_pipeline;

#[tokio::test]
async fn test_data_pipeline() {
    let network = create_data_pipeline().await.unwrap();
    
    // Test the complete workflow
    // Send test data and verify output
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h2>
<h3 id="environment-configuration"><a class="header" href="#environment-configuration">Environment Configuration</a></h3>
<p>Create <code>config/reflow.toml</code>:</p>
<pre><code class="language-toml">[development]
log_level = "debug"
thread_pool_size = 4

[production]
log_level = "info"
thread_pool_size = 8

[scripting]
deno_permissions = ["--allow-net", "--allow-read"]
python_interpreter = "python3"

[networking]
bind_address = "127.0.0.1:8080"
enable_metrics = true
</code></pre>
<h3 id="loading-configuration"><a class="header" href="#loading-configuration">Loading Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};
use std::fs;

#[derive(Debug, Deserialize, Serialize)]
struct Config {
    development: Option&lt;EnvConfig&gt;,
    production: Option&lt;EnvConfig&gt;,
    scripting: Option&lt;ScriptingConfig&gt;,
    networking: Option&lt;NetworkingConfig&gt;,
}

#[derive(Debug, Deserialize, Serialize)]
struct EnvConfig {
    log_level: String,
    thread_pool_size: usize,
}

fn load_config() -&gt; Result&lt;Config, Box&lt;dyn std::error::Error&gt;&gt; {
    let config_str = fs::read_to_string("config/reflow.toml")?;
    let config: Config = toml::from_str(&amp;config_str)?;
    Ok(config)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="development-scripts"><a class="header" href="#development-scripts">Development Scripts</a></h2>
<h3 id="makefile"><a class="header" href="#makefile">Makefile</a></h3>
<p>Create a <code>Makefile</code> for common tasks:</p>
<pre><code class="language-makefile">.PHONY: build test run clean docs

build:
	cargo build

test:
	cargo test

run:
	cargo run

clean:
	cargo clean

docs:
	cargo doc --open

check:
	cargo check
	cargo clippy -- -D warnings
	cargo fmt -- --check

dev:
	cargo watch -x run

install-tools:
	cargo install cargo-watch
	cargo install cargo-expand
</code></pre>
<h3 id="development-commands"><a class="header" href="#development-commands">Development Commands</a></h3>
<pre><code class="language-bash"># Development workflow
make build          # Build the project
make test           # Run tests
make check          # Run linting and formatting checks
make dev            # Run with auto-reload on changes

# Documentation
make docs           # Generate and open documentation
cargo doc --document-private-items  # Include private items
</code></pre>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="logging-setup"><a class="header" href="#logging-setup">Logging Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, warn, error, debug};
use tracing_subscriber;

// In main.rs
fn init_logging() {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();
}

// In your actors
debug!("Processing message: {:?}", message);
info!("Actor started successfully");
warn!("High memory usage detected");
error!("Failed to process message: {}", error);
<span class="boring">}</span></code></pre></pre>
<h3 id="debug-configuration"><a class="header" href="#debug-configuration">Debug Configuration</a></h3>
<p>Add to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.dev]
debug = true
debug-assertions = true
overflow-checks = true

[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"
</code></pre>
<h3 id="using-debugger"><a class="header" href="#using-debugger">Using Debugger</a></h3>
<p>For VS Code, create <code>.vscode/launch.json</code>:</p>
<pre><code class="language-json">{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug Reflow App",
            "cargo": {
                "args": ["build", "--bin=my-reflow-app"],
                "filter": {
                    "name": "my-reflow-app",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
</code></pre>
<h2 id="performance-profiling"><a class="header" href="#performance-profiling">Performance Profiling</a></h2>
<h3 id="basic-profiling"><a class="header" href="#basic-profiling">Basic Profiling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;

// Time critical sections
let start = Instant::now();
// ... your code
let duration = start.elapsed();
println!("Time elapsed: {:?}", duration);
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-profiling-tools"><a class="header" href="#advanced-profiling-tools">Advanced Profiling Tools</a></h3>
<pre><code class="language-bash"># Install profiling tools
cargo install cargo-profiler
cargo install flamegraph

# Generate flame graphs
cargo flamegraph --bin my-reflow-app

# Memory profiling with valgrind (Linux)
cargo build --release
valgrind --tool=massif ./target/release/my-reflow-app
</code></pre>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<p>Create <code>.github/workflows/ci.yml</code>:</p>
<pre><code class="language-yaml">name: CI

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
    - name: Build
      run: cargo build --verbose
    - name: Run tests
      run: cargo test --verbose
    - name: Check formatting
      run: cargo fmt -- --check
    - name: Run clippy
      run: cargo clippy -- -D warnings
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Now that your development environment is set up:</p>
<ol>
<li><strong>Create your first workflow</strong>: <a href="getting-started/./first-workflow.html">First Workflow</a></li>
<li><strong>Learn about actors</strong>: <a href="getting-started/../api/actors/creating-actors.html">Creating Actors</a></li>
<li><strong>Explore scripting</strong>: <a href="getting-started/../scripting/javascript/deno-runtime.html">Deno Runtime</a></li>
<li><strong>See examples</strong>: <a href="getting-started/../examples/README.html">Examples</a></li>
</ol>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/">Rust Book</a></li>
<li><a href="https://tokio.rs/tokio/tutorial">Tokio Tutorial</a></li>
<li><a href="getting-started/../examples/README.html">Reflow Examples</a></li>
<li><a href="getting-started/../reference/api-reference.html">API Reference</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-workflow"><a class="header" href="#your-first-workflow">Your First Workflow</a></h1>
<p>This tutorial will guide you through creating and running your first Reflow workflow using the actual implementation patterns. We'll build a simple data processing pipeline that demonstrates the core concepts.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>We'll create a workflow that:</p>
<ol>
<li>Processes input numbers (Sum Actor)</li>
<li>Squares the result (Square Actor)</li>
<li>Validates the output (Assert Actor)</li>
</ol>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Sum   â”‚â”€â”€â”€â–¶â”‚ Square  â”‚â”€â”€â”€â–¶â”‚ Assert  â”‚
â”‚ Actor   â”‚    â”‚ Actor   â”‚    â”‚ Actor   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Before starting, make sure you have:</p>
<ul>
<li>Completed the <a href="getting-started/./installation.html">Installation</a> guide</li>
<li>Set up your <a href="getting-started/./development-setup.html">Development Environment</a></li>
<li>Understanding of <a href="getting-started/./basic-concepts.html">Basic Concepts</a></li>
</ul>
<h2 id="step-1-create-a-new-project"><a class="header" href="#step-1-create-a-new-project">Step 1: Create a New Project</a></h2>
<pre><code class="language-bash"># Create a new Rust project
cargo new hello-reflow
cd hello-reflow

# Add Reflow dependencies
cargo add reflow_network
cargo add actor_macro
cargo add tokio --features full
cargo add serde --features derive
cargo add serde_json anyhow
cargo add parking_lot
</code></pre>
<p>Your <code>Cargo.toml</code> should look like this:</p>
<pre><code class="language-toml">[package]
name = "hello-reflow"
version = "0.1.0"
edition = "2021"

[dependencies]
reflow_network = { path = "../path/to/reflow/crates/reflow_network" }
actor_macro = { path = "../path/to/reflow/crates/actor_macro" }
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
parking_lot = "0.12"
</code></pre>
<h2 id="step-2-create-your-first-actors"><a class="header" href="#step-2-create-your-first-actors">Step 2: Create Your First Actors</a></h2>
<p>Create <code>src/main.rs</code> with the correct actor patterns:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;
use reflow_network::{
    actor::{ActorContext, MemoryState},
    network::{Network, NetworkConfig},
    connector::{ConnectionPoint, Connector, InitialPacket},
    message::Message,
};
use actor_macro::actor;

// Sum Actor - adds two input numbers
#[actor(
    SumActor,
    inports::&lt;100&gt;(A, B),
    outports::&lt;100&gt;(Out),
    await_all_inports
)]
async fn sum_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();

    let a_msg = payload.get("A").expect("expected to get data from port A");
    let b_msg = payload.get("B").expect("expected to get data from port B");

    let a = match a_msg {
        Message::Integer(value) =&gt; *value,
        _ =&gt; 0,
    };

    let b = match b_msg {
        Message::Integer(value) =&gt; *value,
        _ =&gt; 0,
    };

    let result = a + b;
    println!("Sum Actor: {} + {} = {}", a, b, result);

    Ok([("Out".to_owned(), Message::Integer(result))].into())
}

// Square Actor - squares the input number
#[actor(
    SquareActor,
    inports::&lt;100&gt;(In),
    outports::&lt;50&gt;(Out)
)]
async fn square_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    let message = payload.get("In").expect("expected input");
    
    let input = match message {
        Message::Integer(value) =&gt; *value,
        _ =&gt; 0,
    };

    let result = input * input;
    println!("Square Actor: {} squared = {}", input, result);

    Ok([("Out".to_owned(), Message::Integer(result))].into())
}

// Print Actor - displays the final result
#[actor(
    PrintActor,
    inports::&lt;100&gt;(Value),
    outports::&lt;50&gt;(Done)
)]
async fn print_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    let message = payload.get("Value").expect("expected value");
    
    match message {
        Message::Integer(value) =&gt; {
            println!("ğŸ‰ Final Result: {}", value);
        },
        _ =&gt; {
            println!("ğŸ“„ Final Result: {:?}", message);
        }
    }

    Ok([("Done".to_owned(), Message::Boolean(true))].into())
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    println!("ğŸš€ Starting Hello Reflow workflow...");
    
    // Create network with default configuration
    let mut network = Network::new(NetworkConfig::default());

    // Register actor types
    network.register_actor("sum_process", SumActor::new())?;
    network.register_actor("square_process", SquareActor::new())?;
    network.register_actor("print_process", PrintActor::new())?;

    // Add actor instances (nodes)
    network.add_node("sum", "sum_process")?;
    network.add_node("square", "square_process")?;
    network.add_node("print", "print_process")?;

    // Connect the workflow: sum -&gt; square -&gt; print
    network.add_connection(Connector {
        from: ConnectionPoint {
            actor: "sum".to_owned(),
            port: "Out".to_owned(),
            ..Default::default()
        },
        to: ConnectionPoint {
            actor: "square".to_owned(),
            port: "In".to_owned(),
            ..Default::default()
        },
    });

    network.add_connection(Connector {
        from: ConnectionPoint {
            actor: "square".to_owned(),
            port: "Out".to_owned(),
            ..Default::default()
        },
        to: ConnectionPoint {
            actor: "print".to_owned(),
            port: "Value".to_owned(),
            ..Default::default()
        },
    });

    // Add initial data to start the workflow
    network.add_initial(InitialPacket {
        to: ConnectionPoint {
            actor: "sum".to_owned(),
            port: "A".to_owned(),
            initial_data: Some(Message::Integer(5)),
        },
    });

    network.add_initial(InitialPacket {
        to: ConnectionPoint {
            actor: "sum".to_owned(),
            port: "B".to_owned(),
            initial_data: Some(Message::Integer(3)),
        },
    });

    // Start the network
    network.start().await?;

    // Give the workflow time to complete
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    println!("âœ… Workflow completed!");
    
    Ok(())
}</code></pre></pre>
<h2 id="step-3-run-the-workflow"><a class="header" href="#step-3-run-the-workflow">Step 3: Run the Workflow</a></h2>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see output like:</p>
<pre><code>ğŸš€ Starting Hello Reflow workflow...
Sum Actor: 5 + 3 = 8
Square Actor: 8 squared = 64
ğŸ‰ Final Result: 64
âœ… Workflow completed!
</code></pre>
<h2 id="step-4-understanding-the-code"><a class="header" href="#step-4-understanding-the-code">Step 4: Understanding the Code</a></h2>
<h3 id="actor-macro-usage"><a class="header" href="#actor-macro-usage">Actor Macro Usage</a></h3>
<p>The <code>#[actor]</code> macro simplifies actor creation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actor(
    SumActor,                    // Generated struct name
    inports::&lt;100&gt;(A, B),        // Input ports with capacity
    outports::&lt;100&gt;(Out),        // Output ports with capacity
    await_all_inports            // Wait for all inputs before processing
)]
async fn sum_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt;
<span class="boring">}</span></code></pre></pre>
<h3 id="function-signature"><a class="header" href="#function-signature">Function Signature</a></h3>
<p>All actor functions must have this exact signature:</p>
<ul>
<li><code>async fn</code> - Asynchronous function</li>
<li><code>context: ActorContext</code> - Single parameter containing payload, state, config</li>
<li><code>Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt;</code> - Return type</li>
</ul>
<h3 id="network-api-pattern"><a class="header" href="#network-api-pattern">Network API Pattern</a></h3>
<ol>
<li><strong>Register</strong> actor types: <code>network.register_actor("name", ActorStruct::new())</code></li>
<li><strong>Add</strong> node instances: <code>network.add_node("instance_id", "actor_type")</code></li>
<li><strong>Connect</strong> with <code>Connector</code> structs</li>
<li><strong>Initialize</strong> with <code>InitialPacket</code> structs</li>
</ol>
<h2 id="step-5-add-state-management"><a class="header" href="#step-5-add-state-management">Step 5: Add State Management</a></h2>
<p>Let's create a stateful actor that counts operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Counter Actor - keeps track of how many values it has processed
#[actor(
    CounterActor,
    state(MemoryState),
    inports::&lt;100&gt;(Value),
    outports::&lt;50&gt;(Count, Total)
)]
async fn counter_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    let state = context.get_state();
    let input = payload.get("Value").expect("expected value");
    
    let value = match input {
        Message::Integer(n) =&gt; *n,
        _ =&gt; 0,
    };

    // Update state
    let (count, total) = {
        let mut state_guard = state.lock();
        let memory_state = state_guard
            .as_mut_any()
            .downcast_mut::&lt;MemoryState&gt;()
            .expect("Expected MemoryState");
        
        // Get current count and total
        let current_count = memory_state
            .get("count")
            .and_then(|v| v.as_i64())
            .unwrap_or(0);
        
        let current_total = memory_state
            .get("total")
            .and_then(|v| v.as_i64())
            .unwrap_or(0);
        
        // Update values
        let new_count = current_count + 1;
        let new_total = current_total + value;
        
        memory_state.insert("count", serde_json::json!(new_count));
        memory_state.insert("total", serde_json::json!(new_total));
        
        (new_count, new_total)
    };

    println!("Counter Actor: processed {} values, total sum: {}", count, total);

    Ok([
        ("Count".to_owned(), Message::Integer(count)),
        ("Total".to_owned(), Message::Integer(total)),
    ].into())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-6-multiple-input-example"><a class="header" href="#step-6-multiple-input-example">Step 6: Multiple Input Example</a></h2>
<p>Create an actor that waits for multiple inputs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Multiply Actor - multiplies two inputs
#[actor(
    MultiplyActor,
    inports::&lt;100&gt;(X, Y),
    outports::&lt;50&gt;(Result),
    await_all_inports  // This makes it wait for both X and Y
)]
async fn multiply_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();

    let x = match payload.get("X").expect("expected X") {
        Message::Integer(value) =&gt; *value,
        _ =&gt; 1,
    };

    let y = match payload.get("Y").expect("expected Y") {
        Message::Integer(value) =&gt; *value,
        _ =&gt; 1,
    };

    let result = x * y;
    println!("Multiply Actor: {} Ã— {} = {}", x, y, result);

    Ok([("Result".to_owned(), Message::Integer(result))].into())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-7-complex-workflow-example"><a class="header" href="#step-7-complex-workflow-example">Step 7: Complex Workflow Example</a></h2>
<p>Here's a more complex workflow that demonstrates multiple patterns:</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    println!("ğŸš€ Starting Complex Reflow workflow...");
    
    let mut network = Network::new(NetworkConfig::default());

    // Register all actor types
    network.register_actor("sum_process", SumActor::new())?;
    network.register_actor("multiply_process", MultiplyActor::new())?;
    network.register_actor("counter_process", CounterActor::new())?;
    network.register_actor("print_process", PrintActor::new())?;

    // Create network topology
    network.add_node("sum1", "sum_process")?;
    network.add_node("multiply1", "multiply_process")?;
    network.add_node("counter1", "counter_process")?;
    network.add_node("print1", "print_process")?;

    // Connect workflow
    network.add_connection(Connector {
        from: ConnectionPoint {
            actor: "sum1".to_owned(),
            port: "Out".to_owned(),
            ..Default::default()
        },
        to: ConnectionPoint {
            actor: "multiply1".to_owned(),
            port: "X".to_owned(),
            ..Default::default()
        },
    });

    network.add_connection(Connector {
        from: ConnectionPoint {
            actor: "multiply1".to_owned(),
            port: "Result".to_owned(),
            ..Default::default()
        },
        to: ConnectionPoint {
            actor: "counter1".to_owned(),
            port: "Value".to_owned(),
            ..Default::default()
        },
    });

    network.add_connection(Connector {
        from: ConnectionPoint {
            actor: "counter1".to_owned(),
            port: "Total".to_owned(),
            ..Default::default()
        },
        to: ConnectionPoint {
            actor: "print1".to_owned(),
            port: "Value".to_owned(),
            ..Default::default()
        },
    });

    // Initial data
    network.add_initial(InitialPacket {
        to: ConnectionPoint {
            actor: "sum1".to_owned(),
            port: "A".to_owned(),
            initial_data: Some(Message::Integer(10)),
        },
    });

    network.add_initial(InitialPacket {
        to: ConnectionPoint {
            actor: "sum1".to_owned(),
            port: "B".to_owned(),
            initial_data: Some(Message::Integer(5)),
        },
    });

    network.add_initial(InitialPacket {
        to: ConnectionPoint {
            actor: "multiply1".to_owned(),
            port: "Y".to_owned(),
            initial_data: Some(Message::Integer(3)),
        },
    });

    // Start the network
    network.start().await?;
    
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    
    println!("âœ… Complex workflow completed!");
    
    Ok(())
}</code></pre></pre>
<p>Expected output:</p>
<pre><code>ğŸš€ Starting Complex Reflow workflow...
Sum Actor: 10 + 5 = 15
Multiply Actor: 15 Ã— 3 = 45
Counter Actor: processed 1 values, total sum: 45
ğŸ‰ Final Result: 45
âœ… Complex workflow completed!
</code></pre>
<h2 id="key-concepts-demonstrated"><a class="header" href="#key-concepts-demonstrated">Key Concepts Demonstrated</a></h2>
<h3 id="actor-macro-features"><a class="header" href="#actor-macro-features">Actor Macro Features</a></h3>
<ul>
<li><strong>Port Definitions</strong>: <code>inports::&lt;capacity&gt;(Port1, Port2)</code></li>
<li><strong>State Management</strong>: <code>state(MemoryState)</code> for stateful actors</li>
<li><strong>Input Synchronization</strong>: <code>await_all_inports</code> waits for all inputs</li>
</ul>
<h3 id="network-configuration"><a class="header" href="#network-configuration">Network Configuration</a></h3>
<ul>
<li><strong>Registration</strong>: Register actor types before use</li>
<li><strong>Instantiation</strong>: Create specific instances with unique IDs</li>
<li><strong>Connection</strong>: Use structured <code>Connector</code> objects</li>
<li><strong>Initialization</strong>: Send initial data with <code>InitialPacket</code></li>
</ul>
<h3 id="message-flow"><a class="header" href="#message-flow">Message Flow</a></h3>
<ul>
<li>Messages flow through typed ports</li>
<li>Actors process inputs and produce outputs</li>
<li>State is maintained per actor instance</li>
</ul>
<h2 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h2>
<p>Actors can return errors that will be logged:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actor(
    ValidatorActor,
    inports::&lt;100&gt;(Input),
    outports::&lt;50&gt;(Valid, Invalid)
)]
async fn validator_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    let input = payload.get("Input").expect("expected input");
    
    match input {
        Message::Integer(n) if *n &gt; 0 =&gt; {
            Ok([("Valid".to_owned(), input.clone())].into())
        },
        Message::Integer(n) if *n &lt;= 0 =&gt; {
            Ok([("Invalid".to_owned(), input.clone())].into())
        },
        _ =&gt; {
            Err(anyhow::anyhow!("Expected integer input, got {:?}", input))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Now that you understand the basic patterns:</p>
<ol>
<li><strong>Learn more actor patterns</strong>: <a href="getting-started/../api/actors/creating-actors.html">Creating Actors</a></li>
<li><strong>Explore message types</strong>: <a href="getting-started/../architecture/message-passing.html">Message Passing</a></li>
<li><strong>Add scripting</strong>: <a href="getting-started/../scripting/javascript/deno-runtime.html">JavaScript Integration</a></li>
<li><strong>Use pre-built components</strong>: <a href="getting-started/../components/standard-library.html">Standard Library</a></li>
<li><strong>See more examples</strong>: <a href="getting-started/../examples/README.html">Examples</a></li>
</ol>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h3>
<p><strong>Compilation errors with actor macro</strong>: Make sure <code>actor_macro</code> is in your dependencies</p>
<p><strong>Port connection errors</strong>: Verify port names match exactly between connections</p>
<p><strong>Runtime panics</strong>: Check that initial data types match what actors expect</p>
<p><strong>Deadlocks</strong>: Ensure <code>await_all_inports</code> actors receive all required inputs</p>
<p>For more help, see the <a href="getting-started/../reference/troubleshooting-guide.html">Troubleshooting Guide</a>.</p>
<h2 id="complete-example-code"><a class="header" href="#complete-example-code">Complete Example Code</a></h2>
<p>The complete working examples are available in the <a href="getting-started/../examples/tutorials/hello-reflow/">examples directory</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>This document provides a high-level overview of Reflow's architecture, covering its core components, design principles, and system interactions.</p>
<h2 id="system-architecture"><a class="header" href="#system-architecture">System Architecture</a></h2>
<p>Reflow follows a modular, actor-based architecture designed for scalability, reliability, and multi-language support.</p>
<pre><code class="language-mermaid">graph TB
    subgraph "Application Layer"
        WF[Workflows]
        SC[Scripts]
        CP[Components]
    end
    
    subgraph "Actor System"
        AC[Actor Core]
        MSG[Message System]
        NET[Network Layer]
    end
    
    subgraph "Runtime Layer"
        DR[Deno Runtime]
        PR[Python Runtime]
        WR[WASM Runtime]
        NR[Native Runtime]
    end
    
    subgraph "Infrastructure"
        THR[Thread Pool]
        SER[Serialization]
        NET_IO[Network I/O]
        FS[File System]
    end
    
    WF --&gt; AC
    SC --&gt; DR
    SC --&gt; PR
    SC --&gt; WR
    CP --&gt; NR
    
    AC --&gt; MSG
    MSG --&gt; NET
    
    NET --&gt; THR
    NET --&gt; SER
    NET --&gt; NET_IO
    NET --&gt; FS
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="1-actor-system-reflow_network"><a class="header" href="#1-actor-system-reflow_network">1. Actor System (<code>reflow_network</code>)</a></h3>
<p>The foundation of Reflow, implementing the actor model for concurrent computation:</p>
<ul>
<li><strong>Actors</strong>: Isolated units of computation</li>
<li><strong>Messages</strong>: Immutable data passed between actors</li>
<li><strong>Ports</strong>: Communication channels (input/output)</li>
<li><strong>Network</strong>: Manages actor lifecycle and message routing</li>
</ul>
<h3 id="2-script-runtime-reflow_script"><a class="header" href="#2-script-runtime-reflow_script">2. Script Runtime (<code>reflow_script</code>)</a></h3>
<p>Multi-language execution environment supporting:</p>
<ul>
<li><strong>Deno Runtime</strong>: JavaScript/TypeScript execution</li>
<li><strong>Python Engine</strong>: Python script execution (with optional Docker isolation)</li>
<li><strong>WebAssembly</strong>: WASM plugin system via Extism</li>
<li><strong>Script Context</strong>: Execution environment and state management</li>
</ul>
<h3 id="3-component-library-reflow_components"><a class="header" href="#3-component-library-reflow_components">3. Component Library (<code>reflow_components</code>)</a></h3>
<p>Pre-built, reusable workflow components:</p>
<ul>
<li><strong>Flow Control</strong>: Conditional logic, loops, branching</li>
<li><strong>Data Operations</strong>: Transformations, aggregations, validation</li>
<li><strong>Integration</strong>: External API connectivity</li>
<li><strong>Synchronization</strong>: Coordination primitives</li>
</ul>
<h3 id="4-network-layer-reflow_network"><a class="header" href="#4-network-layer-reflow_network">4. Network Layer (<code>reflow_network</code>)</a></h3>
<p>Handles distributed execution and communication:</p>
<ul>
<li><strong>Message Routing</strong>: Efficient message delivery</li>
<li><strong>Graph Management</strong>: Workflow topology and execution</li>
<li><strong>Connection Management</strong>: Inter-actor connectivity</li>
<li><strong>Load Balancing</strong>: Work distribution</li>
</ul>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<h3 id="actor-model"><a class="header" href="#actor-model">Actor Model</a></h3>
<p>Reflow is built on the <strong>Actor Model</strong> of computation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Actor {
    fn get_behavior(&amp;self) -&gt; ActorBehavior;
    fn get_inports(&amp;self) -&gt; Port;
    fn get_outports(&amp;self) -&gt; Port;
    fn create_process(&amp;self) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + Send + 'static&gt;&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Key Properties:</strong></p>
<ul>
<li><strong>Isolation</strong>: No shared state between actors</li>
<li><strong>Concurrency</strong>: Actors run concurrently</li>
<li><strong>Message Passing</strong>: Communication via immutable messages</li>
<li><strong>Location Transparency</strong>: Actors can be local or remote</li>
</ul>
<h3 id="immutable-messages"><a class="header" href="#immutable-messages">Immutable Messages</a></h3>
<p>All communication uses immutable message types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Message {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Array(Vec&lt;Message&gt;),
    Object(HashMap&lt;String, Message&gt;),
    Binary(Vec&lt;u8&gt;),
    Null,
    Error(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="async-first-design"><a class="header" href="#async-first-design">Async-First Design</a></h3>
<p>Built on Rust's async/await system using Tokio:</p>
<ul>
<li>Non-blocking I/O operations</li>
<li>Efficient resource utilization</li>
<li>Scalable concurrent execution</li>
<li>Backpressure handling</li>
</ul>
<h2 id="execution-model"><a class="header" href="#execution-model">Execution Model</a></h2>
<h3 id="actor-lifecycle"><a class="header" href="#actor-lifecycle">Actor Lifecycle</a></h3>
<pre><code class="language-mermaid">stateDiagram-v2
    [*] --&gt; Created
    Created --&gt; Initialized
    Initialized --&gt; Running
    Running --&gt; Processing
    Processing --&gt; Running
    Running --&gt; Stopping
    Stopping --&gt; Stopped
    Stopped --&gt; [*]
    
    Processing --&gt; Error
    Error --&gt; Running
    Error --&gt; Stopping
</code></pre>
<ol>
<li><strong>Creation</strong>: Actor instance created with configuration</li>
<li><strong>Initialization</strong>: Resources allocated, connections established</li>
<li><strong>Running</strong>: Actor ready to process messages</li>
<li><strong>Processing</strong>: Executing behavior function on incoming messages</li>
<li><strong>Stopping</strong>: Graceful shutdown initiated</li>
<li><strong>Stopped</strong>: All resources cleaned up</li>
</ol>
<h3 id="message-flow-1"><a class="header" href="#message-flow-1">Message Flow</a></h3>
<pre><code class="language-mermaid">sequenceDiagram
    participant S as Source Actor
    participant M as Message Bus
    participant T as Target Actor
    
    S-&gt;&gt;M: Send Message
    M-&gt;&gt;M: Route Message
    M-&gt;&gt;T: Deliver Message
    T-&gt;&gt;T: Process Message
    T-&gt;&gt;M: Send Response
    M-&gt;&gt;S: Deliver Response
</code></pre>
<h3 id="graph-execution"><a class="header" href="#graph-execution">Graph Execution</a></h3>
<p>Workflows are executed as directed acyclic graphs (DAGs):</p>
<ul>
<li><strong>Topological Ordering</strong>: Ensures correct execution sequence</li>
<li><strong>Parallel Execution</strong>: Independent branches run concurrently</li>
<li><strong>Backpressure</strong>: Prevents resource exhaustion</li>
<li><strong>Error Propagation</strong>: Failures are handled gracefully</li>
</ul>
<h2 id="runtime-architecture"><a class="header" href="#runtime-architecture">Runtime Architecture</a></h2>
<h3 id="native-runtime-rust"><a class="header" href="#native-runtime-rust">Native Runtime (Rust)</a></h3>
<p>Direct Rust implementation for maximum performance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct NativeActor {
    behavior: Box&lt;dyn Fn(ActorContext) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;HashMap&lt;String, Message&gt;, Error&gt;&gt; + Send&gt;&gt;&gt;,
    // ... other fields
}
<span class="boring">}</span></code></pre></pre>
<h3 id="script-runtimes"><a class="header" href="#script-runtimes">Script Runtimes</a></h3>
<h4 id="deno-runtime"><a class="header" href="#deno-runtime">Deno Runtime</a></h4>
<ul>
<li><strong>Sandbox</strong>: Secure execution environment</li>
<li><strong>Permissions</strong>: Fine-grained access control</li>
<li><strong>TypeScript</strong>: Full TypeScript support</li>
<li><strong>NPM</strong>: Package ecosystem access</li>
</ul>
<h4 id="python-runtime"><a class="header" href="#python-runtime">Python Runtime</a></h4>
<ul>
<li><strong>Isolation</strong>: Process-level or Docker isolation</li>
<li><strong>Libraries</strong>: Full Python ecosystem support</li>
<li><strong>Async</strong>: Async/await support</li>
<li><strong>Error Handling</strong>: Exception propagation</li>
</ul>
<h4 id="webassembly-runtime"><a class="header" href="#webassembly-runtime">WebAssembly Runtime</a></h4>
<ul>
<li><strong>Portability</strong>: Cross-platform execution</li>
<li><strong>Security</strong>: Sandboxed execution</li>
<li><strong>Performance</strong>: Near-native speed</li>
<li><strong>Multi-language</strong>: Support for multiple source languages</li>
</ul>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<h3 id="ownership-model"><a class="header" href="#ownership-model">Ownership Model</a></h3>
<p>Follows Rust's ownership principles:</p>
<ul>
<li><strong>Single Ownership</strong>: Each value has a single owner</li>
<li><strong>Borrowing</strong>: Temporary access without ownership transfer</li>
<li><strong>Lifetimes</strong>: Compile-time memory safety guarantees</li>
<li><strong>Reference Counting</strong>: Shared ownership where needed</li>
</ul>
<h3 id="message-serialization"><a class="header" href="#message-serialization">Message Serialization</a></h3>
<p>Efficient serialization for message passing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compressed serialization for performance
let compressed = compress_message(&amp;message)?;
let serialized = bitcode::serialize(&amp;compressed)?;

// Network transmission
send_over_network(serialized).await?;

// Deserialization
let message = bitcode::deserialize(&amp;received_data)?;
let decompressed = decompress_message(&amp;message)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="networking-architecture"><a class="header" href="#networking-architecture">Networking Architecture</a></h2>
<h3 id="local-communication"><a class="header" href="#local-communication">Local Communication</a></h3>
<pre><code class="language-mermaid">graph LR
    A1[Actor 1] --&gt; C1[Channel]
    C1 --&gt; A2[Actor 2]
    A2 --&gt; C2[Channel]
    C2 --&gt; A3[Actor 3]
</code></pre>
<p><strong>Local Channels:</strong></p>
<ul>
<li><strong>Flume</strong>: High-performance async channels</li>
<li><strong>Zero-copy</strong>: Direct memory access where possible</li>
<li><strong>Backpressure</strong>: Flow control mechanisms</li>
</ul>
<h3 id="distributed-communication"><a class="header" href="#distributed-communication">Distributed Communication</a></h3>
<pre><code class="language-mermaid">graph TB
    subgraph "Node 1"
        A1[Actor A]
        A2[Actor B]
    end
    
    subgraph "Network Layer"
        N1[Network Bridge]
        N2[Network Bridge]
    end
    
    subgraph "Node 2"
        A3[Actor C]
        A4[Actor D]
    end
    
    A1 --&gt; N1
    N1 --&gt; N2
    N2 --&gt; A3
</code></pre>
<p><strong>Network Features:</strong></p>
<ul>
<li><strong>WebSocket</strong>: Real-time communication</li>
<li><strong>Compression</strong>: Efficient data transfer</li>
<li><strong>Encryption</strong>: Secure communication</li>
<li><strong>Discovery</strong>: Automatic node discovery</li>
</ul>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<h3 id="hierarchical-error-management"><a class="header" href="#hierarchical-error-management">Hierarchical Error Management</a></h3>
<pre><code class="language-mermaid">graph TD
    A[Actor Error] --&gt; B[Network Error Handler]
    B --&gt; C[Workflow Error Handler]
    C --&gt; D[Application Error Handler]
    
    B --&gt; E[Circuit Breaker]
    C --&gt; F[Retry Logic]
    D --&gt; G[Dead Letter Queue]
</code></pre>
<p><strong>Error Strategies:</strong></p>
<ul>
<li><strong>Isolation</strong>: Errors don't affect other actors</li>
<li><strong>Propagation</strong>: Structured error reporting</li>
<li><strong>Recovery</strong>: Automatic retry and fallback</li>
<li><strong>Monitoring</strong>: Error tracking and alerting</li>
</ul>
<h2 id="security-model"><a class="header" href="#security-model">Security Model</a></h2>
<h3 id="sandboxing"><a class="header" href="#sandboxing">Sandboxing</a></h3>
<p>Each runtime environment provides isolation:</p>
<ul>
<li><strong>Deno</strong>: V8 isolates with permission system</li>
<li><strong>Python</strong>: Process isolation or containerization</li>
<li><strong>WASM</strong>: Memory-safe execution environment</li>
<li><strong>Native</strong>: Rust's memory safety guarantees</li>
</ul>
<h3 id="permission-system"><a class="header" href="#permission-system">Permission System</a></h3>
<p>Fine-grained access control:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Permissions {
    pub file_system: FileSystemPermissions,
    pub network: NetworkPermissions,
    pub environment: EnvironmentPermissions,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="throughput"><a class="header" href="#throughput">Throughput</a></h3>
<ul>
<li><strong>Message Rate</strong>: &gt;1M messages/second (local)</li>
<li><strong>Latency</strong>: &lt;1ms (local), &lt;10ms (network)</li>
<li><strong>Memory</strong>: ~1KB per actor overhead</li>
<li><strong>CPU</strong>: Scales with core count</li>
</ul>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<ul>
<li><strong>Horizontal</strong>: Distribute across machines</li>
<li><strong>Vertical</strong>: Utilize all CPU cores</li>
<li><strong>Elastic</strong>: Dynamic resource allocation</li>
<li><strong>Backpressure</strong>: Graceful degradation under load</li>
</ul>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<h3 id="runtime-configuration"><a class="header" href="#runtime-configuration">Runtime Configuration</a></h3>
<pre><code class="language-toml">[actor_system]
thread_pool_size = 8
max_actors_per_node = 10000
message_buffer_size = 1000

[networking]
bind_address = "0.0.0.0:8080"
compression_enabled = true
encryption_enabled = true

[runtimes.deno]
permissions = ["--allow-net", "--allow-read"]
memory_limit = "512MB"

[runtimes.python]
use_docker = false
shared_environment = true
</code></pre>
<h2 id="monitoring-and-observability"><a class="header" href="#monitoring-and-observability">Monitoring and Observability</a></h2>
<h3 id="metrics"><a class="header" href="#metrics">Metrics</a></h3>
<ul>
<li><strong>Actor Performance</strong>: Processing time, message rates</li>
<li><strong>Network Statistics</strong>: Bandwidth, latency, errors</li>
<li><strong>Resource Usage</strong>: Memory, CPU, disk I/O</li>
<li><strong>Error Rates</strong>: Failure frequencies and patterns</li>
</ul>
<h3 id="tracing"><a class="header" href="#tracing">Tracing</a></h3>
<p>Distributed tracing support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, span, Level};

let span = span!(Level::INFO, "actor_processing", actor_id = %actor.id());
let _enter = span.enter();

info!("Processing message: {:?}", message);
<span class="boring">}</span></code></pre></pre>
<h2 id="extension-points"><a class="header" href="#extension-points">Extension Points</a></h2>
<h3 id="custom-actors"><a class="header" href="#custom-actors">Custom Actors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Actor for CustomActor {
    fn get_behavior(&amp;self) -&gt; ActorBehavior {
        Box::new(|context| {
            Box::pin(async move {
                // Custom processing logic
                Ok(HashMap::new())
            })
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-runtimes"><a class="header" href="#custom-runtimes">Custom Runtimes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[async_trait]
impl ScriptEngine for CustomEngine {
    async fn init(&amp;mut self, config: &amp;ScriptConfig) -&gt; Result&lt;()&gt;;
    async fn call(&amp;mut self, context: &amp;ScriptContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;&gt;;
    async fn cleanup(&amp;mut self) -&gt; Result&lt;()&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<p>For detailed information on specific components:</p>
<ul>
<li><a href="architecture/./actor-model.html">Actor Model</a> - Deep dive into actor implementation</li>
<li><a href="architecture/./message-passing.html">Message Passing</a> - Message system details</li>
<li><a href="architecture/./graph-system.html">Graph System</a> - Workflow graph management</li>
<li><a href="architecture/./multi-language-support.html">Multi-Language Support</a> - Runtime integration</li>
<li><a href="architecture/./performance-considerations.html">Performance Considerations</a> - Optimization strategies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actor-model-1"><a class="header" href="#actor-model-1">Actor Model</a></h1>
<p>This document provides an in-depth look at how Reflow implements the Actor Model of computation.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The Actor Model is a mathematical model of concurrent computation that treats "actors" as the universal primitives of concurrent computation. In Reflow, actors are isolated computational units that communicate exclusively through message passing.</p>
<h2 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h2>
<h3 id="1-everything-is-an-actor"><a class="header" href="#1-everything-is-an-actor">1. Everything is an Actor</a></h3>
<p>In Reflow's actor system:</p>
<ul>
<li>Data processing units are actors</li>
<li>Message routers are actors</li>
<li>Database connections are actors</li>
<li>Network services are actors</li>
</ul>
<h3 id="2-actors-communicate-via-messages"><a class="header" href="#2-actors-communicate-via-messages">2. Actors Communicate via Messages</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Messages are immutable and serializable
pub enum Message {
    String(String),
    Integer(i64),
    Float(f64),
    Boolean(bool),
    Array(Vec&lt;Message&gt;),
    Object(HashMap&lt;String, Message&gt;),
    Binary(Vec&lt;u8&gt;),
    Null,
    Error(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-actors-have-private-state"><a class="header" href="#3-actors-have-private-state">3. Actors Have Private State</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ActorState: Send + Sync + 'static {
    fn as_any(&amp;self) -&gt; &amp;dyn Any;
    fn as_mut_any(&amp;mut self) -&gt; &amp;mut dyn Any;
}

#[derive(Default, Debug, Clone)]
pub struct MemoryState(pub HashMap&lt;String, Value&gt;);
<span class="boring">}</span></code></pre></pre>
<h3 id="4-actors-process-messages-sequentially"><a class="header" href="#4-actors-process-messages-sequentially">4. Actors Process Messages Sequentially</a></h3>
<p>Each actor processes one message at a time, ensuring thread safety without locks.</p>
<h2 id="actor-implementation"><a class="header" href="#actor-implementation">Actor Implementation</a></h2>
<h3 id="actor-trait"><a class="header" href="#actor-trait">Actor Trait</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Actor: Send + Sync + 'static {
    /// Defines how the actor processes messages
    fn get_behavior(&amp;self) -&gt; ActorBehavior;
    
    /// Access to input ports
    fn get_inports(&amp;self) -&gt; Port;
    
    /// Access to output ports
    fn get_outports(&amp;self) -&gt; Port;
    
    /// Create the actor's execution process
    fn create_process(&amp;self) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static + Send&gt;&gt;;
    
    /// Load counting for backpressure (optional)
    fn load_count(&amp;self) -&gt; Arc&lt;Mutex&lt;ActorLoad&gt;&gt; {
        Arc::new(Mutex::new(ActorLoad::new(0)))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="actor-behavior"><a class="header" href="#actor-behavior">Actor Behavior</a></h3>
<p>The behavior function defines how an actor responds to messages:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type ActorBehavior = Box&lt;
    dyn Fn(ActorContext) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt;&gt; + Send + 'static&gt;&gt;
        + Send + Sync + 'static,
&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="actor-context"><a class="header" href="#actor-context">Actor Context</a></h3>
<p>The context provides access to the actor's environment:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ActorContext {
    pub payload: ActorPayload,
    pub outports: Port,
    pub state: Arc&lt;Mutex&lt;dyn ActorState&gt;&gt;,
    pub config: HashMap&lt;String, Value&gt;,
    load: Arc&lt;Mutex&lt;ActorLoad&gt;&gt;,
}

impl ActorContext {
    pub fn get_state(&amp;self) -&gt; Arc&lt;Mutex&lt;dyn ActorState&gt;&gt;;
    pub fn get_config(&amp;self) -&gt; &amp;HashMap&lt;String, Value&gt;;
    pub fn get_payload(&amp;self) -&gt; &amp;ActorPayload;
    pub fn get_outports(&amp;self) -&gt; Port;
    pub fn done(&amp;self);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="actor-types-1"><a class="header" href="#actor-types-1">Actor Types</a></h2>
<h3 id="1-native-actors"><a class="header" href="#1-native-actors">1. Native Actors</a></h3>
<p>Written directly in Rust for maximum performance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::actor::{Actor, ActorBehavior, ActorContext, Port, MemoryState};
use reflow_network::message::Message;
use std::collections::HashMap;

pub struct FilterActor {
    threshold: f64,
    inports: Port,
    outports: Port,
}

impl FilterActor {
    pub fn new(threshold: f64) -&gt; Self {
        Self {
            threshold,
            inports: flume::unbounded(),
            outports: flume::unbounded(),
        }
    }
}

impl Actor for FilterActor {
    fn get_behavior(&amp;self) -&gt; ActorBehavior {
        let threshold = self.threshold;
        
        Box::new(move |context: ActorContext| {
            Box::pin(async move {
                let payload = context.get_payload();
                let mut results = HashMap::new();
                
                if let Some(Message::Float(value)) = payload.get("input") {
                    if *value &gt; threshold {
                        results.insert("output".to_string(), Message::Float(*value));
                    }
                }
                
                Ok(results)
            })
        })
    }
    
    fn get_inports(&amp;self) -&gt; Port { self.inports.clone() }
    fn get_outports(&amp;self) -&gt; Port { self.outports.clone() }
    
    fn create_process(&amp;self) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static + Send&gt;&gt; {
        // Implementation details...
        todo!()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-script-actors"><a class="header" href="#2-script-actors">2. Script Actors</a></h3>
<p>Execute scripts in various languages:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_script::{ScriptActor, ScriptConfig, ScriptRuntime, ScriptEnvironment};

// JavaScript Actor
let js_config = ScriptConfig {
    environment: ScriptEnvironment::SYSTEM,
    runtime: ScriptRuntime::JavaScript,
    source: include_bytes!("script.js").to_vec(),
    entry_point: "process".to_string(),
    packages: None,
};

let js_actor = ScriptActor::new(js_config);
<span class="boring">}</span></code></pre></pre>
<h3 id="3-component-actors"><a class="header" href="#3-component-actors">3. Component Actors</a></h3>
<p>Pre-built components from the library:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::flow_control::ConditionalActor;
use reflow_components::data_operations::MapActor;

let conditional = ConditionalActor::new(|msg| {
    if let Message::Integer(n) = msg {
        *n &gt; 0
    } else {
        false
    }
});

let mapper = MapActor::new(|msg| {
    if let Message::Integer(n) = msg {
        Message::Integer(n * 2)
    } else {
        msg.clone()
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="message-passing-semantics"><a class="header" href="#message-passing-semantics">Message Passing Semantics</a></h2>
<h3 id="asynchronous-messaging"><a class="header" href="#asynchronous-messaging">Asynchronous Messaging</a></h3>
<p>Messages are sent asynchronously without blocking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Send message without waiting
outport.send_async(message).await?;

// Receive message when available
let message = inport.recv_async().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="message-ordering"><a class="header" href="#message-ordering">Message Ordering</a></h3>
<ul>
<li>Messages between the same pair of actors maintain order</li>
<li>No global ordering guarantees across different actor pairs</li>
<li>Use synchronization actors for coordination when needed</li>
</ul>
<h3 id="message-delivery"><a class="header" href="#message-delivery">Message Delivery</a></h3>
<ul>
<li><strong>At-most-once</strong>: Messages may be lost but never duplicated</li>
<li><strong>Best-effort</strong>: System attempts delivery but doesn't guarantee it</li>
<li><strong>Backpressure</strong>: Slow consumers cause senders to block</li>
</ul>
<h2 id="actor-lifecycle-management"><a class="header" href="#actor-lifecycle-management">Actor Lifecycle Management</a></h2>
<h3 id="creation-and-initialization"><a class="header" href="#creation-and-initialization">Creation and Initialization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create actor
let actor = MyActor::new(config);

// Initialize ports and state
let inports = actor.get_inports();
let outports = actor.get_outports();

// Start actor process
let process = actor.create_process();
tokio::spawn(process);
<span class="boring">}</span></code></pre></pre>
<h3 id="message-processing-loop"><a class="header" href="#message-processing-loop">Message Processing Loop</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn create_process(&amp;self) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static + Send&gt;&gt; {
    let inports = self.get_inports();
    let behavior = self.get_behavior();
    let state = Arc::new(Mutex::new(MemoryState::default()));
    let outports = self.get_outports();
    
    Box::pin(async move {
        while let Ok(payload) = inports.1.recv_async().await {
            let context = ActorContext::new(
                payload,
                outports.clone(),
                state.clone(),
                HashMap::new(),
                Arc::new(Mutex::new(ActorLoad::new(0))),
            );
            
            match behavior(context).await {
                Ok(result) =&gt; {
                    if !result.is_empty() {
                        let _ = outports.0.send_async(result).await;
                    }
                },
                Err(e) =&gt; {
                    let error_msg = HashMap::from([
                        ("error".to_string(), Message::Error(e.to_string()))
                    ]);
                    let _ = outports.0.send_async(error_msg).await;
                }
            }
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="termination"><a class="header" href="#termination">Termination</a></h3>
<p>Actors terminate when:</p>
<ul>
<li>Input ports are closed (no more messages)</li>
<li>Explicit shutdown signal</li>
<li>Unrecoverable error occurs</li>
</ul>
<h2 id="state-management"><a class="header" href="#state-management">State Management</a></h2>
<h3 id="actor-state-types"><a class="header" href="#actor-state-types">Actor State Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple memory state
let state = MemoryState::default();

// Custom state implementation
struct CounterState {
    count: AtomicU64,
}

impl ActorState for CounterState {
    fn as_any(&amp;self) -&gt; &amp;dyn Any { self }
    fn as_mut_any(&amp;mut self) -&gt; &amp;mut dyn Any { self }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="state-persistence-1"><a class="header" href="#state-persistence-1">State Persistence</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Access state in behavior
fn get_behavior(&amp;self) -&gt; ActorBehavior {
    Box::new(|context: ActorContext| {
        Box::pin(async move {
            let state = context.get_state();
            let mut state_guard = state.lock();
            
            // Read/modify state
            if let Some(memory_state) = state_guard.as_mut_any().downcast_mut::&lt;MemoryState&gt;() {
                memory_state.insert("counter", serde_json::json!(42));
            }
            
            Ok(HashMap::new())
        })
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<h3 id="actor-level-errors-1"><a class="header" href="#actor-level-errors-1">Actor-Level Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Return error from behavior
Err(anyhow::anyhow!("Processing failed: {}", reason))

// Handle errors in message processing
match behavior(context).await {
    Ok(result) =&gt; send_result(result).await,
    Err(e) =&gt; send_error(e).await,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-propagation"><a class="header" href="#error-propagation">Error Propagation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Error message format
let error_message = HashMap::from([
    ("error".to_string(), Message::Error("Database connection failed".to_string())),
    ("code".to_string(), Message::Integer(500)),
    ("timestamp".to_string(), Message::String(Utc::now().to_rfc3339())),
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="supervision-strategies"><a class="header" href="#supervision-strategies">Supervision Strategies</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Supervisor actor monitors children
struct SupervisorActor {
    children: Vec&lt;ActorRef&gt;,
    restart_policy: RestartPolicy,
}

enum RestartPolicy {
    OneForOne,    // Restart only failed actor
    OneForAll,    // Restart all actors
    RestForOne,   // Restart failed and subsequent actors
}
<span class="boring">}</span></code></pre></pre>
<h2 id="concurrency-and-parallelism"><a class="header" href="#concurrency-and-parallelism">Concurrency and Parallelism</a></h2>
<h3 id="actor-isolation-1"><a class="header" href="#actor-isolation-1">Actor Isolation</a></h3>
<ul>
<li>Each actor runs in isolation</li>
<li>No shared mutable state</li>
<li>Communication only via messages</li>
<li>Thread-safe by design</li>
</ul>
<h3 id="parallel-execution"><a class="header" href="#parallel-execution">Parallel Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Multiple actors can run simultaneously
tokio::spawn(actor1.create_process());
tokio::spawn(actor2.create_process());
tokio::spawn(actor3.create_process());

// Actors on different CPU cores
let rt = tokio::runtime::Builder::new_multi_thread()
    .worker_threads(num_cpus::get())
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="load-balancing"><a class="header" href="#load-balancing">Load Balancing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Round-robin message distribution
struct LoadBalancerActor {
    workers: Vec&lt;Port&gt;,
    current: AtomicUsize,
}

impl LoadBalancerActor {
    fn next_worker(&amp;self) -&gt; &amp;Port {
        let index = self.current.fetch_add(1, Ordering::Relaxed) % self.workers.len();
        &amp;self.workers[index]
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<ul>
<li>Actors have minimal overhead (~1KB per actor)</li>
<li>Messages are reference-counted when possible</li>
<li>State is lazily allocated</li>
</ul>
<h3 id="message-throughput"><a class="header" href="#message-throughput">Message Throughput</a></h3>
<ul>
<li>Local messages: &gt;1M messages/second</li>
<li>Network messages: 10K-100K messages/second</li>
<li>Batch processing for high throughput</li>
</ul>
<h3 id="backpressure-handling"><a class="header" href="#backpressure-handling">Backpressure Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check actor load before sending
let load = actor.load_count();
if load.lock().get() &gt; MAX_LOAD {
    // Apply backpressure
    tokio::time::sleep(Duration::from_millis(10)).await;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="actor-pooling"><a class="header" href="#actor-pooling">Actor Pooling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ActorPool&lt;T: Actor&gt; {
    actors: Vec&lt;T&gt;,
    distributor: LoadBalancerActor,
}

impl&lt;T: Actor&gt; ActorPool&lt;T&gt; {
    pub fn new(size: usize, factory: impl Fn() -&gt; T) -&gt; Self {
        let actors: Vec&lt;T&gt; = (0..size).map(|_| factory()).collect();
        // ... setup distributor
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="hot-swapping"><a class="header" href="#hot-swapping">Hot Swapping</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Replace actor behavior without stopping
actor.update_behavior(new_behavior).await?;

// Migrate state to new actor version
let old_state = old_actor.get_state();
new_actor.set_state(old_state).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="circuit-breaker"><a class="header" href="#circuit-breaker">Circuit Breaker</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CircuitBreakerActor {
    target: ActorRef,
    failure_count: AtomicU32,
    state: AtomicU8, // Open, Closed, HalfOpen
}

impl CircuitBreakerActor {
    fn should_allow_request(&amp;self) -&gt; bool {
        match self.state.load(Ordering::Relaxed) {
            0 =&gt; true,  // Closed
            1 =&gt; false, // Open
            2 =&gt; true,  // HalfOpen
            _ =&gt; false,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-actors"><a class="header" href="#testing-actors">Testing Actors</a></h2>
<h3 id="unit-testing"><a class="header" href="#unit-testing">Unit Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_filter_actor() {
    let actor = FilterActor::new(5.0);
    let behavior = actor.get_behavior();
    
    // Create test context
    let payload = HashMap::from([
        ("input".to_string(), Message::Float(10.0))
    ]);
    
    let context = create_test_context(payload);
    let result = behavior(context).await.unwrap();
    
    assert!(result.contains_key("output"));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_actor_pipeline() {
    let source = SourceActor::new();
    let filter = FilterActor::new(5.0);
    let sink = SinkActor::new();
    
    // Connect actors
    connect_actors(&amp;source, &amp;filter).await;
    connect_actors(&amp;filter, &amp;sink).await;
    
    // Start pipeline
    let handles = vec![
        tokio::spawn(source.create_process()),
        tokio::spawn(filter.create_process()),
        tokio::spawn(sink.create_process()),
    ];
    
    // Test data flow
    // ... assertions
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="actor-design-1"><a class="header" href="#actor-design-1">Actor Design</a></h3>
<ol>
<li><strong>Keep actors small and focused</strong> - Single responsibility principle</li>
<li><strong>Avoid blocking operations</strong> - Use async/await for I/O</li>
<li><strong>Handle errors gracefully</strong> - Don't let actors crash</li>
<li><strong>Design for failure</strong> - Expect message loss and actor failures</li>
</ol>
<h3 id="message-design-1"><a class="header" href="#message-design-1">Message Design</a></h3>
<ol>
<li><strong>Keep messages immutable</strong> - Never modify messages after sending</li>
<li><strong>Use appropriate message sizes</strong> - Balance between batching and latency</li>
<li><strong>Include context</strong> - Messages should carry enough information</li>
<li><strong>Handle malformed messages</strong> - Validate input gracefully</li>
</ol>
<h3 id="state-management-1"><a class="header" href="#state-management-1">State Management</a></h3>
<ol>
<li><strong>Minimize state</strong> - Less state means fewer bugs</li>
<li><strong>Make state serializable</strong> - Enable persistence and distribution</li>
<li><strong>Avoid shared state</strong> - Each actor owns its state</li>
<li><strong>Design for recovery</strong> - State should be reconstructible</li>
</ol>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><a href="architecture/./message-passing.html">Message Passing</a> - Detailed message system</li>
<li><a href="architecture/./graph-system.html">Graph System</a> - Workflow composition</li>
<li><a href="architecture/../api/actors/creating-actors.html">Creating Actors</a> - Practical guide</li>
<li><a href="architecture/./performance-considerations.html">Performance Optimization</a> - Tuning guidelines</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h1>
<p>This document details Reflow's message passing system, which is the primary communication mechanism between actors.</p>
<h2 id="message-types"><a class="header" href="#message-types">Message Types</a></h2>
<p>Reflow uses a strongly-typed message system with built-in serialization support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Serialize, Deserialize, Encode, Decode, PartialEq)]
pub enum Message {
    Flow,
    Event(EncodableValue),
    Boolean(bool),
    Integer(i64),
    Float(f64),
    String(String),
    Object(EncodableValue),
    Array(Vec&lt;EncodableValue&gt;),
    Stream(Vec&lt;u8&gt;),
    Encoded(Vec&lt;u8&gt;),
    Optional(Option&lt;EncodableValue&gt;),
    Any(EncodableValue),
    Error(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="encodablevalue"><a class="header" href="#encodablevalue">EncodableValue</a></h3>
<p>Reflow uses <code>EncodableValue</code> as a wrapper for complex data types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Serialize, Deserialize, Encode, Decode, PartialEq, Eq)]
pub struct EncodableValue {
    pub(crate) data: Vec&lt;u8&gt;,
}

impl EncodableValue {
    pub fn new&lt;T: Encode&gt;(value: &amp;T) -&gt; Self {
        Self {
            data: bitcode::encode(value),
        }
    }

    pub fn decode&lt;'a, T: Decode&lt;'a&gt;&gt;(&amp;'a self) -&gt; Option&lt;T&gt; {
        bitcode::decode(&amp;self.data).ok()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="message-conversion"><a class="header" href="#message-conversion">Message Conversion</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::Value;

// From JSON values
let msg = Message::from(serde_json::json!(42));

// To JSON values  
let json: Value = message.into();

// Type checking
if let Message::Integer(n) = message {
    println!("Number: {}", n);
}

// Working with EncodableValue
let data = serde_json::json!({"key": "value"});
let encodable = EncodableValue::from(data);
let object_msg = Message::Object(encodable);

// Create arrays with EncodableValue
let array_items = vec![
    EncodableValue::from(serde_json::json!("hello")),
    EncodableValue::from(serde_json::json!(42)),
];
let array_msg = Message::Array(array_items);
<span class="boring">}</span></code></pre></pre>
<h2 id="communication-channels"><a class="header" href="#communication-channels">Communication Channels</a></h2>
<h3 id="ports-1"><a class="header" href="#ports-1">Ports</a></h3>
<p>Ports are the communication endpoints for actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Port = (
    flume::Sender&lt;HashMap&lt;String, Message&gt;&gt;,
    flume::Receiver&lt;HashMap&lt;String, Message&gt;&gt;,
);

// Actor payload format
pub type ActorPayload = HashMap&lt;String, Message&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="channel-properties"><a class="header" href="#channel-properties">Channel Properties</a></h3>
<ul>
<li><strong>Asynchronous</strong>: Non-blocking send/receive operations</li>
<li><strong>Bounded</strong>: Configurable buffer sizes for backpressure</li>
<li><strong>Multi-producer, Single-consumer</strong>: Multiple senders, one receiver per port</li>
<li><strong>Type-safe</strong>: Compile-time message type checking</li>
</ul>
<h2 id="message-flow-patterns"><a class="header" href="#message-flow-patterns">Message Flow Patterns</a></h2>
<h3 id="point-to-point-1"><a class="header" href="#point-to-point-1">Point-to-Point</a></h3>
<p>Direct communication between two actors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Actor A sends to Actor B
let message = HashMap::from([
    ("data".to_string(), Message::String("hello".to_string()))
]);
sender.send_async(message).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="broadcast-1"><a class="header" href="#broadcast-1">Broadcast</a></h3>
<p>One actor sends to multiple receivers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Using actor macro for broadcast
#[actor(
    BroadcastActor,
    inports::&lt;100&gt;(input),
    outports::&lt;50&gt;(output1, output2, output3)
)]
async fn broadcast_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    if let Some(input_msg) = payload.get("input") {
        // Broadcast to all output ports
        Ok([
            ("output1".to_owned(), input_msg.clone()),
            ("output2".to_owned(), input_msg.clone()),
            ("output3".to_owned(), input_msg.clone()),
        ].into())
    } else {
        Err(anyhow::anyhow!("No input to broadcast"))
    }
}

// Manual implementation for dynamic outputs
struct ManualBroadcastActor {
    inports: Port,
    outports: Port,
    outputs: Vec&lt;flume::Sender&lt;HashMap&lt;String, Message&gt;&gt;&gt;,
    load: Arc&lt;Mutex&lt;ActorLoad&gt;&gt;,
}

impl ManualBroadcastActor {
    async fn broadcast(&amp;self, message: HashMap&lt;String, Message&gt;) -&gt; Result&lt;(), anyhow::Error&gt; {
        for output in &amp;self.outputs {
            output.send_async(message.clone()).await?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="fan-in-merge"><a class="header" href="#fan-in-merge">Fan-In (Merge)</a></h3>
<p>Multiple actors send to one receiver:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MergeActor {
    inputs: Vec&lt;flume::Receiver&lt;HashMap&lt;String, Message&gt;&gt;&gt;,
    output: flume::Sender&lt;HashMap&lt;String, Message&gt;&gt;,
}

impl MergeActor {
    async fn merge_loop(&amp;self) {
        use futures::stream::{FuturesUnordered, StreamExt};
        
        let mut streams: FuturesUnordered&lt;_&gt; = self.inputs
            .iter()
            .map(|rx| rx.recv_async())
            .collect();
            
        while let Some(result) = streams.next().await {
            if let Ok(message) = result {
                let _ = self.output.send_async(message).await;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="serialization-and-transport"><a class="header" href="#serialization-and-transport">Serialization and Transport</a></h2>
<h3 id="local-serialization"><a class="header" href="#local-serialization">Local Serialization</a></h3>
<p>For local communication, messages use efficient in-memory representation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Zero-copy for simple types
let msg = Message::Integer(42); // No allocation

// Reference counting for complex types
let complex = Message::Object(data); // Rc&lt;HashMap&lt;String, Message&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<h3 id="network-serialization"><a class="header" href="#network-serialization">Network Serialization</a></h3>
<p>For distributed communication:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bitcode;
use flate2::Compression;

// Compress and serialize
let compressed = compress_message(&amp;message, Compression::default())?;
let bytes = bitcode::serialize(&amp;compressed)?;

// Send over network
network_send(bytes).await?;

// Receive and deserialize
let received = network_receive().await?;
let message = bitcode::deserialize(&amp;received)?;
let decompressed = decompress_message(&amp;message)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="message-routing"><a class="header" href="#message-routing">Message Routing</a></h2>
<h3 id="router-actor"><a class="header" href="#router-actor">Router Actor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RouterActor {
    routes: HashMap&lt;String, flume::Sender&lt;HashMap&lt;String, Message&gt;&gt;&gt;,
    default_route: Option&lt;flume::Sender&lt;HashMap&lt;String, Message&gt;&gt;&gt;,
}

impl RouterActor {
    pub fn route_message(&amp;self, key: &amp;str, message: HashMap&lt;String, Message&gt;) -&gt; Result&lt;()&gt; {
        if let Some(sender) = self.routes.get(key) {
            sender.try_send(message)?;
        } else if let Some(default) = &amp;self.default_route {
            default.try_send(message)?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="content-based-routing"><a class="header" href="#content-based-routing">Content-Based Routing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RouterActor {
    fn route_by_content(&amp;self, message: &amp;HashMap&lt;String, Message&gt;) -&gt; Option&lt;&amp;str&gt; {
        // Route based on message content
        if let Some(Message::String(msg_type)) = message.get("type") {
            match msg_type.as_str() {
                "user_event" =&gt; Some("user_handler"),
                "system_event" =&gt; Some("system_handler"),
                "error" =&gt; Some("error_handler"),
                _ =&gt; None,
            }
        } else {
            None
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<h3 id="error-message-format"><a class="header" href="#error-message-format">Error Message Format</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Standard error message structure
let error_msg = HashMap::from([
    ("error".to_string(), Message::Error("Processing failed".to_string())),
    ("code".to_string(), Message::Integer(500)),
    ("source".to_string(), Message::String("database_actor".to_string())),
    ("timestamp".to_string(), Message::String(Utc::now().to_rfc3339())),
    ("details".to_string(), Message::Object(error_details)),
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="dead-letter-queue"><a class="header" href="#dead-letter-queue">Dead Letter Queue</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DeadLetterQueue {
    storage: Arc&lt;Mutex&lt;Vec&lt;(String, HashMap&lt;String, Message&gt;)&gt;&gt;&gt;,
    max_size: usize,
}

impl DeadLetterQueue {
    pub async fn store_failed_message(
        &amp;self, 
        reason: String, 
        message: HashMap&lt;String, Message&gt;
    ) {
        let mut storage = self.storage.lock();
        if storage.len() &gt;= self.max_size {
            storage.remove(0); // Remove oldest
        }
        storage.push((reason, message));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="backpressure-management"><a class="header" href="#backpressure-management">Backpressure Management</a></h2>
<h3 id="flow-control"><a class="header" href="#flow-control">Flow Control</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FlowControlActor {
    input: flume::Receiver&lt;HashMap&lt;String, Message&gt;&gt;,
    output: flume::Sender&lt;HashMap&lt;String, Message&gt;&gt;,
    buffer_size: usize,
    current_load: Arc&lt;AtomicUsize&gt;,
}

impl FlowControlActor {
    async fn process_with_backpressure(&amp;self) {
        while let Ok(message) = self.input.recv_async().await {
            // Check current load
            let load = self.current_load.load(Ordering::Relaxed);
            
            if load &gt; self.buffer_size {
                // Apply backpressure - slow down
                tokio::time::sleep(Duration::from_millis(10)).await;
            }
            
            self.current_load.fetch_add(1, Ordering::Relaxed);
            
            // Process message
            if let Err(_) = self.output.try_send(message) {
                // Output buffer full, apply backpressure
                tokio::time::sleep(Duration::from_millis(1)).await;
            }
            
            self.current_load.fetch_sub(1, Ordering::Relaxed);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-ordering-1"><a class="header" href="#message-ordering-1">Message Ordering</a></h2>
<h3 id="ordered-delivery"><a class="header" href="#ordered-delivery">Ordered Delivery</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OrderedDeliveryActor {
    sequence_number: AtomicU64,
    expected_sequence: AtomicU64,
    buffer: Arc&lt;Mutex&lt;BTreeMap&lt;u64, HashMap&lt;String, Message&gt;&gt;&gt;&gt;,
}

impl OrderedDeliveryActor {
    fn add_sequence_number(&amp;self, mut message: HashMap&lt;String, Message&gt;) -&gt; HashMap&lt;String, Message&gt; {
        let seq = self.sequence_number.fetch_add(1, Ordering::Relaxed);
        message.insert("sequence".to_string(), Message::Integer(seq as i64));
        message
    }
    
    async fn deliver_in_order(&amp;self, message: HashMap&lt;String, Message&gt;) {
        if let Some(Message::Integer(seq)) = message.get("sequence") {
            let seq = *seq as u64;
            let expected = self.expected_sequence.load(Ordering::Relaxed);
            
            if seq == expected {
                // Deliver immediately
                self.deliver_message(message).await;
                self.expected_sequence.fetch_add(1, Ordering::Relaxed);
                
                // Check buffer for next messages
                self.deliver_buffered_messages().await;
            } else {
                // Buffer out-of-order message
                self.buffer.lock().insert(seq, message);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="message-batching"><a class="header" href="#message-batching">Message Batching</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::message::{Message, EncodableValue};

pub struct BatchingActor {
    batch_size: usize,
    batch_timeout: Duration,
    current_batch: Vec&lt;HashMap&lt;String, Message&gt;&gt;,
    input: flume::Receiver&lt;HashMap&lt;String, Message&gt;&gt;,
    output: flume::Sender&lt;HashMap&lt;String, Message&gt;&gt;,
}

impl BatchingActor {
    async fn process_with_batching(&amp;mut self) {
        let mut interval = tokio::time::interval(self.batch_timeout);
        
        loop {
            tokio::select! {
                // Receive new message
                Ok(message) = self.input.recv_async() =&gt; {
                    self.current_batch.push(message);
                    
                    if self.current_batch.len() &gt;= self.batch_size {
                        self.flush_batch().await;
                    }
                }
                
                // Timeout - flush partial batch
                _ = interval.tick() =&gt; {
                    if !self.current_batch.is_empty() {
                        self.flush_batch().await;
                    }
                }
            }
        }
    }
    
    async fn flush_batch(&amp;mut self) {
        if !self.current_batch.is_empty() {
            // Convert to EncodableValue for proper serialization
            let batch_items: Vec&lt;EncodableValue&gt; = self.current_batch
                .drain(..)
                .map(|msg| EncodableValue::from(serde_json::to_value(msg).unwrap()))
                .collect();
            
            let batch = Message::Array(batch_items);
            
            let batch_message = HashMap::from([
                ("batch".to_string(), batch)
            ]);
            
            let _ = self.output.send_async(batch_message).await;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="zero-copy-optimization"><a class="header" href="#zero-copy-optimization">Zero-Copy Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bytes::Bytes;

// Use Bytes for zero-copy binary data
let data = Bytes::from(vec![1, 2, 3, 4]);
let message = Message::Binary(data.to_vec());

// Reference counting for large objects
use std::sync::Arc;

struct LargeData {
    content: Vec&lt;u8&gt;,
}

let large_data = Arc::new(LargeData { content: vec![0; 1000000] });
// Pass Arc around instead of cloning large data
<span class="boring">}</span></code></pre></pre>
<h2 id="message-validation"><a class="header" href="#message-validation">Message Validation</a></h2>
<h3 id="schema-validation"><a class="header" href="#schema-validation">Schema Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::Value;

pub struct MessageValidator {
    schemas: HashMap&lt;String, Value&gt;, // JSON Schema
}

impl MessageValidator {
    pub fn validate_message(
        &amp;self, 
        message_type: &amp;str, 
        message: &amp;HashMap&lt;String, Message&gt;
    ) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(schema) = self.schemas.get(message_type) {
            let json_value: Value = message.clone().into();
            validate_json_schema(&amp;json_value, schema)?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-safety"><a class="header" href="#type-safety">Type Safety</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Type-safe message builders
pub struct UserEventBuilder {
    user_id: Option&lt;String&gt;,
    event_type: Option&lt;String&gt;,
    timestamp: Option&lt;String&gt;,
}

impl UserEventBuilder {
    pub fn user_id(mut self, id: String) -&gt; Self {
        self.user_id = Some(id);
        self
    }
    
    pub fn event_type(mut self, event_type: String) -&gt; Self {
        self.event_type = Some(event_type);
        self
    }
    
    pub fn build(self) -&gt; Result&lt;HashMap&lt;String, Message&gt;, BuildError&gt; {
        let user_id = self.user_id.ok_or(BuildError::MissingUserId)?;
        let event_type = self.event_type.ok_or(BuildError::MissingEventType)?;
        
        Ok(HashMap::from([
            ("user_id".to_string(), Message::String(user_id)),
            ("event_type".to_string(), Message::String(event_type)),
            ("timestamp".to_string(), Message::String(Utc::now().to_rfc3339())),
        ]))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-message-passing"><a class="header" href="#testing-message-passing">Testing Message Passing</a></h2>
<h3 id="mock-channels"><a class="header" href="#mock-channels">Mock Channels</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MockChannel {
    sent_messages: Arc&lt;Mutex&lt;Vec&lt;HashMap&lt;String, Message&gt;&gt;&gt;&gt;,
    responses: Arc&lt;Mutex&lt;VecDeque&lt;HashMap&lt;String, Message&gt;&gt;&gt;&gt;,
}

impl MockChannel {
    pub fn new() -&gt; Self {
        Self {
            sent_messages: Arc::new(Mutex::new(Vec::new())),
            responses: Arc::new(Mutex::new(VecDeque::new())),
        }
    }
    
    pub fn expect_message(&amp;self, message: HashMap&lt;String, Message&gt;) {
        self.responses.lock().push_back(message);
    }
    
    pub fn verify_sent(&amp;self, expected: &amp;HashMap&lt;String, Message&gt;) -&gt; bool {
        self.sent_messages.lock().contains(expected)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing-1"><a class="header" href="#integration-testing-1">Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_message_pipeline() {
    let (tx1, rx1) = flume::unbounded();
    let (tx2, rx2) = flume::unbounded();
    
    // Create test actors
    let source = TestSourceActor::new(tx1);
    let processor = TestProcessorActor::new(rx1, tx2);
    let sink = TestSinkActor::new(rx2);
    
    // Start actors
    tokio::spawn(source.run());
    tokio::spawn(processor.run());
    tokio::spawn(sink.run());
    
    // Test message flow
    let test_message = HashMap::from([
        ("data".to_string(), Message::String("test".to_string()))
    ]);
    
    source.send(test_message.clone()).await;
    
    // Verify message received
    let received = sink.receive_next().await;
    assert_eq!(received.get("data"), test_message.get("data"));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<h3 id="message-design-2"><a class="header" href="#message-design-2">Message Design</a></h3>
<ol>
<li><strong>Keep messages immutable</strong> - Never modify after creation</li>
<li><strong>Use appropriate granularity</strong> - Not too fine, not too coarse</li>
<li><strong>Include enough context</strong> - Messages should be self-contained</li>
<li><strong>Design for evolution</strong> - Use versioned message formats</li>
</ol>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<ol>
<li><strong>Batch when possible</strong> - Reduce overhead</li>
<li><strong>Use appropriate data types</strong> - Binary for large data</li>
<li><strong>Implement backpressure</strong> - Prevent resource exhaustion</li>
<li><strong>Monitor message rates</strong> - Track performance metrics</li>
</ol>
<h3 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h3>
<ol>
<li><strong>Use structured errors</strong> - Include error codes and context</li>
<li><strong>Implement dead letter queues</strong> - Don't lose failed messages</li>
<li><strong>Design for retry</strong> - Make operations idempotent</li>
<li><strong>Log message failures</strong> - Enable debugging</li>
</ol>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><a href="architecture/./graph-system.html">Graph System</a> - Workflow composition</li>
<li><a href="architecture/./multi-language-support.html">Multi-Language Support</a> - Script integration</li>
<li><a href="architecture/./performance-considerations.html">Performance Considerations</a> - Optimization</li>
<li><a href="architecture/../api/actors/creating-actors.html">Creating Actors</a> - Practical implementation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-system-architecture"><a class="header" href="#graph-system-architecture">Graph System Architecture</a></h1>
<p>Reflow's graph system provides a comprehensive flow-based programming (FBP) foundation for building visual workflow editors, data processing pipelines, and complex computational graphs. The system supports real-time validation, automatic layout, performance analysis, and both native Rust and WebAssembly implementations.</p>
<h2 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h2>
<h3 id="graph-structure"><a class="header" href="#graph-structure">Graph Structure</a></h3>
<p>A Reflow graph consists of:</p>
<ul>
<li><strong>Nodes</strong>: Processing units that represent actors or components</li>
<li><strong>Connections</strong>: Data flow paths between node ports</li>
<li><strong>Ports</strong>: Input/output endpoints with typed interfaces</li>
<li><strong>Initial Information Packets (IIPs)</strong>: Static data injected into the graph</li>
<li><strong>Groups</strong>: Logical collections of related nodes</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{Graph, GraphNode, GraphConnection, GraphEdge, PortType};
use std::collections::HashMap;

// Create a new graph
let mut graph = Graph::new("MyWorkflow", false, None);

// Add nodes
graph.add_node("source", "DataSource", None);
graph.add_node("processor", "DataProcessor", None);
graph.add_node("sink", "DataSink", None);

// Connect nodes
graph.add_connection("source", "output", "processor", "input", None);
graph.add_connection("processor", "output", "sink", "input", None);
<span class="boring">}</span></code></pre></pre>
<h3 id="port-type-system"><a class="header" href="#port-type-system">Port Type System</a></h3>
<p>Reflow uses a sophisticated type system to ensure data compatibility between connected nodes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, PartialEq)]
pub enum PortType {
    Any,                              // Accepts any data type
    Flow,                            // Control flow signals
    Event,                           // Event-driven data
    Boolean,                         // Boolean values
    Integer,                         // Integer numbers
    Float,                          // Floating-point numbers
    String,                         // Text data
    Object(String),                 // Structured objects with schema
    Array(Box&lt;PortType&gt;),          // Arrays of typed elements
    Stream,                        // Streaming data
    Encoded,                       // Binary encoded data
    Option(Box&lt;PortType&gt;),         // Optional values
}
<span class="boring">}</span></code></pre></pre>
<h3 id="type-compatibility"><a class="header" href="#type-compatibility">Type Compatibility</a></h3>
<p>The system automatically validates type compatibility when connections are made:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// These connections are valid
graph.add_connection("int_source", "out", "float_sink", "in", None); // Integer â†’ Float
graph.add_connection("any_source", "out", "string_sink", "in", None); // Any â†’ String
graph.add_connection("data", "out", "stream", "in", None);            // Any â†’ Stream

// This would be invalid and rejected
// graph.add_connection("string_source", "out", "int_sink", "in", None); // String â†› Integer
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-operations"><a class="header" href="#graph-operations">Graph Operations</a></h2>
<h3 id="node-management"><a class="header" href="#node-management">Node Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add node with metadata
let metadata = HashMap::from([
    ("x".to_string(), json!(100)),
    ("y".to_string(), json!(200)),
    ("description".to_string(), json!("Processes incoming data"))
]);
graph.add_node("processor", "DataProcessor", Some(metadata));

// Update node metadata
graph.set_node_metadata("processor", HashMap::from([
    ("color".to_string(), json!("#ff0000"))
]));

// Remove node (also removes all connections)
graph.remove_node("processor");
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-management"><a class="header" href="#connection-management">Connection Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add connection with metadata
let conn_metadata = HashMap::from([
    ("weight".to_string(), json!(0.8)),
    ("priority".to_string(), json!("high"))
]);
graph.add_connection("source", "data", "sink", "input", Some(conn_metadata));

// Get connection details
if let Some(connection) = graph.get_connection("source", "data", "sink", "input") {
    println!("Connection: {:?}", connection);
}

// Remove specific connection
graph.remove_connection("source", "data", "sink", "input");
<span class="boring">}</span></code></pre></pre>
<h3 id="initial-information-packets-iips"><a class="header" href="#initial-information-packets-iips">Initial Information Packets (IIPs)</a></h3>
<p>IIPs allow you to inject static data into the graph at startup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::json;

// Add configuration data
graph.add_initial(
    json!({"database_url": "postgresql://localhost/mydb"}),
    "database_connector",
    "config",
    None
);

// Add initial data with index for array ports
graph.add_initial_index(
    json!("input_file.txt"),
    "file_reader",
    "filenames",
    0,
    None
);
<span class="boring">}</span></code></pre></pre>
<h3 id="graph-ports"><a class="header" href="#graph-ports">Graph Ports</a></h3>
<p>Expose internal node ports as graph-level interfaces:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add input port to graph
graph.add_inport(
    "data_input",           // External port name
    "processor",            // Internal node
    "input",               // Internal port
    PortType::Any,         // Port type
    None                   // Metadata
);

// Add output port to graph
graph.add_outport(
    "processed_data",      // External port name
    "processor",           // Internal node
    "output",              // Internal port
    PortType::Object("ProcessedData".to_string()),
    None
);
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-validation"><a class="header" href="#graph-validation">Graph Validation</a></h2>
<h3 id="automatic-validation"><a class="header" href="#automatic-validation">Automatic Validation</a></h3>
<p>The graph system performs continuous validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Validate entire graph
let validation_result = graph.validate_flow()?;

if !validation_result.cycles.is_empty() {
    println!("Cycles detected: {:?}", validation_result.cycles);
}

if !validation_result.orphaned_nodes.is_empty() {
    println!("Orphaned nodes: {:?}", validation_result.orphaned_nodes);
}

for mismatch in validation_result.port_mismatches {
    println!("Port mismatch: {}", mismatch);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cycle-detection"><a class="header" href="#cycle-detection">Cycle Detection</a></h3>
<p>Advanced cycle detection with path tracking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detect first cycle
if let Some(cycle) = graph.detect_cycles() {
    println!("Cycle found: {:?}", cycle);
}

// Comprehensive cycle analysis
let cycle_analysis = graph.analyze_cycles();
println!("Total cycles: {}", cycle_analysis.total_cycles);
println!("Nodes in cycles: {:?}", cycle_analysis.nodes_in_cycles);
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-analysis"><a class="header" href="#performance-analysis">Performance Analysis</a></h2>
<h3 id="parallelism-detection"><a class="header" href="#parallelism-detection">Parallelism Detection</a></h3>
<p>Identify opportunities for parallel execution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parallelism = graph.analyze_parallelism();

// Parallel branches that can execute simultaneously
for branch in parallelism.parallel_branches {
    println!("Parallel branch: {:?}", branch.nodes);
}

// Pipeline stages for sequential execution
for stage in parallelism.pipeline_stages {
    println!("Stage {}: {:?}", stage.level, stage.nodes);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bottleneck-analysis"><a class="header" href="#bottleneck-analysis">Bottleneck Analysis</a></h3>
<p>Find performance bottlenecks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bottlenecks = graph.detect_bottlenecks();

for bottleneck in bottlenecks {
    match bottleneck {
        Bottleneck::HighDegree(node) =&gt; {
            println!("High-degree bottleneck at node: {}", node);
        }
        Bottleneck::SequentialChain(chain) =&gt; {
            println!("Sequential chain that could be parallelized: {:?}", chain);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-analysis"><a class="header" href="#resource-analysis">Resource Analysis</a></h3>
<p>Estimate execution requirements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let analysis = graph.analyze_for_runtime();

println!("Estimated execution time: {:.2}s", analysis.estimated_execution_time);
println!("Resource requirements: {:?}", analysis.resource_requirements);

for suggestion in analysis.optimization_suggestions {
    match suggestion {
        OptimizationSuggestion::ParallelizableChain { nodes } =&gt; {
            println!("Consider parallelizing: {:?}", nodes);
        }
        OptimizationSuggestion::RedundantNode { node, reason } =&gt; {
            println!("Redundant node {}: {}", node, reason);
        }
        OptimizationSuggestion::ResourceBottleneck { resource, severity } =&gt; {
            println!("Resource bottleneck in {}: {:.1}%", resource, severity * 100.0);
        }
        OptimizationSuggestion::DataTypeOptimization { from, to, suggestion } =&gt; {
            println!("Optimize {} â†’ {}: {}", from, to, suggestion);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-layout"><a class="header" href="#graph-layout">Graph Layout</a></h2>
<h3 id="automatic-layout"><a class="header" href="#automatic-layout">Automatic Layout</a></h3>
<p>The system provides intelligent automatic layout:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Calculate optimal positions
let positions = graph.calculate_layout();

for (node_id, position) in positions {
    println!("Node {}: x={:.1}, y={:.1}", node_id, position.x, position.y);
}

// Apply layout to graph metadata
graph.auto_layout()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="manual-positioning"><a class="header" href="#manual-positioning">Manual Positioning</a></h3>
<p>Set custom node positions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set specific position
graph.set_node_position("processor", 150.0, 100.0)?;

// Set position with custom dimensions and anchor
let metadata = HashMap::from([
    ("position".to_string(), json!({"x": 200, "y": 150})),
    ("dimensions".to_string(), json!({
        "width": 120,
        "height": 80,
        "anchor": {"x": 0.5, "y": 0.5}  // Center anchor
    }))
]);
graph.set_node_metadata("custom_node", metadata);
<span class="boring">}</span></code></pre></pre>
<h2 id="event-system"><a class="header" href="#event-system">Event System</a></h2>
<h3 id="real-time-updates"><a class="header" href="#real-time-updates">Real-time Updates</a></h3>
<p>Subscribe to graph changes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::GraphEvents;

// Graph creates event channel automatically
let (sender, receiver) = graph.event_channel;

// Listen for events
while let Ok(event) = receiver.recv() {
    match event {
        GraphEvents::AddNode(node_data) =&gt; {
            println!("Node added: {:?}", node_data);
        }
        GraphEvents::AddConnection(conn_data) =&gt; {
            println!("Connection added: {:?}", conn_data);
        }
        GraphEvents::RemoveNode(node_data) =&gt; {
            println!("Node removed: {:?}", node_data);
        }
        // ... handle other events
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="event-types"><a class="header" href="#event-types">Event Types</a></h3>
<p>Complete list of graph events:</p>
<ul>
<li><code>AddNode</code> / <code>RemoveNode</code> / <code>RenameNode</code> / <code>ChangeNode</code></li>
<li><code>AddConnection</code> / <code>RemoveConnection</code> / <code>ChangeConnection</code></li>
<li><code>AddInitial</code> / <code>RemoveInitial</code></li>
<li><code>AddGroup</code> / <code>RemoveGroup</code> / <code>RenameGroup</code> / <code>ChangeGroup</code></li>
<li><code>AddInport</code> / <code>RemoveInport</code> / <code>RenameInport</code> / <code>ChangeInport</code></li>
<li><code>AddOutport</code> / <code>RemoveOutport</code> / <code>RenameOutport</code> / <code>ChangeOutport</code></li>
<li><code>ChangeProperties</code></li>
<li><code>StartTransaction</code> / <code>EndTransaction</code> / <code>Transaction</code></li>
</ul>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<h3 id="export-format"><a class="header" href="#export-format">Export Format</a></h3>
<p>Graphs can be serialized to JSON for storage and interchange:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Export to JSON-compatible format
let export = graph.export();
let json_string = serde_json::to_string_pretty(&amp;export)?;

// Load from JSON
let loaded_graph = Graph::load(export, Some(metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="export-structure"><a class="header" href="#export-structure">Export Structure</a></h3>
<pre><code class="language-json">{
  "caseSensitive": false,
  "properties": {
    "name": "MyWorkflow",
    "description": "A sample workflow"
  },
  "processes": {
    "source": {
      "id": "source",
      "component": "DataSource",
      "metadata": {"x": 0, "y": 0}
    }
  },
  "connections": [
    {
      "from": {"nodeId": "source", "portId": "output"},
      "to": {"nodeId": "sink", "portId": "input"},
      "metadata": {}
    }
  ],
  "inports": {},
  "outports": {},
  "groups": []
}
</code></pre>
<h2 id="webassembly-support"><a class="header" href="#webassembly-support">WebAssembly Support</a></h2>
<h3 id="browser-integration"><a class="header" href="#browser-integration">Browser Integration</a></h3>
<p>The graph system compiles to WebAssembly for browser usage:</p>
<pre><code class="language-javascript">import { Graph } from 'reflow-network';

// Create graph in browser
const graph = new Graph("WebWorkflow", false, {});

// Add nodes and connections
graph.addNode("input", "InputNode", {x: 0, y: 0});
graph.addNode("output", "OutputNode", {x: 200, y: 0});
graph.addConnection("input", "out", "output", "in", {});

// Subscribe to events
graph.subscribe((event) =&gt; {
    console.log("Graph event:", event);
});

// Export for persistence
const exported = graph.toJSON();
localStorage.setItem('workflow', JSON.stringify(exported));
</code></pre>
<h3 id="typescript-support"><a class="header" href="#typescript-support">TypeScript Support</a></h3>
<p>Full TypeScript definitions are generated:</p>
<pre><code class="language-typescript">interface GraphNode {
    id: string;
    component: string;
    metadata?: Map&lt;string, any&gt;;
}

interface GraphConnection {
    from: GraphEdge;
    to: GraphEdge;
    metadata?: Map&lt;string, any&gt;;
    data?: any;
}

type PortType = 
  | { type: "flow" }
  | { type: "event" }
  | { type: "boolean" }
  | { type: "integer" }
  | { type: "float" }
  | { type: "string" }
  | { type: "object", value: string }
  | { type: "array", value: PortType }
  | { type: "stream" }
  | { type: "encoded" }
  | { type: "any" }
  | { type: "option", value: PortType };
</code></pre>
<h2 id="graph-history"><a class="header" href="#graph-history">Graph History</a></h2>
<h3 id="undoredo-system"><a class="header" href="#undoredo-system">Undo/Redo System</a></h3>
<p>Track changes for undo/redo functionality:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create graph with history tracking
let (mut graph, mut history) = Graph::with_history();

// Make changes
graph.add_node("test", "TestNode", None);
graph.add_connection("test", "out", "sink", "in", None);

// Undo last change
if let Some(event) = history.undo() {
    // Apply inverse operation
    history.apply_inverse(&amp;mut graph, event)?;
}

// Redo change
if let Some(event) = history.redo() {
    // Reapply operation
    history.apply_event(&amp;mut graph, event)?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h2>
<h3 id="subgraph-analysis"><a class="header" href="#subgraph-analysis">Subgraph Analysis</a></h3>
<p>Extract and analyze subgraphs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get reachable subgraph from a node
if let Some(subgraph) = graph.get_reachable_subgraph("start_node") {
    let analysis = graph.analyze_subgraph(&amp;subgraph);
    
    println!("Subgraph nodes: {}", analysis.node_count);
    println!("Max depth: {}", analysis.max_depth);
    println!("Is cyclic: {}", analysis.is_cyclic);
    println!("Branching factor: {:.2}", analysis.branching_factor);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="graph-traversal"><a class="header" href="#graph-traversal">Graph Traversal</a></h3>
<p>Efficient traversal algorithms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Depth-first traversal
graph.traverse_depth_first("start_node", |node| {
    println!("Visiting node: {}", node.id);
})?;

// Breadth-first traversal
graph.traverse_breadth_first("start_node", |node| {
    println!("Processing: {} ({})", node.id, node.component);
})?;
<span class="boring">}</span></code></pre></pre>
<h3 id="node-groups"><a class="header" href="#node-groups">Node Groups</a></h3>
<p>Organize nodes into logical groups:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create group
graph.add_group("data_processing", vec!["filter".to_string(), "transform".to_string()], None);

// Add node to existing group
graph.add_to_group("data_processing", "validator");

// Remove from group
graph.remove_from_group("data_processing", "validator");
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h3>
<ol>
<li><strong>Use indexed operations</strong>: The graph uses internal indices for O(1) lookups</li>
<li><strong>Batch modifications</strong>: Group related changes to minimize event overhead</li>
<li><strong>Validate incrementally</strong>: Use targeted validation for better performance</li>
<li><strong>Cache analysis results</strong>: Store expensive analysis results when graph is stable</li>
</ol>
<h3 id="memory-management-1"><a class="header" href="#memory-management-1">Memory Management</a></h3>
<ol>
<li><strong>Clean up connections</strong>: Always remove connections before removing nodes</li>
<li><strong>Limit history size</strong>: Use <code>with_history_and_limit()</code> for bounded memory usage</li>
<li><strong>Dispose of event listeners</strong>: Unsubscribe from events when no longer needed</li>
</ol>
<h3 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h3>
<ol>
<li><strong>Check return values</strong>: Most operations return Result types</li>
<li><strong>Validate before execution</strong>: Use validation methods before running workflows</li>
<li><strong>Handle cycles gracefully</strong>: Implement cycle detection in your workflow runtime</li>
<li><strong>Monitor resource usage</strong>: Track memory and CPU usage for large graphs</li>
</ol>
<h2 id="integration-examples"><a class="header" href="#integration-examples">Integration Examples</a></h2>
<h3 id="visual-editor-integration"><a class="header" href="#visual-editor-integration">Visual Editor Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In a visual editor, sync UI with graph events
graph.subscribe(|event| {
    match event {
        GraphEvents::AddNode(data) =&gt; ui.add_node_widget(data),
        GraphEvents::RemoveNode(data) =&gt; ui.remove_node_widget(data.id),
        GraphEvents::AddConnection(data) =&gt; ui.draw_connection(data),
        _ =&gt; {}
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="workflow-execution"><a class="header" href="#workflow-execution">Workflow Execution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Convert graph to executable network
let network = Network::from_graph(&amp;graph)?;

// Execute with runtime
let runtime = Runtime::new();
runtime.execute(network).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li><a href="architecture/../api/graph/creating-graphs.html">Creating Graphs</a> - Detailed API guide</li>
<li><a href="architecture/../api/graph/analysis.html">Graph Analysis</a> - Validation and performance analysis</li>
<li><a href="architecture/../api/graph/layout.html">Layout System</a> - Positioning and visualization</li>
<li><a href="architecture/../api/graph/advanced.html">Advanced Features</a> - History, subgraphs, and optimization</li>
<li><a href="architecture/../tutorials/building-visual-editor.html">Building Visual Editors</a> - Complete tutorial</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-actors"><a class="header" href="#creating-actors">Creating Actors</a></h1>
<p>This guide covers how to create custom actors in Reflow using the correct implementation patterns. Learn everything from basic actors to advanced patterns with state management and error handling.</p>
<h2 id="creating-actors-two-approaches"><a class="header" href="#creating-actors-two-approaches">Creating Actors: Two Approaches</a></h2>
<p>Reflow provides two ways to create actors:</p>
<ol>
<li><strong>Actor Macro</strong> (Recommended): Use the <code>#[actor]</code> macro for simple, declarative actor creation</li>
<li><strong>Manual Implementation</strong>: Implement the <code>Actor</code> trait directly for maximum control</li>
</ol>
<h2 id="using-the-actor-macro"><a class="header" href="#using-the-actor-macro">Using the Actor Macro</a></h2>
<p>The <code>#[actor]</code> macro is the recommended way to create actors. It generates all the necessary boilerplate code including the Actor trait implementation, port management, and process creation.</p>
<h3 id="basic-actor"><a class="header" href="#basic-actor">Basic Actor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
use reflow_network::{
    actor::ActorContext,
    message::Message,
};
use actor_macro::actor;

#[actor(
    HelloActor,
    inports::&lt;100&gt;(input),
    outports::&lt;50&gt;(output)
)]
async fn hello_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    if let Some(Message::String(text)) = payload.get("input") {
        let response = format!("Hello, {}!", text);
        
        Ok([
            ("output".to_owned(), Message::String(response))
        ].into())
    } else {
        Err(anyhow::anyhow!("Expected string input"))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="actor-with-multiple-inputs"><a class="header" href="#actor-with-multiple-inputs">Actor with Multiple Inputs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actor(
    GreeterActor,
    inports::&lt;100&gt;(name, age),
    outports::&lt;50&gt;(greeting),
    await_all_inports  // Wait for both inputs before processing
)]
async fn greeter_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    let name = match payload.get("name").expect("expected name") {
        Message::String(s) =&gt; s,
        _ =&gt; return Err(anyhow::anyhow!("Name must be a string")),
    };
    
    let age = match payload.get("age").expect("expected age") {
        Message::Integer(n) =&gt; *n,
        _ =&gt; return Err(anyhow::anyhow!("Age must be an integer")),
    };
    
    let greeting = format!("Hello {}, you are {} years old!", name, age);
    
    Ok([
        ("greeting".to_owned(), Message::String(greeting))
    ].into())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stateful-actor"><a class="header" href="#stateful-actor">Stateful Actor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::actor::MemoryState;

#[actor(
    CounterActor,
    state(MemoryState),
    inports::&lt;100&gt;(increment, reset),
    outports::&lt;50&gt;(count, total)
)]
async fn counter_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    let state = context.get_state();
    
    let mut state_guard = state.lock();
    let memory_state = state_guard
        .as_mut_any()
        .downcast_mut::&lt;MemoryState&gt;()
        .expect("Expected MemoryState");
    
    // Initialize state if needed
    if !memory_state.contains_key("count") {
        memory_state.insert("count", serde_json::json!(0));
        memory_state.insert("total", serde_json::json!(0));
    }
    
    let current_count = memory_state.get("count")
        .and_then(|v| v.as_i64())
        .unwrap_or(0);
    
    let current_total = memory_state.get("total")
        .and_then(|v| v.as_i64())
        .unwrap_or(0);
    
    let (new_count, new_total) = if payload.contains_key("reset") {
        // Reset counter
        (0, current_total)
    } else if let Some(Message::Integer(amount)) = payload.get("increment") {
        // Increment by specific amount
        let new_count = current_count + amount;
        (new_count, current_total + amount)
    } else {
        // Default increment by 1
        let new_count = current_count + 1;
        (new_count, current_total + 1)
    };
    
    // Update state
    memory_state.insert("count", serde_json::json!(new_count));
    memory_state.insert("total", serde_json::json!(new_total));
    
    println!("Counter: {} (total: {})", new_count, new_total);
    
    Ok([
        ("count".to_owned(), Message::Integer(new_count)),
        ("total".to_owned(), Message::Integer(new_total)),
    ].into())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="actor-macro-parameters"><a class="header" href="#actor-macro-parameters">Actor Macro Parameters</a></h2>
<h3 id="port-definitions"><a class="header" href="#port-definitions">Port Definitions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic ports (unbounded channels)
inports(A, B, C)
outports(X, Y)

// Ports with capacity (bounded channels)
inports::&lt;100&gt;(A, B)      // Input ports with capacity 100
outports::&lt;50&gt;(X, Y)      // Output ports with capacity 50
<span class="boring">}</span></code></pre></pre>
<h3 id="state-management-2"><a class="header" href="#state-management-2">State Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use built-in MemoryState
state(MemoryState)

// Custom state types can also be used
// (must implement ActorState trait)
<span class="boring">}</span></code></pre></pre>
<h3 id="input-synchronization"><a class="header" href="#input-synchronization">Input Synchronization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Process inputs as they arrive (default)
#[actor(MyActor, inports(A, B), outports(C))]

// Wait for ALL inputs before processing
#[actor(MyActor, inports(A, B), outports(C), await_all_inports)]
<span class="boring">}</span></code></pre></pre>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="data-processing-pipeline"><a class="header" href="#data-processing-pipeline">Data Processing Pipeline</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sum Actor - adds numbers from multiple sources
#[actor(
    SumActor,
    inports::&lt;100&gt;(numbers),
    outports::&lt;50&gt;(sum, count)
)]
async fn sum_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    if let Some(Message::Array(numbers)) = payload.get("numbers") {
        let mut sum = 0i64;
        let mut count = 0usize;
        
        for num in numbers {
            if let Message::Integer(n) = num {
                sum += n;
                count += 1;
            }
        }
        
        println!("Sum Actor: {} numbers, sum = {}", count, sum);
        
        Ok([
            ("sum".to_owned(), Message::Integer(sum)),
            ("count".to_owned(), Message::Integer(count as i64)),
        ].into())
    } else {
        Err(anyhow::anyhow!("Expected array of numbers"))
    }
}

// Filter Actor - filters values based on condition
#[actor(
    FilterActor,
    inports::&lt;100&gt;(values, threshold),
    outports::&lt;50&gt;(passed, failed),
    await_all_inports
)]
async fn filter_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    let threshold = match payload.get("threshold").expect("expected threshold") {
        Message::Integer(t) =&gt; *t,
        _ =&gt; return Err(anyhow::anyhow!("Threshold must be integer")),
    };
    
    if let Some(Message::Array(values)) = payload.get("values") {
        let mut passed = Vec::new();
        let mut failed = Vec::new();
        
        for value in values {
            if let Message::Integer(n) = value {
                if *n &gt;= threshold {
                    passed.push(value.clone());
                } else {
                    failed.push(value.clone());
                }
            }
        }
        
        println!("Filter Actor: {} passed, {} failed (threshold: {})", 
                passed.len(), failed.len(), threshold);
        
        Ok([
            ("passed".to_owned(), Message::Array(passed)),
            ("failed".to_owned(), Message::Array(failed)),
        ].into())
    } else {
        Err(anyhow::anyhow!("Expected array of values"))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="http-client-actor"><a class="header" href="#http-client-actor">HTTP Client Actor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest;

#[actor(
    HttpClientActor,
    inports::&lt;50&gt;(request),
    outports::&lt;25&gt;(response, error)
)]
async fn http_client_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    // Parse request
    let request = match payload.get("request") {
        Some(Message::Object(obj)) =&gt; obj,
        _ =&gt; return Err(anyhow::anyhow!("Expected request object")),
    };
    
    let url = match request.get("url") {
        Some(Message::String(s)) =&gt; s,
        _ =&gt; return Err(anyhow::anyhow!("Missing URL in request")),
    };
    
    let method = request.get("method")
        .and_then(|m| if let Message::String(s) = m { Some(s.as_str()) } else { None })
        .unwrap_or("GET");
    
    // Make HTTP request
    let client = reqwest::Client::new();
    
    let result = match method {
        "GET" =&gt; {
            match client.get(url).send().await {
                Ok(response) =&gt; {
                    let status = response.status().as_u16();
                    let text = response.text().await.unwrap_or_default();
                    
                    let response_obj = [
                        ("status".to_owned(), Message::Integer(status as i64)),
                        ("body".to_owned(), Message::String(text)),
                        ("url".to_owned(), Message::String(url.clone())),
                    ].into();
                    
                    [("response".to_owned(), Message::Object(response_obj))].into()
                },
                Err(e) =&gt; {
                    let error_obj = [
                        ("message".to_owned(), Message::String(e.to_string())),
                        ("url".to_owned(), Message::String(url.clone())),
                    ].into();
                    
                    [("error".to_owned(), Message::Object(error_obj))].into()
                }
            }
        },
        "POST" =&gt; {
            let body = request.get("body")
                .and_then(|b| if let Message::String(s) = b { Some(s) } else { None })
                .unwrap_or("");
            
            match client.post(url).body(body.to_string()).send().await {
                Ok(response) =&gt; {
                    let status = response.status().as_u16();
                    let text = response.text().await.unwrap_or_default();
                    
                    let response_obj = [
                        ("status".to_owned(), Message::Integer(status as i64)),
                        ("body".to_owned(), Message::String(text)),
                        ("url".to_owned(), Message::String(url.clone())),
                    ].into();
                    
                    [("response".to_owned(), Message::Object(response_obj))].into()
                },
                Err(e) =&gt; {
                    let error_obj = [
                        ("message".to_owned(), Message::String(e.to_string())),
                        ("url".to_owned(), Message::String(url.clone())),
                    ].into();
                    
                    [("error".to_owned(), Message::Object(error_obj))].into()
                }
            }
        },
        _ =&gt; {
            let error_obj = [
                ("message".to_owned(), Message::String(format!("Unsupported method: {}", method))),
            ].into();
            
            [("error".to_owned(), Message::Object(error_obj))].into()
        }
    };
    
    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-processing-actor"><a class="header" href="#batch-processing-actor">Batch Processing Actor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actor(
    BatchActor,
    state(MemoryState),
    inports::&lt;200&gt;(item, flush),
    outports::&lt;50&gt;(batch, count)
)]
async fn batch_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    let state = context.get_state();
    
    let mut state_guard = state.lock();
    let memory_state = state_guard
        .as_mut_any()
        .downcast_mut::&lt;MemoryState&gt;()
        .expect("Expected MemoryState");
    
    // Initialize batch storage
    if !memory_state.contains_key("batch") {
        memory_state.insert("batch", serde_json::json!([]));
        memory_state.insert("batch_size", serde_json::json!(10)); // Configurable batch size
    }
    
    let batch_size = memory_state.get("batch_size")
        .and_then(|v| v.as_u64())
        .unwrap_or(10) as usize;
    
    let mut current_batch: Vec&lt;serde_json::Value&gt; = memory_state.get("batch")
        .and_then(|v| v.as_array())
        .cloned()
        .unwrap_or_default();
    
    // Handle flush command
    if payload.contains_key("flush") {
        if !current_batch.is_empty() {
            let batch_messages: Vec&lt;Message&gt; = current_batch
                .into_iter()
                .map(|v| Message::from(v))
                .collect();
            
            // Clear batch
            memory_state.insert("batch", serde_json::json!([]));
            
            let count = batch_messages.len();
            println!("Batch Actor: Flushing {} items", count);
            
            return Ok([
                ("batch".to_owned(), Message::Array(batch_messages)),
                ("count".to_owned(), Message::Integer(count as i64)),
            ].into());
        } else {
            return Ok(HashMap::new()); // No items to flush
        }
    }
    
    // Handle new item
    if let Some(item) = payload.get("item") {
        current_batch.push(serde_json::json!(item));
        
        // Check if batch is full
        if current_batch.len() &gt;= batch_size {
            let batch_messages: Vec&lt;Message&gt; = current_batch
                .iter()
                .map(|v| Message::from(v.clone()))
                .collect();
            
            // Clear batch
            memory_state.insert("batch", serde_json::json!([]));
            
            let count = batch_messages.len();
            println!("Batch Actor: Full batch of {} items", count);
            
            Ok([
                ("batch".to_owned(), Message::Array(batch_messages)),
                ("count".to_owned(), Message::Integer(count as i64)),
            ].into())
        } else {
            // Update batch state
            memory_state.insert("batch", serde_json::json!(current_batch));
            
            // Return empty result (batch not ready yet)
            Ok(HashMap::new())
        }
    } else {
        Err(anyhow::anyhow!("Expected item or flush command"))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-patterns"><a class="header" href="#error-handling-patterns">Error Handling Patterns</a></h2>
<h3 id="graceful-error-handling"><a class="header" href="#graceful-error-handling">Graceful Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actor(
    ValidatorActor,
    inports::&lt;100&gt;(data),
    outports::&lt;50&gt;(valid, invalid, error)
)]
async fn validator_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    match payload.get("data") {
        Some(Message::Integer(n)) if *n &gt; 0 =&gt; {
            println!("Validator: Valid number {}", n);
            Ok([("valid".to_owned(), Message::Integer(*n))].into())
        },
        Some(Message::Integer(n)) =&gt; {
            println!("Validator: Invalid number {} (must be positive)", n);
            Ok([("invalid".to_owned(), Message::Integer(*n))].into())
        },
        Some(other) =&gt; {
            let error_msg = format!("Expected integer, got {:?}", other);
            println!("Validator: {}", error_msg);
            Ok([("error".to_owned(), Message::Error(error_msg))].into())
        },
        None =&gt; {
            Err(anyhow::anyhow!("Missing data field"))
        }
    }
}

// Retry Actor - implements retry logic with exponential backoff
#[actor(
    RetryActor,
    state(MemoryState),
    inports::&lt;50&gt;(task),
    outports::&lt;25&gt;(success, failure)
)]
async fn retry_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    let state = context.get_state();
    
    let task = payload.get("task")
        .ok_or_else(|| anyhow::anyhow!("Missing task"))?;
    
    let max_retries = 3;
    let base_delay_ms = 100;
    
    for attempt in 1..=max_retries {
        match simulate_task_processing(task).await {
            Ok(result) =&gt; {
                println!("Retry Actor: Task succeeded on attempt {}", attempt);
                return Ok([("success".to_owned(), result)].into());
            },
            Err(e) =&gt; {
                if attempt &lt; max_retries {
                    let delay = base_delay_ms * (2_u64.pow(attempt - 1));
                    println!("Retry Actor: Attempt {} failed, retrying in {}ms: {}", 
                            attempt, delay, e);
                    
                    tokio::time::sleep(tokio::time::Duration::from_millis(delay)).await;
                } else {
                    println!("Retry Actor: All {} attempts failed: {}", max_retries, e);
                    return Ok([
                        ("failure".to_owned(), Message::Error(format!("Failed after {} attempts: {}", max_retries, e)))
                    ].into());
                }
            }
        }
    }
    
    unreachable!()
}

async fn simulate_task_processing(task: &amp;Message) -&gt; Result&lt;Message, anyhow::Error&gt; {
    // Simulate processing that might fail
    use rand::Rng;
    let mut rng = rand::thread_rng();
    
    if rng.gen_bool(0.7) { // 70% success rate
        Ok(Message::String(format!("Processed: {:?}", task)))
    } else {
        Err(anyhow::anyhow!("Simulated task failure"))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-actors-in-networks"><a class="header" href="#using-actors-in-networks">Using Actors in Networks</a></h2>
<h3 id="registration-and-instantiation"><a class="header" href="#registration-and-instantiation">Registration and Instantiation</a></h3>
<pre><pre class="playground"><code class="language-rust">use reflow_network::{Network, NetworkConfig};
use reflow_network::connector::{Connector, ConnectionPoint, InitialPacket};

#[tokio::main]
async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {
    let mut network = Network::new(NetworkConfig::default());
    
    // Register actor types
    network.register_actor("hello_process", HelloActor::new())?;
    network.register_actor("counter_process", CounterActor::new())?;
    network.register_actor("validator_process", ValidatorActor::new())?;
    
    // Create actor instances
    network.add_node("hello1", "hello_process")?;
    network.add_node("counter1", "counter_process")?;
    network.add_node("validator1", "validator_process")?;
    
    // Connect actors
    network.add_connection(Connector {
        from: ConnectionPoint {
            actor: "hello1".to_owned(),
            port: "output".to_owned(),
            ..Default::default()
        },
        to: ConnectionPoint {
            actor: "validator1".to_owned(),
            port: "data".to_owned(),
            ..Default::default()
        },
    });
    
    // Send initial data
    network.add_initial(InitialPacket {
        to: ConnectionPoint {
            actor: "hello1".to_owned(),
            port: "input".to_owned(),
            initial_data: Some(Message::String("World".to_owned())),
        },
    });
    
    // Start the network
    network.start().await?;
    
    // Wait for processing
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    
    Ok(())
}</code></pre></pre>
<h2 id="testing-actors-1"><a class="header" href="#testing-actors-1">Testing Actors</a></h2>
<h3 id="unit-testing-actor-functions"><a class="header" href="#unit-testing-actor-functions">Unit Testing Actor Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use reflow_network::actor::{ActorContext, MemoryState, ActorLoad};
    use std::sync::Arc;
    use parking_lot::Mutex;
    
    fn create_test_context(payload: HashMap&lt;String, Message&gt;) -&gt; ActorContext {
        let (tx, _rx) = flume::unbounded();
        let state: Arc&lt;Mutex&lt;dyn reflow_network::actor::ActorState&gt;&gt; = 
            Arc::new(Mutex::new(MemoryState::default()));
        
        ActorContext::new(
            payload,
            (tx, _rx),
            state,
            HashMap::new(),
            Arc::new(Mutex::new(ActorLoad::new(0))),
        )
    }
    
    #[tokio::test]
    async fn test_hello_actor() {
        let payload = HashMap::from([
            ("input".to_string(), Message::String("Test".to_string()))
        ]);
        
        let context = create_test_context(payload);
        let result = hello_actor(context).await.unwrap();
        
        assert_eq!(
            result.get("output"),
            Some(&amp;Message::String("Hello, Test!".to_string()))
        );
    }
    
    #[tokio::test]
    async fn test_counter_actor_increment() {
        let payload = HashMap::from([
            ("increment".to_string(), Message::Integer(5))
        ]);
        
        let context = create_test_context(payload);
        let result = counter_actor(context).await.unwrap();
        
        assert_eq!(result.get("count"), Some(&amp;Message::Integer(5)));
        assert_eq!(result.get("total"), Some(&amp;Message::Integer(5)));
    }
    
    #[tokio::test]
    async fn test_greeter_actor() {
        let payload = HashMap::from([
            ("name".to_string(), Message::String("Alice".to_string())),
            ("age".to_string(), Message::Integer(30)),
        ]);
        
        let context = create_test_context(payload);
        let result = greeter_actor(context).await.unwrap();
        
        assert_eq!(
            result.get("greeting"),
            Some(&amp;Message::String("Hello Alice, you are 30 years old!".to_string()))
        );
    }
    
    #[tokio::test]
    async fn test_validator_actor_valid() {
        let payload = HashMap::from([
            ("data".to_string(), Message::Integer(42))
        ]);
        
        let context = create_test_context(payload);
        let result = validator_actor(context).await.unwrap();
        
        assert_eq!(result.get("valid"), Some(&amp;Message::Integer(42)));
        assert!(!result.contains_key("invalid"));
        assert!(!result.contains_key("error"));
    }
    
    #[tokio::test]
    async fn test_validator_actor_invalid() {
        let payload = HashMap::from([
            ("data".to_string(), Message::Integer(-5))
        ]);
        
        let context = create_test_context(payload);
        let result = validator_actor(context).await.unwrap();
        
        assert_eq!(result.get("invalid"), Some(&amp;Message::Integer(-5)));
        assert!(!result.contains_key("valid"));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="actor-design-guidelines"><a class="header" href="#actor-design-guidelines">Actor Design Guidelines</a></h3>
<ol>
<li><strong>Single Responsibility</strong>: Each actor should have one clear purpose</li>
<li><strong>Idempotent Processing</strong>: Handle duplicate messages gracefully</li>
<li><strong>Error Propagation</strong>: Use both Result returns and error output ports</li>
<li><strong>State Minimal</strong>: Keep state minimal and well-defined</li>
<li><strong>Port Naming</strong>: Use descriptive port names</li>
</ol>
<h3 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use appropriate channel capacities
inports::&lt;1000&gt;(high_volume_input)   // High throughput
inports::&lt;10&gt;(low_volume_input)      // Low throughput

// Batch processing for efficiency
#[actor(
    EfficientProcessor,
    inports::&lt;500&gt;(batch),
    outports::&lt;100&gt;(results)
)]
async fn efficient_processor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    if let Some(Message::Array(items)) = payload.get("batch") {
        // Process items in parallel
        use futures::stream::{self, StreamExt};
        
        let results: Vec&lt;Message&gt; = stream::iter(items.iter())
            .map(|item| async move {
                process_single_item(item).await
            })
            .buffer_unordered(10) // Process 10 items concurrently
            .collect()
            .await;
        
        Ok([("results".to_owned(), Message::Array(results))].into())
    } else {
        Err(anyhow::anyhow!("Expected batch of items"))
    }
}

async fn process_single_item(item: &amp;Message) -&gt; Message {
    // Simulate processing
    tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
    item.clone()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-management-2"><a class="header" href="#memory-management-2">Memory Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Avoid cloning large data when possible
#[actor(
    MemoryEfficientActor,
    inports::&lt;100&gt;(data),
    outports::&lt;50&gt;(processed)
)]
async fn memory_efficient_actor(context: ActorContext) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    let payload = context.get_payload();
    
    // Process data in-place when possible
    if let Some(Message::Array(items)) = payload.get("data") {
        let count = items.len();
        
        // Instead of cloning all items, just extract what we need
        let summary = Message::Object([
            ("count".to_owned(), Message::Integer(count as i64)),
            ("first_item".to_owned(), items.first().cloned().unwrap_or(Message::None)),
            ("last_item".to_owned(), items.last().cloned().unwrap_or(Message::None)),
        ].into());
        
        Ok([("processed".to_owned(), summary)].into())
    } else {
        Err(anyhow::anyhow!("Expected array data"))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="manual-actor-implementation"><a class="header" href="#manual-actor-implementation">Manual Actor Implementation</a></h2>
<p>For maximum control or when the macro limitations are insufficient, you can implement the Actor trait manually. This approach gives you complete control over the actor's behavior and lifecycle.</p>
<h3 id="basic-manual-actor"><a class="header" href="#basic-manual-actor">Basic Manual Actor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::actor::{Actor, ActorBehavior, ActorContext, Port, MemoryState, ActorLoad};
use reflow_network::message::Message;
use std::collections::HashMap;
use std::sync::Arc;
use parking_lot::Mutex;
use std::pin::Pin;
use std::future::Future;

pub struct ManualActor {
    inports: Port,
    outports: Port,
    name: String,
    load: Arc&lt;Mutex&lt;ActorLoad&gt;&gt;,
}

impl ManualActor {
    pub fn new(name: String) -&gt; Self {
        Self {
            inports: flume::unbounded(),
            outports: flume::unbounded(),
            name,
            load: Arc::new(Mutex::new(ActorLoad::new(0))),
        }
    }
}

impl Actor for ManualActor {
    fn get_behavior(&amp;self) -&gt; ActorBehavior {
        let name = self.name.clone();
        
        Box::new(move |context: ActorContext| {
            let name = name.clone();
            
            Box::pin(async move {
                let payload = context.get_payload();
                
                if let Some(Message::String(text)) = payload.get("input") {
                    let response = format!("{}: Processing '{}'", name, text);
                    println!("{}", response);
                    
                    Ok([
                        ("output".to_owned(), Message::String(response))
                    ].into())
                } else {
                    Err(anyhow::anyhow!("Expected string input"))
                }
            })
        })
    }
    
    fn get_inports(&amp;self) -&gt; Port {
        self.inports.clone()
    }
    
    fn get_outports(&amp;self) -&gt; Port {
        self.outports.clone()
    }
    
    fn load_count(&amp;self) -&gt; Arc&lt;Mutex&lt;ActorLoad&gt;&gt; {
        self.load.clone()
    }
    
    fn create_process(&amp;self) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static + Send&gt;&gt; {
        let inports = self.get_inports();
        let behavior = self.get_behavior();
        let outports = self.get_outports();
        let state: Arc&lt;Mutex&lt;dyn reflow_network::actor::ActorState&gt;&gt; = 
            Arc::new(Mutex::new(MemoryState::default()));
        let load_count = self.load_count();
        
        Box::pin(async move {
            use futures::stream::StreamExt;
            
            loop {
                if let Some(payload) = inports.1.stream().next().await {
                    // Increment load count
                    {
                        let mut load = load_count.lock();
                        load.inc();
                    }
                    
                    let context = ActorContext::new(
                        payload,
                        outports.clone(),
                        state.clone(),
                        HashMap::new(),
                        load_count.clone(),
                    );
                    
                    match behavior(context).await {
                        Ok(result) =&gt; {
                            if !result.is_empty() {
                                let _ = outports.0.send(result);
                            }
                        },
                        Err(e) =&gt; {
                            eprintln!("Error in actor behavior: {:?}", e);
                        }
                    }
                    
                    // Decrement load count
                    {
                        let mut load = load_count.lock();
                        load.dec();
                    }
                }
            }
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="stateful-manual-actor"><a class="header" href="#stateful-manual-actor">Stateful Manual Actor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CustomState {
    pub counter: i64,
    pub last_message: String,
    pub timestamps: Vec&lt;i64&gt;,
}

impl reflow_network::actor::ActorState for CustomState {
    fn as_mut_any(&amp;mut self) -&gt; &amp;mut dyn std::any::Any {
        self
    }
    
    fn as_any(&amp;self) -&gt; &amp;dyn std::any::Any {
        self
    }
}

pub struct StatefulManualActor {
    inports: Port,
    outports: Port,
    initial_state: CustomState,
    load: Arc&lt;Mutex&lt;ActorLoad&gt;&gt;,
}

impl StatefulManualActor {
    pub fn new(initial_state: CustomState) -&gt; Self {
        Self {
            inports: flume::unbounded(),
            outports: flume::unbounded(),
            initial_state,
            load: Arc::new(Mutex::new(ActorLoad::new(0))),
        }
    }
}

impl Actor for StatefulManualActor {
    fn get_behavior(&amp;self) -&gt; ActorBehavior {
        Box::new(|context: ActorContext| {
            Box::pin(async move {
                let payload = context.get_payload();
                let state = context.get_state();
                
                let mut state_guard = state.lock();
                let custom_state = state_guard
                    .as_mut_any()
                    .downcast_mut::&lt;CustomState&gt;()
                    .expect("Expected CustomState");
                
                // Update counter
                custom_state.counter += 1;
                
                // Record timestamp
                let now = chrono::Utc::now().timestamp_millis();
                custom_state.timestamps.push(now);
                
                // Keep only last 10 timestamps
                if custom_state.timestamps.len() &gt; 10 {
                    custom_state.timestamps.remove(0);
                }
                
                // Process message
                if let Some(Message::String(text)) = payload.get("message") {
                    custom_state.last_message = text.clone();
                    
                    let response = format!(
                        "Processed message #{}: '{}' (last 5 timestamps: {:?})",
                        custom_state.counter,
                        text,
                        custom_state.timestamps.iter().rev().take(5).collect::&lt;Vec&lt;_&gt;&gt;()
                    );
                    
                    Ok([
                        ("response".to_owned(), Message::String(response)),
                        ("counter".to_owned(), Message::Integer(custom_state.counter)),
                    ].into())
                } else {
                    Err(anyhow::anyhow!("Expected message field"))
                }
            })
        })
    }
    
    fn get_inports(&amp;self) -&gt; Port {
        self.inports.clone()
    }
    
    fn get_outports(&amp;self) -&gt; Port {
        self.outports.clone()
    }
    
    fn load_count(&amp;self) -&gt; Arc&lt;Mutex&lt;ActorLoad&gt;&gt; {
        self.load.clone()
    }
    
    fn create_process(&amp;self) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static + Send&gt;&gt; {
        let inports = self.get_inports();
        let behavior = self.get_behavior();
        let outports = self.get_outports();
        let state: Arc&lt;Mutex&lt;dyn reflow_network::actor::ActorState&gt;&gt; = 
            Arc::new(Mutex::new(self.initial_state.clone()));
        let load_count = self.load_count();
        
        Box::pin(async move {
            use futures::stream::StreamExt;
            
            loop {
                if let Some(payload) = inports.1.stream().next().await {
                    // Increment load count
                    {
                        let mut load = load_count.lock();
                        load.inc();
                    }
                    
                    let context = ActorContext::new(
                        payload,
                        outports.clone(),
                        state.clone(),
                        HashMap::new(),
                        load_count.clone(),
                    );
                    
                    match behavior(context).await {
                        Ok(result) =&gt; {
                            if !result.is_empty() {
                                let _ = outports.0.send(result);
                            }
                        },
                        Err(e) =&gt; {
                            eprintln!("Error in stateful actor behavior: {:?}", e);
                        }
                    }
                    
                    // Decrement load count
                    {
                        let mut load = load_count.lock();
                        load.dec();
                    }
                }
            }
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="multi-input-manual-actor"><a class="header" href="#multi-input-manual-actor">Multi-Input Manual Actor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MultiInputActor {
    inports: Port,
    outports: Port,
    await_all_inputs: bool,
    input_ports: Vec&lt;String&gt;,
    load: Arc&lt;Mutex&lt;ActorLoad&gt;&gt;,
}

impl MultiInputActor {
    pub fn new(input_ports: Vec&lt;String&gt;, await_all_inputs: bool) -&gt; Self {
        Self {
            inports: flume::bounded(100),
            outports: flume::bounded(50),
            await_all_inputs,
            input_ports,
            load: Arc::new(Mutex::new(ActorLoad::new(0))),
        }
    }
}

impl Actor for MultiInputActor {
    fn get_behavior(&amp;self) -&gt; ActorBehavior {
        Box::new(|context: ActorContext| {
            Box::pin(async move {
                let payload = context.get_payload();
                
                // Collect all available data
                let mut results = HashMap::new();
                let mut total_value = 0i64;
                let mut value_count = 0;
                
                for (port, message) in &amp;payload {
                    if let Message::Integer(value) = message {
                        total_value += value;
                        value_count += 1;
                        
                        results.insert(
                            format!("processed_{}", port), 
                            Message::Integer(value * 2)
                        );
                    }
                }
                
                if value_count &gt; 0 {
                    results.insert("sum".to_owned(), Message::Integer(total_value));
                    results.insert("average".to_owned(), Message::Integer(total_value / value_count));
                    results.insert("count".to_owned(), Message::Integer(value_count));
                }
                
                println!("MultiInput Actor: processed {} values, sum = {}", value_count, total_value);
                
                Ok(results)
            })
        })
    }
    
    fn get_inports(&amp;self) -&gt; Port {
        self.inports.clone()
    }
    
    fn get_outports(&amp;self) -&gt; Port {
        self.outports.clone()
    }
    
    fn load_count(&amp;self) -&gt; Arc&lt;Mutex&lt;ActorLoad&gt;&gt; {
        self.load.clone()
    }
    
    fn create_process(&amp;self) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static + Send&gt;&gt; {
        let inports = self.get_inports();
        let behavior = self.get_behavior();
        let outports = self.get_outports();
        let state: Arc&lt;Mutex&lt;dyn reflow_network::actor::ActorState&gt;&gt; = 
            Arc::new(Mutex::new(MemoryState::default()));
        let load_count = self.load_count();
        let await_all_inputs = self.await_all_inputs;
        let input_ports_count = self.input_ports.len();
        
        Box::pin(async move {
            use futures::stream::StreamExt;
            let mut all_inputs: HashMap&lt;String, Message&gt; = HashMap::new();
            
            loop {
                if let Some(packet) = inports.1.stream().next().await {
                    // Increment load count
                    {
                        let mut load = load_count.lock();
                        load.inc();
                    }
                    
                    if await_all_inputs {
                        // Accumulate inputs until we have all expected ports
                        all_inputs.extend(packet);
                        
                        if all_inputs.len() &gt;= input_ports_count {
                            let context = ActorContext::new(
                                all_inputs.clone(),
                                outports.clone(),
                                state.clone(),
                                HashMap::new(),
                                load_count.clone(),
                            );
                            
                            match behavior(context).await {
                                Ok(result) =&gt; {
                                    if !result.is_empty() {
                                        let _ = outports.0.send(result);
                                    }
                                },
                                Err(e) =&gt; {
                                    eprintln!("Error in multi-input actor behavior: {:?}", e);
                                }
                            }
                            
                            all_inputs.clear();
                        } else {
                            // Continue without decrementing load count
                            {
                                let mut load = load_count.lock();
                                load.dec();
                            }
                            continue;
                        }
                    } else {
                        // Process immediately
                        let context = ActorContext::new(
                            packet,
                            outports.clone(),
                            state.clone(),
                            HashMap::new(),
                            load_count.clone(),
                        );
                        
                        match behavior(context).await {
                            Ok(result) =&gt; {
                                if !result.is_empty() {
                                    let _ = outports.0.send(result);
                                }
                            },
                            Err(e) =&gt; {
                                eprintln!("Error in multi-input actor behavior: {:?}", e);
                            }
                        }
                    }
                    
                    // Decrement load count
                    {
                        let mut load = load_count.lock();
                        load.dec();
                    }
                }
            }
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="when-to-use-manual-implementation"><a class="header" href="#when-to-use-manual-implementation">When to Use Manual Implementation</a></h3>
<p><strong>Use manual implementation when:</strong></p>
<ol>
<li><strong>Complex State Requirements</strong>: You need custom state types or complex state initialization</li>
<li><strong>Custom Port Logic</strong>: You need dynamic port creation or complex routing logic</li>
<li><strong>Advanced Error Handling</strong>: You need sophisticated error recovery or circuit breaker patterns</li>
<li><strong>Performance Optimization</strong>: You need fine-grained control over message processing</li>
<li><strong>Integration Requirements</strong>: You need to integrate with external systems in specific ways</li>
</ol>
<p><strong>Example: Circuit Breaker Actor</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
enum CircuitState {
    Closed,   // Normal operation
    Open,     // Failing, rejecting requests
    HalfOpen, // Testing if service recovered
}

pub struct CircuitBreakerActor {
    inports: Port,
    outports: Port,
    failure_threshold: u32,
    timeout_ms: u64,
    load: Arc&lt;Mutex&lt;ActorLoad&gt;&gt;,
}

impl CircuitBreakerActor {
    pub fn new(failure_threshold: u32, timeout_ms: u64) -&gt; Self {
        Self {
            inports: flume::unbounded(),
            outports: flume::unbounded(),
            failure_threshold,
            timeout_ms,
            load: Arc::new(Mutex::new(ActorLoad::new(0))),
        }
    }
}

impl Actor for CircuitBreakerActor {
    fn get_behavior(&amp;self) -&gt; ActorBehavior {
        let failure_threshold = self.failure_threshold;
        let timeout_ms = self.timeout_ms;
        
        Box::new(move |context: ActorContext| {
            Box::pin(async move {
                let payload = context.get_payload();
                let state = context.get_state();
                
                let mut state_guard = state.lock();
                let memory_state = state_guard
                    .as_mut_any()
                    .downcast_mut::&lt;MemoryState&gt;()
                    .expect("Expected MemoryState");
                
                // Initialize circuit breaker state
                if !memory_state.contains_key("circuit_state") {
                    memory_state.insert("circuit_state", serde_json::json!("Closed"));
                    memory_state.insert("failure_count", serde_json::json!(0));
                    memory_state.insert("last_failure_time", serde_json::json!(0));
                }
                
                let circuit_state_str = memory_state.get("circuit_state")
                    .and_then(|v| v.as_str())
                    .unwrap_or("Closed");
                
                let failure_count = memory_state.get("failure_count")
                    .and_then(|v| v.as_u64())
                    .unwrap_or(0) as u32;
                
                let last_failure_time = memory_state.get("last_failure_time")
                    .and_then(|v| v.as_i64())
                    .unwrap_or(0);
                
                let circuit_state = match circuit_state_str {
                    "Open" =&gt; CircuitState::Open,
                    "HalfOpen" =&gt; CircuitState::HalfOpen,
                    _ =&gt; CircuitState::Closed,
                };
                
                let now = chrono::Utc::now().timestamp_millis();
                
                match circuit_state {
                    CircuitState::Open =&gt; {
                        // Check if timeout has passed
                        if now - last_failure_time &gt; timeout_ms as i64 {
                            memory_state.insert("circuit_state", serde_json::json!("HalfOpen"));
                            println!("Circuit breaker: Transitioning to HalfOpen");
                        } else {
                            return Ok([
                                ("rejected".to_owned(), 
                                 Message::Error("Circuit breaker is OPEN".to_string()))
                            ].into());
                        }
                    },
                    CircuitState::HalfOpen =&gt; {
                        // Process one request to test
                    },
                    CircuitState::Closed =&gt; {
                        // Normal operation
                    }
                }
                
                // Simulate processing the request
                if let Some(request) = payload.get("request") {
                    // Simulate success/failure (in real implementation, you'd call actual service)
                    let success = payload.get("simulate_success")
                        .and_then(|v| if let Message::Boolean(b) = v { Some(*b) } else { None })
                        .unwrap_or(true);
                    
                    if success {
                        // Success - reset failure count if in HalfOpen
                        if matches!(circuit_state, CircuitState::HalfOpen) {
                            memory_state.insert("circuit_state", serde_json::json!("Closed"));
                            memory_state.insert("failure_count", serde_json::json!(0));
                            println!("Circuit breaker: Transitioning to Closed");
                        }
                        
                        Ok([
                            ("success".to_owned(), Message::String("Request processed".to_string()))
                        ].into())
                    } else {
                        // Failure
                        let new_failure_count = failure_count + 1;
                        memory_state.insert("failure_count", serde_json::json!(new_failure_count));
                        memory_state.insert("last_failure_time", serde_json::json!(now));
                        
                        if new_failure_count &gt;= failure_threshold {
                            memory_state.insert("circuit_state", serde_json::json!("Open"));
                            println!("Circuit breaker: Transitioning to Open");
                        }
                        
                        Ok([
                            ("failure".to_owned(), 
                             Message::Error(format!("Request failed (failures: {})", new_failure_count)))
                        ].into())
                    }
                } else {
                    Err(anyhow::anyhow!("Missing request"))
                }
            })
        })
    }
    
    fn get_inports(&amp;self) -&gt; Port { self.inports.clone() }
    fn get_outports(&amp;self) -&gt; Port { self.outports.clone() }
    fn load_count(&amp;self) -&gt; Arc&lt;Mutex&lt;ActorLoad&gt;&gt; { self.load.clone() }
    
    fn create_process(&amp;self) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + 'static + Send&gt;&gt; {
        let inports = self.get_inports();
        let behavior = self.get_behavior();
        let outports = self.get_outports();
        let state: Arc&lt;Mutex&lt;dyn reflow_network::actor::ActorState&gt;&gt; = 
            Arc::new(Mutex::new(MemoryState::default()));
        let load_count = self.load_count();
        
        Box::pin(async move {
            use futures::stream::StreamExt;
            
            loop {
                if let Some(payload) = inports.1.stream().next().await {
                    {
                        let mut load = load_count.lock();
                        load.inc();
                    }
                    
                    let context = ActorContext::new(
                        payload,
                        outports.clone(),
                        state.clone(),
                        HashMap::new(),
                        load_count.clone(),
                    );
                    
                    match behavior(context).await {
                        Ok(result) =&gt; {
                            if !result.is_empty() {
                                let _ = outports.0.send(result);
                            }
                        },
                        Err(e) =&gt; {
                            eprintln!("Error in circuit breaker: {:?}", e);
                        }
                    }
                    
                    {
                        let mut load = load_count.lock();
                        load.dec();
                    }
                }
            }
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-manual-actors"><a class="header" href="#testing-manual-actors">Testing Manual Actors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod manual_actor_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_manual_actor() {
        let actor = ManualActor::new("TestActor".to_string());
        let behavior = actor.get_behavior();
        
        let payload = HashMap::from([
            ("input".to_string(), Message::String("test".to_string()))
        ]);
        
        let (tx, _rx) = flume::unbounded();
        let state: Arc&lt;Mutex&lt;dyn reflow_network::actor::ActorState&gt;&gt; = 
            Arc::new(Mutex::new(MemoryState::default()));
        
        let context = ActorContext::new(
            payload,
            (tx, _rx),
            state,
            HashMap::new(),
            Arc::new(Mutex::new(ActorLoad::new(0))),
        );
        
        let result = behavior(context).await.unwrap();
        
        assert!(result.contains_key("output"));
        if let Some(Message::String(output)) = result.get("output") {
            assert!(output.contains("TestActor"));
            assert!(output.contains("test"));
        }
    }
    
    #[tokio::test]
    async fn test_stateful_manual_actor() {
        let initial_state = CustomState {
            counter: 0,
            last_message: String::new(),
            timestamps: Vec::new(),
        };
        
        let actor = StatefulManualActor::new(initial_state);
        let behavior = actor.get_behavior();
        
        let payload = HashMap::from([
            ("message".to_string(), Message::String("hello".to_string()))
        ]);
        
        let (tx, _rx) = flume::unbounded();
        let state: Arc&lt;Mutex&lt;dyn reflow_network::actor::ActorState&gt;&gt; = 
            Arc::new(Mutex::new(CustomState::default()));
        
        let context = ActorContext::new(
            payload,
            (tx, _rx),
            state,
            HashMap::new(),
            Arc::new(Mutex::new(ActorLoad::new(0))),
        );
        
        let result = behavior(context).await.unwrap();
        
        assert_eq!(result.get("counter"), Some(&amp;Message::Integer(1)));
        assert!(result.contains_key("response"));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="choosing-between-macro-and-manual-implementation"><a class="header" href="#choosing-between-macro-and-manual-implementation">Choosing Between Macro and Manual Implementation</a></h2>
<h3 id="use-actor-macro-when"><a class="header" href="#use-actor-macro-when">Use Actor Macro When:</a></h3>
<ul>
<li>Simple, stateless processing</li>
<li>Standard input/output patterns</li>
<li>Rapid prototyping</li>
<li>Most common use cases</li>
</ul>
<h3 id="use-manual-implementation-when"><a class="header" href="#use-manual-implementation-when">Use Manual Implementation When:</a></h3>
<ul>
<li>Complex state management</li>
<li>Custom error handling strategies</li>
<li>Performance-critical applications</li>
<li>Integration with external systems</li>
<li>Advanced patterns (circuit breakers, rate limiting, etc.)</li>
</ul>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li><strong>State Management</strong>: <a href="api/actors/../state/advanced-patterns.html">Advanced State Patterns</a></li>
<li><strong>Network Integration</strong>: <a href="api/actors/../network/workflows.html">Building Workflows</a></li>
<li><strong>Performance</strong>: <a href="api/actors/../performance/optimization.html">Actor Optimization</a></li>
<li><strong>Examples</strong>: <a href="api/actors/../../examples/README.html">Real-World Examples</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-and-managing-graphs"><a class="header" href="#creating-and-managing-graphs">Creating and Managing Graphs</a></h1>
<p>This guide covers the core APIs for creating, modifying, and managing Reflow graphs.</p>
<h2 id="graph-creation"><a class="header" href="#graph-creation">Graph Creation</a></h2>
<h3 id="basic-graph-creation"><a class="header" href="#basic-graph-creation">Basic Graph Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{Graph, PortType};
use std::collections::HashMap;
use serde_json::json;

// Create a new graph
let mut graph = Graph::new("MyWorkflow", false, None);

// Create with case sensitivity enabled
let mut case_sensitive_graph = Graph::new("CaseSensitive", true, None);

// Create with initial properties
let properties = HashMap::from([
    ("description".to_string(), json!("Data processing workflow")),
    ("version".to_string(), json!("1.0.0")),
    ("author".to_string(), json!("John Doe"))
]);
let mut graph_with_props = Graph::new("WorkflowV1", false, Some(properties));
<span class="boring">}</span></code></pre></pre>
<h3 id="graph-with-history-tracking"><a class="header" href="#graph-with-history-tracking">Graph with History Tracking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create graph with unlimited history
let (mut graph, mut history) = Graph::with_history();

// Create graph with limited history (recommended for production)
let (mut graph, mut history) = Graph::with_history_and_limit(100);
<span class="boring">}</span></code></pre></pre>
<h2 id="node-management-1"><a class="header" href="#node-management-1">Node Management</a></h2>
<h3 id="adding-nodes"><a class="header" href="#adding-nodes">Adding Nodes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic node addition
graph.add_node("data_source", "FileReader", None);

// Node with position metadata
let metadata = HashMap::from([
    ("x".to_string(), json!(100)),
    ("y".to_string(), json!(200))
]);
graph.add_node("processor", "DataProcessor", Some(metadata));

// Node with comprehensive metadata
let rich_metadata = HashMap::from([
    ("x".to_string(), json!(300)),
    ("y".to_string(), json!(150)),
    ("label".to_string(), json!("CSV Parser")),
    ("color".to_string(), json!("#3498db")),
    ("estimated_time".to_string(), json!(2.5)),
    ("resources".to_string(), json!({
        "memory": 128,
        "cpu": 0.5
    })),
    ("configuration".to_string(), json!({
        "delimiter": ",",
        "has_header": true
    }))
]);
graph.add_node("csv_parser", "CSVParser", Some(rich_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="node-retrieval"><a class="header" href="#node-retrieval">Node Retrieval</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get node reference
if let Some(node) = graph.get_node("processor") {
    println!("Node component: {}", node.component);
    if let Some(metadata) = &amp;node.metadata {
        println!("Node metadata: {:?}", metadata);
    }
}

// Get mutable node reference
if let Some(node) = graph.get_node_mut("processor") {
    // Modify node directly (not recommended - use set_node_metadata instead)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="updating-node-metadata"><a class="header" href="#updating-node-metadata">Updating Node Metadata</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update metadata (merges with existing)
let updates = HashMap::from([
    ("color".to_string(), json!("#e74c3c")),
    ("priority".to_string(), json!("high"))
]);
graph.set_node_metadata("processor", updates);

// Clear specific metadata field by setting to null
let clear_color = HashMap::from([
    ("color".to_string(), json!(null))
]);
graph.set_node_metadata("processor", clear_color);
<span class="boring">}</span></code></pre></pre>
<h3 id="node-removal"><a class="header" href="#node-removal">Node Removal</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove node (automatically removes all connections)
graph.remove_node("old_processor");
<span class="boring">}</span></code></pre></pre>
<h3 id="node-renaming"><a class="header" href="#node-renaming">Node Renaming</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rename node (updates all references)
graph.rename_node("old_name", "new_name");
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-management-1"><a class="header" href="#connection-management-1">Connection Management</a></h2>
<h3 id="creating-connections"><a class="header" href="#creating-connections">Creating Connections</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic connection
graph.add_connection("source", "output", "processor", "input", None);

// Connection with metadata
let conn_metadata = HashMap::from([
    ("weight".to_string(), json!(0.8)),
    ("priority".to_string(), json!("high")),
    ("buffer_size".to_string(), json!(1024))
]);
graph.add_connection("processor", "output", "sink", "input", Some(conn_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-queries"><a class="header" href="#connection-queries">Connection Queries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get specific connection
if let Some(connection) = graph.get_connection("source", "output", "processor", "input") {
    println!("Connection metadata: {:?}", connection.metadata);
}

// Get all connections for a node
let incoming = graph.get_incoming_connections("processor");
for (source_node, source_port, connection) in incoming {
    println!("Input from {}:{}", source_node, source_port);
}

let outgoing = graph.get_outgoing_connections("processor");
for (target_node, target_port, connection) in outgoing {
    println!("Output to {}:{}", target_node, target_port);
}

// Get connections for specific port
let port_incoming = graph.get_incoming_connections_for_port("processor", "input");
let port_outgoing = graph.get_outgoing_connections_for_port("processor", "output");
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-analysis"><a class="header" href="#connection-analysis">Connection Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if nodes are connected
if graph.are_nodes_connected("source", "processor") {
    println!("Nodes are connected");
}

// Check specific port connections
if graph.are_ports_connected("source", "output", "processor", "input") {
    println!("Ports are connected");
}

// Get connection degrees
let (in_degree, out_degree) = graph.get_connection_degree("processor");
println!("Node has {} inputs and {} outputs", in_degree, out_degree);

// Get port-specific degrees
let (port_in, port_out) = graph.get_port_connection_degree("processor", "data");
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-updates"><a class="header" href="#connection-updates">Connection Updates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update connection metadata
let new_metadata = HashMap::from([
    ("bandwidth".to_string(), json!("high")),
    ("encrypted".to_string(), json!(true))
]);
graph.set_connection_metadata("source", "output", "processor", "input", new_metadata);
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-removal"><a class="header" href="#connection-removal">Connection Removal</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove specific connection
graph.remove_connection("source", "output", "processor", "input");

// Remove all connections for a node (called automatically when removing node)
graph.remove_node_connections("isolated_node");
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-ports-inportsoutports"><a class="header" href="#graph-ports-inportsoutports">Graph Ports (Inports/Outports)</a></h2>
<p>Graph ports expose internal node ports as external interfaces, making subgraphs reusable.</p>
<h3 id="adding-input-ports"><a class="header" href="#adding-input-ports">Adding Input Ports</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic inport
graph.add_inport("data_input", "processor", "input", PortType::Any, None);

// Inport with metadata
let port_metadata = HashMap::from([
    ("description".to_string(), json!("Main data input stream")),
    ("required".to_string(), json!(true)),
    ("default_value".to_string(), json!(null))
]);
graph.add_inport("config", "processor", "config", PortType::Object("Config".to_string()), Some(port_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-output-ports"><a class="header" href="#adding-output-ports">Adding Output Ports</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic outport
graph.add_outport("processed_data", "processor", "output", PortType::Object("ProcessedData".to_string()), None);

// Outport with metadata
let out_metadata = HashMap::from([
    ("description".to_string(), json!("Processed data stream")),
    ("format".to_string(), json!("json"))
]);
graph.add_outport("results", "processor", "result", PortType::Array(Box::new(PortType::Object("Result".to_string()))), Some(out_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="port-management"><a class="header" href="#port-management">Port Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update port metadata
let port_updates = HashMap::from([
    ("required".to_string(), json!(false)),
    ("deprecated".to_string(), json!(true))
]);
graph.set_inport_metadata("data_input", port_updates);
graph.set_outport_metadata("results", port_updates);

// Rename ports
graph.rename_inport("old_input", "new_input");
graph.rename_outport("old_output", "new_output");

// Remove ports
graph.remove_inport("unused_input");
graph.remove_outport("unused_output");
<span class="boring">}</span></code></pre></pre>
<h2 id="initial-information-packets-iips-1"><a class="header" href="#initial-information-packets-iips-1">Initial Information Packets (IIPs)</a></h2>
<p>IIPs provide static data to nodes at startup.</p>
<h3 id="adding-iips"><a class="header" href="#adding-iips">Adding IIPs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Basic IIP
graph.add_initial(
    json!("config.yaml"),
    "file_reader",
    "filename",
    None
);

// IIP with metadata
let iip_metadata = HashMap::from([
    ("source".to_string(), json!("configuration")),
    ("priority".to_string(), json!("high"))
]);
graph.add_initial(
    json!({"host": "localhost", "port": 8080}),
    "server",
    "config",
    Some(iip_metadata)
);

// IIP with array index
graph.add_initial_index(
    json!("file1.txt"),
    "multi_reader",
    "files",
    0,
    None
);
<span class="boring">}</span></code></pre></pre>
<h3 id="graph-level-iips"><a class="header" href="#graph-level-iips">Graph-level IIPs</a></h3>
<p>When using graph ports, you can add IIPs at the graph level:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add IIP to graph inport
graph.add_graph_initial(
    json!({"mode": "production"}),
    "config_input",  // Graph inport name
    None
);

// Add indexed IIP to graph inport
graph.add_graph_initial_index(
    json!("primary.db"),
    "database_files",  // Graph inport name
    0,
    None
);
<span class="boring">}</span></code></pre></pre>
<h3 id="removing-iips"><a class="header" href="#removing-iips">Removing IIPs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove node-level IIP
graph.remove_initial("file_reader", "filename");

// Remove graph-level IIP
graph.remove_graph_initial("config_input");
<span class="boring">}</span></code></pre></pre>
<h2 id="node-groups-1"><a class="header" href="#node-groups-1">Node Groups</a></h2>
<p>Groups provide logical organization of related nodes.</p>
<h3 id="creating-groups"><a class="header" href="#creating-groups">Creating Groups</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create basic group
graph.add_group("data_processing", vec!["parser".to_string(), "validator".to_string(), "transformer".to_string()], None);

// Group with metadata
let group_metadata = HashMap::from([
    ("color".to_string(), json!("#2ecc71")),
    ("description".to_string(), json!("Data processing pipeline")),
    ("collapsed".to_string(), json!(false))
]);
graph.add_group("preprocessing", vec!["cleaner".to_string(), "normalizer".to_string()], Some(group_metadata));
<span class="boring">}</span></code></pre></pre>
<h3 id="managing-group-membership"><a class="header" href="#managing-group-membership">Managing Group Membership</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add node to existing group
graph.add_to_group("data_processing", "formatter");

// Remove node from group
graph.remove_from_group("data_processing", "formatter");
<span class="boring">}</span></code></pre></pre>
<h3 id="group-metadata"><a class="header" href="#group-metadata">Group Metadata</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update group metadata
let group_updates = HashMap::from([
    ("collapsed".to_string(), json!(true)),
    ("priority".to_string(), json!("high"))
]);
graph.set_group_metadata("data_processing", group_updates);
<span class="boring">}</span></code></pre></pre>
<h3 id="removing-groups"><a class="header" href="#removing-groups">Removing Groups</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove entire group (nodes remain, just ungrouped)
graph.remove_group("old_group");
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-properties"><a class="header" href="#graph-properties">Graph Properties</a></h2>
<h3 id="setting-properties"><a class="header" href="#setting-properties">Setting Properties</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Set multiple properties
let properties = HashMap::from([
    ("name".to_string(), json!("Updated Workflow")),
    ("version".to_string(), json!("2.0.0")),
    ("description".to_string(), json!("Enhanced data processing")),
    ("tags".to_string(), json!(["data", "processing", "etl"]))
]);
graph.set_properties(properties);
<span class="boring">}</span></code></pre></pre>
<h3 id="getting-properties"><a class="header" href="#getting-properties">Getting Properties</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Properties are accessible via graph.properties field
if let Some(name) = graph.properties.get("name") {
    println!("Graph name: {}", name);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h2>
<h3 id="subscribing-to-events"><a class="header" href="#subscribing-to-events">Subscribing to Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::GraphEvents;

// Get event receiver
let event_receiver = graph.event_channel.1.clone();

// Handle events in a loop
std::thread::spawn(move || {
    while let Ok(event) = event_receiver.recv() {
        match event {
            GraphEvents::AddNode(data) =&gt; {
                println!("Node added: {:?}", data);
            }
            GraphEvents::RemoveNode(data) =&gt; {
                println!("Node removed: {:?}", data);
            }
            GraphEvents::AddConnection(data) =&gt; {
                println!("Connection added: {:?}", data);
            }
            GraphEvents::RemoveConnection(data) =&gt; {
                println!("Connection removed: {:?}", data);
            }
            GraphEvents::ChangeNode(data) =&gt; {
                println!("Node changed: {:?}", data);
            }
            // ... handle other events
            _ =&gt; {}
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h3 id="event-types-reference"><a class="header" href="#event-types-reference">Event Types Reference</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Event</th><th>Triggered When</th><th>Data</th></tr></thead><tbody>
<tr><td><code>AddNode</code></td><td>Node is added</td><td>Node data</td></tr>
<tr><td><code>RemoveNode</code></td><td>Node is removed</td><td>Node data</td></tr>
<tr><td><code>RenameNode</code></td><td>Node is renamed</td><td><code>{old, new}</code></td></tr>
<tr><td><code>ChangeNode</code></td><td>Node metadata changes</td><td><code>{node, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>AddConnection</code></td><td>Connection is added</td><td>Connection data</td></tr>
<tr><td><code>RemoveConnection</code></td><td>Connection is removed</td><td>Connection data</td></tr>
<tr><td><code>ChangeConnection</code></td><td>Connection metadata changes</td><td><code>{connection, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>AddInitial</code></td><td>IIP is added</td><td>IIP data</td></tr>
<tr><td><code>RemoveInitial</code></td><td>IIP is removed</td><td>IIP data</td></tr>
<tr><td><code>AddGroup</code></td><td>Group is created</td><td>Group data</td></tr>
<tr><td><code>RemoveGroup</code></td><td>Group is removed</td><td>Group data</td></tr>
<tr><td><code>RenameGroup</code></td><td>Group is renamed</td><td><code>{old, new}</code></td></tr>
<tr><td><code>ChangeGroup</code></td><td>Group metadata changes</td><td><code>{group, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>AddInport</code></td><td>Inport is added</td><td><code>{id, port}</code></td></tr>
<tr><td><code>RemoveInport</code></td><td>Inport is removed</td><td><code>{id, port}</code></td></tr>
<tr><td><code>RenameInport</code></td><td>Inport is renamed</td><td><code>{old, new}</code></td></tr>
<tr><td><code>ChangeInport</code></td><td>Inport metadata changes</td><td><code>{name, port, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>AddOutport</code></td><td>Outport is added</td><td><code>{id, port}</code></td></tr>
<tr><td><code>RemoveOutport</code></td><td>Outport is removed</td><td><code>{id, port}</code></td></tr>
<tr><td><code>RenameOutport</code></td><td>Outport is renamed</td><td><code>{old, new}</code></td></tr>
<tr><td><code>ChangeOutport</code></td><td>Outport metadata changes</td><td><code>{name, port, old_metadata, new_metadata}</code></td></tr>
<tr><td><code>ChangeProperties</code></td><td>Graph properties change</td><td><code>{new, before}</code></td></tr>
</tbody></table>
</div>
<h2 id="serialization-and-loading"><a class="header" href="#serialization-and-loading">Serialization and Loading</a></h2>
<h3 id="exporting-graphs"><a class="header" href="#exporting-graphs">Exporting Graphs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Export to GraphExport format
let export = graph.export();

// Serialize to JSON
let json_string = serde_json::to_string_pretty(&amp;export)?;
std::fs::write("workflow.json", json_string)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="loading-graphs"><a class="header" href="#loading-graphs">Loading Graphs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load from JSON
let json_content = std::fs::read_to_string("workflow.json")?;
let export: GraphExport = serde_json::from_str(&amp;json_content)?;

// Create graph from export
let metadata = HashMap::from([
    ("loaded_at".to_string(), json!(chrono::Utc::now().to_rfc3339()))
]);
let loaded_graph = Graph::load(export, Some(metadata));
<span class="boring">}</span></code></pre></pre>
<h2 id="webassembly-api"><a class="header" href="#webassembly-api">WebAssembly API</a></h2>
<p>When using the graph system in a browser via WebAssembly:</p>
<h3 id="javascripttypescript-usage"><a class="header" href="#javascripttypescript-usage">JavaScript/TypeScript Usage</a></h3>
<pre><code class="language-javascript">import { Graph, PortType } from 'reflow-network';

// Create graph
const graph = new Graph("WebWorkflow", false, {
    description: "Browser-based workflow"
});

// Add nodes
graph.addNode("input", "InputNode", { x: 0, y: 0 });
graph.addNode("output", "OutputNode", { x: 200, y: 0 });

// Add connections
graph.addConnection("input", "out", "output", "in", {});

// Subscribe to events
graph.subscribe((event) =&gt; {
    console.log("Graph event:", event);
    // Update UI based on event
    updateUI(event);
});

// Export for persistence
const exported = graph.toJSON();
localStorage.setItem('workflow', JSON.stringify(exported));

// Load saved workflow
const saved = JSON.parse(localStorage.getItem('workflow'));
const restoredGraph = Graph.load(saved, {});
</code></pre>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<h3 id="common-error-scenarios"><a class="header" href="#common-error-scenarios">Common Error Scenarios</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::GraphError;

// Handle node operations
match graph.add_node("duplicate", "TestNode", None) {
    Ok(_) =&gt; println!("Node added successfully"),
    Err(GraphError::DuplicateNode(id)) =&gt; println!("Node {} already exists", id),
    Err(e) =&gt; println!("Error: {}", e),
}

// Handle traversal errors
match graph.traverse_depth_first("nonexistent", |node| {
    println!("Visiting: {}", node.id);
}) {
    Ok(_) =&gt; println!("Traversal completed"),
    Err(GraphError::NodeNotFound(id)) =&gt; println!("Start node {} not found", id),
    Err(e) =&gt; println!("Traversal error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-types"><a class="header" href="#error-types">Error Types</a></h3>
<ul>
<li><code>NodeNotFound(String)</code> - Referenced node doesn't exist</li>
<li><code>DuplicateNode(String)</code> - Node with same ID already exists</li>
<li><code>InvalidConnection { from: String, to: String }</code> - Connection cannot be created</li>
<li><code>CycleDetected</code> - Operation would create a cycle (if validation enabled)</li>
<li><code>InvalidOperation(String)</code> - Generic operation error</li>
</ul>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="performance-tips-1"><a class="header" href="#performance-tips-1">Performance Tips</a></h3>
<ol>
<li>
<p><strong>Batch Operations</strong>: Group related changes to minimize events</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of individual operations, batch them
graph.add_node("n1", "Node1", None);
graph.add_node("n2", "Node2", None);
graph.add_connection("n1", "out", "n2", "in", None);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Use Appropriate Data Structures</strong>: Store frequently accessed metadata efficiently</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: structured metadata
let metadata = HashMap::from([
    ("config".to_string(), json!({
        "retries": 3,
        "timeout": 30
    }))
]);

// Avoid: flat key-value for complex data
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Validate Incrementally</strong>: Use targeted validation instead of full graph validation</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check specific aspects instead of full validation
if let Some(cycle) = graph.detect_cycles() {
    // Handle cycle
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="memory-management-3"><a class="header" href="#memory-management-3">Memory Management</a></h3>
<ol>
<li>
<p><strong>Limit History</strong>: Use bounded history for production systems</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (graph, history) = Graph::with_history_and_limit(50);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Clean Up Events</strong>: Ensure event listeners are properly disposed</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Store receiver handle to drop when done
let receiver = graph.event_channel.1.clone();
// ... use receiver
drop(receiver); // Clean up
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Efficient Metadata</strong>: Avoid storing large objects in metadata</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: reference to external data
let metadata = HashMap::from([
    ("data_ref".to_string(), json!("storage://large-dataset-id"))
]);

// Avoid: embedding large data
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<ul>
<li><a href="api/graph/analysis.html">Graph Analysis</a> - Validation and performance analysis</li>
<li><a href="api/graph/layout.html">Layout System</a> - Positioning and visualization</li>
<li><a href="api/graph/advanced.html">Advanced Features</a> - History, subgraphs, and optimization</li>
<li><a href="api/graph/../../tutorials/building-visual-editor.html">Building Visual Editors</a> - Complete tutorial</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-analysis-and-validation"><a class="header" href="#graph-analysis-and-validation">Graph Analysis and Validation</a></h1>
<p>Reflow's graph system provides extensive analysis capabilities for validation, performance optimization, and structural insights. This guide covers all analysis features available in the graph system.</p>
<h2 id="flow-validation"><a class="header" href="#flow-validation">Flow Validation</a></h2>
<h3 id="comprehensive-validation"><a class="header" href="#comprehensive-validation">Comprehensive Validation</a></h3>
<p>The <code>validate_flow</code> method performs a complete analysis of graph integrity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{FlowValidation, PortMismatch};

// Perform full validation
let validation = graph.validate_flow()?;

// Check for issues
if !validation.cycles.is_empty() {
    for cycle in validation.cycles {
        println!("Cycle detected: {:?}", cycle);
    }
}

if !validation.orphaned_nodes.is_empty() {
    println!("Orphaned nodes: {:?}", validation.orphaned_nodes);
}

if !validation.port_mismatches.is_empty() {
    for mismatch in validation.port_mismatches {
        println!("Port type mismatch: {}", mismatch);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="validation-results-structure"><a class="header" href="#validation-results-structure">Validation Results Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FlowValidation {
    pub cycles: Vec&lt;Vec&lt;String&gt;&gt;,           // Detected cycles
    pub orphaned_nodes: Vec&lt;String&gt;,        // Disconnected nodes
    pub port_mismatches: Vec&lt;PortMismatch&gt;, // Type incompatibilities
}

pub struct PortMismatch {
    pub from_node: String,
    pub from_port: String,
    pub from_type: PortType,
    pub to_node: String,
    pub to_port: String,
    pub to_type: PortType,
    pub reason: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cycle-detection-1"><a class="header" href="#cycle-detection-1">Cycle Detection</a></h2>
<h3 id="basic-cycle-detection"><a class="header" href="#basic-cycle-detection">Basic Cycle Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Detect first cycle found
if let Some(cycle) = graph.detect_cycles() {
    println!("Cycle path: {:?}", cycle);
    // cycle is Vec&lt;String&gt; showing the path of the cycle
}

// Check if specific node is in a cycle
if graph.is_node_in_cycle("suspicious_node") {
    println!("Node is part of a cycle");
}
<span class="boring">}</span></code></pre></pre>
<h3 id="comprehensive-cycle-analysis"><a class="header" href="#comprehensive-cycle-analysis">Comprehensive Cycle Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::CycleAnalysis;

let cycle_analysis = graph.analyze_cycles();

println!("Total cycles found: {}", cycle_analysis.total_cycles);
println!("Cycle lengths: {:?}", cycle_analysis.cycle_lengths);
println!("Nodes involved in cycles: {:?}", cycle_analysis.nodes_in_cycles);

if let Some(longest) = cycle_analysis.longest_cycle {
    println!("Longest cycle: {:?} (length: {})", longest, longest.len());
}

if let Some(shortest) = cycle_analysis.shortest_cycle {
    println!("Shortest cycle: {:?} (length: {})", shortest, shortest.len());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="all-cycles-detection"><a class="header" href="#all-cycles-detection">All Cycles Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find all cycles in the graph
let all_cycles = graph.detect_all_cycles();

for (i, cycle) in all_cycles.iter().enumerate() {
    println!("Cycle {}: {:?}", i + 1, cycle);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="orphaned-node-analysis"><a class="header" href="#orphaned-node-analysis">Orphaned Node Analysis</a></h2>
<h3 id="basic-orphaned-node-detection"><a class="header" href="#basic-orphaned-node-detection">Basic Orphaned Node Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find all orphaned nodes
let orphaned = graph.find_orphaned_nodes();

for node in orphaned {
    println!("Orphaned node: {}", node);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="detailed-orphaned-analysis"><a class="header" href="#detailed-orphaned-analysis">Detailed Orphaned Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::OrphanedNodeAnalysis;

let orphan_analysis = graph.analyze_orphaned_nodes();

println!("Total orphaned nodes: {}", orphan_analysis.total_orphaned);

println!("Completely isolated nodes:");
for node in orphan_analysis.completely_isolated {
    println!("  - {}", node);
}

println!("Unreachable nodes (have connections but no path from entry points):");
for node in orphan_analysis.unreachable {
    println!("  - {}", node);
}

println!("Disconnected groups:");
for (i, group) in orphan_analysis.disconnected_groups.iter().enumerate() {
    println!("  Group {}: {:?}", i + 1, group);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="port-type-validation"><a class="header" href="#port-type-validation">Port Type Validation</a></h2>
<h3 id="port-compatibility-checking"><a class="header" href="#port-compatibility-checking">Port Compatibility Checking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Validate all port types in the graph
let port_mismatches = graph.validate_port_types();

for mismatch in port_mismatches {
    println!("Port mismatch: {} -&gt; {}", 
        format!("{}:{}", mismatch.from_node, mismatch.from_port),
        format!("{}:{}", mismatch.to_node, mismatch.to_port)
    );
    println!("  Types: {:?} -&gt; {:?}", mismatch.from_type, mismatch.to_type);
    println!("  Reason: {}", mismatch.reason);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-type-compatibility"><a class="header" href="#custom-type-compatibility">Custom Type Compatibility</a></h3>
<p>The graph system includes built-in type compatibility rules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Built-in compatibility rules:
// Any â†” Any type (always compatible)
// Integer â†’ Float (automatic promotion)
// T â†’ Stream (streaming any type)
// T â†’ Option&lt;T&gt; (wrapping in option)
// Array&lt;T&gt; â†’ Array&lt;U&gt; (if T â†’ U)

// Example of compatible connections:
graph.add_connection("int_source", "out", "float_processor", "in", None);     // Integer â†’ Float âœ“
graph.add_connection("data_source", "out", "stream_processor", "in", None);   // Any â†’ Stream âœ“
graph.add_connection("value", "out", "optional_sink", "in", None);            // T â†’ Option&lt;T&gt; âœ“
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-analysis-1"><a class="header" href="#performance-analysis-1">Performance Analysis</a></h2>
<h3 id="parallelism-analysis"><a class="header" href="#parallelism-analysis">Parallelism Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{ParallelismAnalysis, PipelineStage};

let parallelism = graph.analyze_parallelism();

println!("Maximum parallelism: {}", parallelism.max_parallelism);

// Parallel branches that can execute simultaneously
println!("Parallel branches:");
for (i, branch) in parallelism.parallel_branches.iter().enumerate() {
    println!("  Branch {}: {:?}", i + 1, branch.nodes);
    println!("    Entry points: {:?}", branch.entry_points);
    println!("    Exit points: {:?}", branch.exit_points);
}

// Pipeline stages for sequential execution
println!("Pipeline stages:");
for stage in parallelism.pipeline_stages {
    println!("  Stage {}: {:?}", stage.level, stage.nodes);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bottleneck-detection"><a class="header" href="#bottleneck-detection">Bottleneck Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::Bottleneck;

let bottlenecks = graph.detect_bottlenecks();

for bottleneck in bottlenecks {
    match bottleneck {
        Bottleneck::HighDegree(node) =&gt; {
            let (in_deg, out_deg) = graph.get_connection_degree(&amp;node);
            println!("High-degree bottleneck: {} ({} in, {} out)", node, in_deg, out_deg);
        }
        Bottleneck::SequentialChain(chain) =&gt; {
            println!("Sequential chain (could be parallelized): {:?}", chain);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="high-degree-node-analysis"><a class="header" href="#high-degree-node-analysis">High-Degree Node Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find nodes with unusually high connection counts
let high_degree_nodes = graph.find_high_degree_nodes();

for node in high_degree_nodes {
    let (incoming, outgoing) = graph.get_connection_degree(&amp;node);
    let total_degree = incoming + outgoing;
    
    println!("High-degree node: {} (total degree: {})", node, total_degree);
    println!("  Incoming: {}, Outgoing: {}", incoming, outgoing);
    
    // Analyze connected nodes
    let connected = graph.get_connected_nodes(&amp;node);
    println!("  Connected to {} other nodes", connected.len());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sequential-chain-analysis"><a class="header" href="#sequential-chain-analysis">Sequential Chain Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find chains that could potentially be parallelized
let sequential_chains = graph.find_sequential_chains();

for (i, chain) in sequential_chains.iter().enumerate() {
    println!("Sequential chain {}: {:?}", i + 1, chain);
    println!("  Length: {} nodes", chain.len());
    
    // Analyze chain characteristics
    if chain.len() &gt;= 5 {
        println!("  âš ï¸  Long chain - consider breaking into parallel segments");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="data-flow-analysis"><a class="header" href="#data-flow-analysis">Data Flow Analysis</a></h2>
<h3 id="flow-path-tracing"><a class="header" href="#flow-path-tracing">Flow Path Tracing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{DataFlowPath, DataTransform};

// Trace data flow from a starting node
let flow_paths = graph.trace_data_flow("input_node")?;

for (i, path) in flow_paths.iter().enumerate() {
    println!("Flow path {}:", i + 1);
    println!("  Nodes: {:?}", path.nodes);
    
    println!("  Transformations:");
    for transform in &amp;path.transforms {
        println!("    {} -&gt; {} ({}: {} -&gt; {})", 
            transform.node, 
            transform.operation,
            transform.node,
            transform.input_type, 
            transform.output_type
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="execution-path-analysis"><a class="header" href="#execution-path-analysis">Execution Path Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::ExecutionPath;

// Find all possible execution paths
let execution_paths = graph.find_execution_paths();

for (i, path) in execution_paths.iter().enumerate() {
    println!("Execution path {}:", i + 1);
    println!("  Nodes: {:?}", path.nodes);
    println!("  Estimated time: {:.2}s", path.estimated_time);
    println!("  Resource requirements: {:?}", path.resource_requirements);
    
    // Check for parallel execution markers
    if path.resource_requirements.contains_key("parallel_branches") {
        let branches = path.resource_requirements["parallel_branches"];
        println!("  âš¡ Contains {} parallel branches", branches);
    }
    
    if path.resource_requirements.contains_key("contains_cycle") {
        println!("  âš ï¸  Path contains cycles");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-requirements-analysis"><a class="header" href="#resource-requirements-analysis">Resource Requirements Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Analyze resource requirements for the entire graph
let resource_analysis = graph.analyze_resource_requirements();

println!("Graph resource requirements:");
for (resource, requirement) in resource_analysis {
    match resource.as_str() {
        "memory" =&gt; println!("  Memory: {:.1} MB", requirement),
        "cpu" =&gt; println!("  CPU cores: {:.1}", requirement),
        "disk" =&gt; println!("  Disk space: {:.1} GB", requirement),
        "network" =&gt; println!("  Network bandwidth: {:.1} Mbps", requirement),
        _ =&gt; println!("  {}: {:.2}", resource, requirement),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="runtime-analysis"><a class="header" href="#runtime-analysis">Runtime Analysis</a></h2>
<h3 id="comprehensive-runtime-analysis"><a class="header" href="#comprehensive-runtime-analysis">Comprehensive Runtime Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{EnhancedGraphAnalysis, OptimizationSuggestion};

let runtime_analysis = graph.analyze_for_runtime();

println!("=== Runtime Analysis ===");
println!("Estimated execution time: {:.2}s", runtime_analysis.estimated_execution_time);
println!("Resource requirements: {:?}", runtime_analysis.resource_requirements);

// Parallelism opportunities
println!("\nParallelism analysis:");
println!("  Max parallelism: {}", runtime_analysis.parallelism.max_parallelism);
println!("  Parallel branches: {}", runtime_analysis.parallelism.parallel_branches.len());
println!("  Pipeline stages: {}", runtime_analysis.parallelism.pipeline_stages.len());

// Optimization suggestions
println!("\nOptimization suggestions:");
for suggestion in runtime_analysis.optimization_suggestions {
    match suggestion {
        OptimizationSuggestion::ParallelizableChain { nodes } =&gt; {
            println!("  âš¡ Parallelize chain: {:?}", nodes);
        }
        OptimizationSuggestion::RedundantNode { node, reason } =&gt; {
            println!("  ğŸ—‘ï¸  Remove redundant node '{}': {}", node, reason);
        }
        OptimizationSuggestion::ResourceBottleneck { resource, severity } =&gt; {
            println!("  âš ï¸  Resource bottleneck in '{}': {:.1}% usage", resource, severity * 100.0);
        }
        OptimizationSuggestion::DataTypeOptimization { from, to, suggestion } =&gt; {
            println!("  ğŸ”§ Optimize types {} â†’ {}: {}", from, to, suggestion);
        }
    }
}

// Performance bottlenecks
println!("\nPerformance bottlenecks:");
for bottleneck in runtime_analysis.performance_bottlenecks {
    match bottleneck {
        Bottleneck::HighDegree(node) =&gt; {
            println!("  ğŸ”¥ High-degree node: {}", node);
        }
        Bottleneck::SequentialChain(chain) =&gt; {
            println!("  ğŸŒ Sequential bottleneck: {:?}", chain);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="subgraph-analysis-1"><a class="header" href="#subgraph-analysis-1">Subgraph Analysis</a></h2>
<h3 id="extracting-subgraphs"><a class="header" href="#extracting-subgraphs">Extracting Subgraphs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{Subgraph, SubgraphAnalysis};

// Get reachable subgraph from a node
if let Some(subgraph) = graph.get_reachable_subgraph("start_node") {
    println!("Subgraph from 'start_node':");
    println!("  Nodes: {:?}", subgraph.nodes);
    println!("  Entry points: {:?}", subgraph.entry_points);
    println!("  Exit points: {:?}", subgraph.exit_points);
    println!("  Internal connections: {}", subgraph.internal_connections.len());
    
    // Analyze subgraph characteristics
    let analysis = graph.analyze_subgraph(&amp;subgraph);
    println!("  Analysis:");
    println!("    Node count: {}", analysis.node_count);
    println!("    Connection count: {}", analysis.connection_count);
    println!("    Max depth: {}", analysis.max_depth);
    println!("    Is cyclic: {}", analysis.is_cyclic);
    println!("    Branching factor: {:.2}", analysis.branching_factor);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="independent-subgraph-detection"><a class="header" href="#independent-subgraph-detection">Independent Subgraph Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find all independent subgraphs
let subgraphs = graph.find_subgraphs();

println!("Found {} independent subgraphs:", subgraphs.len());
for (i, subgraph) in subgraphs.iter().enumerate() {
    println!("  Subgraph {}: {} nodes", i + 1, subgraph.nodes.len());
    
    let analysis = graph.analyze_subgraph(subgraph);
    if analysis.is_cyclic {
        println!("    âš ï¸  Contains cycles");
    }
    
    if subgraph.entry_points.len() &gt; 1 {
        println!("    âš¡ Multiple entry points - potential for parallel input");
    }
    
    if subgraph.exit_points.len() &gt; 1 {
        println!("    ğŸ“Š Multiple exit points - produces multiple outputs");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-traversal-analysis"><a class="header" href="#graph-traversal-analysis">Graph Traversal Analysis</a></h2>
<h3 id="traversal-with-analysis"><a class="header" href="#traversal-with-analysis">Traversal with Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashSet;

// Depth-first traversal with custom analysis
let mut visited_order = Vec::new();
let mut max_depth = 0;
let mut current_depth = 0;

graph.traverse_depth_first("start_node", |node| {
    visited_order.push(node.id.clone());
    current_depth += 1;
    max_depth = max_depth.max(current_depth);
    
    println!("Visiting {} at depth {}", node.id, current_depth);
    
    // Analyze node characteristics
    if let Some(metadata) = &amp;node.metadata {
        if let Some(estimated_time) = metadata.get("estimated_time") {
            println!("  Estimated processing time: {:?}", estimated_time);
        }
    }
})?;

println!("Traversal completed:");
println!("  Visit order: {:?}", visited_order);
println!("  Maximum depth: {}", max_depth);
<span class="boring">}</span></code></pre></pre>
<h3 id="breadth-first-layer-analysis"><a class="header" href="#breadth-first-layer-analysis">Breadth-First Layer Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Breadth-first traversal to analyze layers
let mut layers: HashMap&lt;usize, Vec&lt;String&gt;&gt; = HashMap::new();
let mut current_layer = 0;

graph.traverse_breadth_first("start_node", |node| {
    // In a real implementation, you'd track depth
    layers.entry(current_layer)
        .or_insert_with(Vec::new)
        .push(node.id.clone());
    
    println!("Layer {}: {}", current_layer, node.id);
})?;

// Analyze layer characteristics
for (layer, nodes) in layers {
    println!("Layer {} has {} nodes: {:?}", layer, nodes.len(), nodes);
    
    if nodes.len() &gt; 1 {
        println!("  âš¡ Layer {} can be parallelized", layer);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-analysis-functions"><a class="header" href="#custom-analysis-functions">Custom Analysis Functions</a></h2>
<h3 id="building-custom-analyzers"><a class="header" href="#building-custom-analyzers">Building Custom Analyzers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Custom analyzer for finding critical paths
fn find_critical_path(graph: &amp;Graph, start: &amp;str, end: &amp;str) -&gt; Option&lt;Vec&lt;String&gt;&gt; {
    let mut longest_path = Vec::new();
    let mut max_weight = 0.0;
    
    // Use path tracing to find all paths
    if let Ok(paths) = graph.trace_data_flow(start) {
        for path in paths {
            if path.nodes.last() == Some(&amp;end.to_string()) {
                // Calculate path weight based on estimated times
                let mut path_weight = 0.0;
                
                for node_id in &amp;path.nodes {
                    if let Some(node) = graph.get_node(node_id) {
                        if let Some(metadata) = &amp;node.metadata {
                            if let Some(time) = metadata.get("estimated_time") {
                                if let Some(t) = time.as_f64() {
                                    path_weight += t;
                                }
                            }
                        }
                    }
                }
                
                if path_weight &gt; max_weight {
                    max_weight = path_weight;
                    longest_path = path.nodes;
                }
            }
        }
    }
    
    if longest_path.is_empty() {
        None
    } else {
        Some(longest_path)
    }
}

// Usage
if let Some(critical_path) = find_critical_path(&amp;graph, "input", "output") {
    println!("Critical path: {:?}", critical_path);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-metrics-collection"><a class="header" href="#performance-metrics-collection">Performance Metrics Collection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;

// Benchmark graph operations
fn benchmark_graph_operations(graph: &amp;Graph) {
    let start = Instant::now();
    
    // Benchmark cycle detection
    let cycle_start = Instant::now();
    let _cycles = graph.detect_all_cycles();
    let cycle_time = cycle_start.elapsed();
    
    // Benchmark validation
    let validation_start = Instant::now();
    let _validation = graph.validate_flow();
    let validation_time = validation_start.elapsed();
    
    // Benchmark parallelism analysis
    let parallelism_start = Instant::now();
    let _parallelism = graph.analyze_parallelism();
    let parallelism_time = parallelism_start.elapsed();
    
    let total_time = start.elapsed();
    
    println!("=== Performance Metrics ===");
    println!("Graph size: {} nodes, {} connections", 
        graph.nodes.len(), 
        graph.connections.len()
    );
    println!("Cycle detection: {:?}", cycle_time);
    println!("Flow validation: {:?}", validation_time);
    println!("Parallelism analysis: {:?}", parallelism_time);
    println!("Total analysis time: {:?}", total_time);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="analysis-best-practices"><a class="header" href="#analysis-best-practices">Analysis Best Practices</a></h2>
<h3 id="incremental-analysis"><a class="header" href="#incremental-analysis">Incremental Analysis</a></h3>
<p>For large graphs, perform incremental analysis:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of full validation on every change
let full_validation = graph.validate_flow()?; // Expensive

// Use targeted analysis
if let Some(cycle) = graph.detect_cycles() {
    // Handle cycles specifically
}

// Check only specific node connections
let node_issues = graph.find_orphaned_nodes()
    .into_iter()
    .filter(|n| recently_modified_nodes.contains(n))
    .collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}</span></code></pre></pre>
<h3 id="caching-analysis-results"><a class="header" href="#caching-analysis-results">Caching Analysis Results</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;

struct CachedAnalyzer {
    graph: Graph,
    cached_validation: RefCell&lt;Option&lt;FlowValidation&gt;&gt;,
    validation_dirty: RefCell&lt;bool&gt;,
}

impl CachedAnalyzer {
    fn get_validation(&amp;self) -&gt; Result&lt;FlowValidation, GraphError&gt; {
        if *self.validation_dirty.borrow() {
            let validation = self.graph.validate_flow()?;
            *self.cached_validation.borrow_mut() = Some(validation.clone());
            *self.validation_dirty.borrow_mut() = false;
            Ok(validation)
        } else {
            Ok(self.cached_validation.borrow().clone().unwrap())
        }
    }
    
    fn invalidate_cache(&amp;self) {
        *self.validation_dirty.borrow_mut() = true;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="parallel-analysis"><a class="header" href="#parallel-analysis">Parallel Analysis</a></h3>
<p>For very large graphs, consider parallel analysis:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread;

// Analyze different aspects in parallel
let graph_clone = graph.clone();
let cycle_handle = thread::spawn(move || {
    graph_clone.detect_all_cycles()
});

let graph_clone2 = graph.clone();
let orphan_handle = thread::spawn(move || {
    graph_clone2.analyze_orphaned_nodes()
});

let graph_clone3 = graph.clone();
let parallelism_handle = thread::spawn(move || {
    graph_clone3.analyze_parallelism()
});

// Collect results
let cycles = cycle_handle.join().unwrap();
let orphan_analysis = orphan_handle.join().unwrap();
let parallelism_analysis = parallelism_handle.join().unwrap();

println!("Parallel analysis completed:");
println!("  Cycles: {}", cycles.len());
println!("  Orphaned: {}", orphan_analysis.total_orphaned);
println!("  Max parallelism: {}", parallelism_analysis.max_parallelism);
<span class="boring">}</span></code></pre></pre>
<h2 id="analysis-error-handling"><a class="header" href="#analysis-error-handling">Analysis Error Handling</a></h2>
<h3 id="robust-error-handling"><a class="header" href="#robust-error-handling">Robust Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::GraphError;

fn safe_analysis(graph: &amp;Graph) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Validate graph structure first
    match graph.validate_flow() {
        Ok(validation) =&gt; {
            if !validation.cycles.is_empty() {
                println!("âš ï¸  Cycles detected - some analyses may not be reliable");
            }
        }
        Err(e) =&gt; {
            eprintln!("Validation failed: {}", e);
            return Err(Box::new(e));
        }
    }
    
    // Perform safe traversal
    match graph.traverse_depth_first("start", |node| {
        println!("Processing: {}", node.id);
    }) {
        Ok(_) =&gt; println!("Traversal completed successfully"),
        Err(GraphError::NodeNotFound(node)) =&gt; {
            eprintln!("Start node '{}' not found", node);
        }
        Err(e) =&gt; {
            eprintln!("Traversal error: {}", e);
            return Err(Box::new(e));
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-visual-editors"><a class="header" href="#integration-with-visual-editors">Integration with Visual Editors</a></h2>
<h3 id="real-time-analysis-updates"><a class="header" href="#real-time-analysis-updates">Real-time Analysis Updates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Update UI based on analysis results
fn update_editor_with_analysis(graph: &amp;Graph, ui: &amp;mut GraphEditor) {
    // Highlight cycles
    if let Some(cycle) = graph.detect_cycles() {
        for node in cycle {
            ui.highlight_node(&amp;node, "error");
        }
    }
    
    // Show bottlenecks
    let bottlenecks = graph.detect_bottlenecks();
    for bottleneck in bottlenecks {
        match bottleneck {
            Bottleneck::HighDegree(node) =&gt; {
                ui.highlight_node(&amp;node, "bottleneck");
            }
            Bottleneck::SequentialChain(chain) =&gt; {
                ui.highlight_chain(&amp;chain, "optimization-opportunity");
            }
        }
    }
    
    // Show parallel opportunities
    let parallelism = graph.analyze_parallelism();
    for branch in parallelism.parallel_branches {
        ui.group_nodes(&amp;branch.nodes, "parallel-group");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li><a href="api/graph/layout.html">Layout System</a> - Positioning and visualization</li>
<li><a href="api/graph/advanced.html">Advanced Features</a> - History, subgraphs, and optimization</li>
<li><a href="api/graph/creating-graphs.html">Creating Graphs</a> - Basic graph operations</li>
<li><a href="api/graph/../../tutorials/building-visual-editor.html">Building Visual Editors</a> - Complete tutorial</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graph-layout-system"><a class="header" href="#graph-layout-system">Graph Layout System</a></h1>
<p>Reflow's layout system provides intelligent automatic positioning and manual positioning capabilities for graph nodes. The system supports multiple layout algorithms, custom positioning, and integration with visual editors.</p>
<h2 id="automatic-layout-1"><a class="header" href="#automatic-layout-1">Automatic Layout</a></h2>
<h3 id="basic-auto-layout"><a class="header" href="#basic-auto-layout">Basic Auto-Layout</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::Position;

// Calculate optimal positions using default algorithm
let positions = graph.calculate_layout();

for (node_id, position) in positions {
    println!("Node {}: x={:.1}, y={:.1}", node_id, position.x, position.y);
}

// Apply calculated layout to graph metadata
graph.auto_layout()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="layout-algorithms"><a class="header" href="#layout-algorithms">Layout Algorithms</a></h3>
<p>The system supports multiple layout algorithms optimized for different graph types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{LayoutAlgorithm, LayoutConfig};

// Hierarchical layout for DAGs (default)
let hierarchical_config = LayoutConfig {
    algorithm: LayoutAlgorithm::Hierarchical,
    node_spacing: 120.0,
    layer_spacing: 80.0,
    edge_spacing: 40.0,
    ..Default::default()
};

let positions = graph.calculate_layout_with_config(&amp;hierarchical_config);

// Force-directed layout for general graphs
let force_config = LayoutConfig {
    algorithm: LayoutAlgorithm::ForceDirected,
    iterations: 100,
    spring_strength: 0.5,
    repulsion_strength: 1000.0,
    ..Default::default()
};

let positions = graph.calculate_layout_with_config(&amp;force_config);

// Grid layout for structured workflows
let grid_config = LayoutConfig {
    algorithm: LayoutAlgorithm::Grid,
    grid_size: 150.0,
    columns: 5,
    align_to_grid: true,
    ..Default::default()
};

let positions = graph.calculate_layout_with_config(&amp;grid_config);
<span class="boring">}</span></code></pre></pre>
<h3 id="hierarchical-layout"><a class="header" href="#hierarchical-layout">Hierarchical Layout</a></h3>
<p>Best for directed acyclic graphs (DAGs) and workflow diagrams:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::HierarchicalConfig;

let hierarchical = HierarchicalConfig {
    direction: LayoutDirection::TopToBottom,
    layer_spacing: 100.0,
    node_spacing: 80.0,
    edge_routing: EdgeRouting::Orthogonal,
    minimize_crossings: true,
    balance_nodes: true,
};

let positions = graph.hierarchical_layout(&amp;hierarchical);

// Apply with automatic layer detection
graph.auto_layout_hierarchical()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="force-directed-layout"><a class="header" href="#force-directed-layout">Force-Directed Layout</a></h3>
<p>Ideal for general graphs with cycles and complex interconnections:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::ForceDirectedConfig;

let force_config = ForceDirectedConfig {
    iterations: 150,
    cooling_factor: 0.95,
    initial_temperature: 100.0,
    spring_strength: 0.3,
    spring_length: 100.0,
    repulsion_strength: 800.0,
    gravity_strength: 0.1,
    node_charge: -30.0,
};

let positions = graph.force_directed_layout(&amp;force_config);
<span class="boring">}</span></code></pre></pre>
<h3 id="organic-layout"><a class="header" href="#organic-layout">Organic Layout</a></h3>
<p>Creates natural, flowing layouts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::OrganicConfig;

let organic_config = OrganicConfig {
    preferred_edge_length: 120.0,
    edge_length_cost_factor: 0.0001,
    node_distribution_cost_factor: 20000.0,
    edge_crossing_cost_factor: 6000.0,
    edge_distance_cost_factor: 15000.0,
    border_line_cost_factor: 100.0,
    max_iterations: 200,
};

let positions = graph.organic_layout(&amp;organic_config);
<span class="boring">}</span></code></pre></pre>
<h2 id="manual-positioning-1"><a class="header" href="#manual-positioning-1">Manual Positioning</a></h2>
<h3 id="setting-node-positions"><a class="header" href="#setting-node-positions">Setting Node Positions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::Position;

// Set specific position
graph.set_node_position("input_node", 0.0, 0.0)?;
graph.set_node_position("processor", 200.0, 100.0)?;
graph.set_node_position("output_node", 400.0, 0.0)?;

// Set position with custom anchor point
let position = Position {
    x: 150.0,
    y: 75.0,
    anchor: Some(Anchor { x: 0.5, y: 0.5 }), // Center anchor
};
graph.set_node_position_with_anchor("centered_node", position)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="position-metadata-structure"><a class="header" href="#position-metadata-structure">Position Metadata Structure</a></h3>
<p>Positions are stored in node metadata following this convention:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::json;
use std::collections::HashMap;

// Standard position metadata
let position_metadata = HashMap::from([
    ("x".to_string(), json!(100)),
    ("y".to_string(), json!(150)),
    ("width".to_string(), json!(120)),
    ("height".to_string(), json!(80)),
    ("anchor".to_string(), json!({
        "x": 0.5,  // Horizontal anchor (0.0 = left, 0.5 = center, 1.0 = right)
        "y": 0.5   // Vertical anchor (0.0 = top, 0.5 = middle, 1.0 = bottom)
    }))
]);

graph.set_node_metadata("positioned_node", position_metadata);
<span class="boring">}</span></code></pre></pre>
<h3 id="retrieving-positions"><a class="header" href="#retrieving-positions">Retrieving Positions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get position for a specific node
if let Some(position) = graph.get_node_position("processor") {
    println!("Node position: ({}, {})", position.x, position.y);
}

// Get all node positions
let all_positions = graph.get_all_positions();
for (node_id, position) in all_positions {
    println!("{}: ({:.1}, {:.1})", node_id, position.x, position.y);
}

// Get positions within a bounding box
let bbox = BoundingBox {
    min_x: 0.0,
    min_y: 0.0,
    max_x: 500.0,
    max_y: 300.0,
};
let nodes_in_area = graph.get_nodes_in_area(bbox);
<span class="boring">}</span></code></pre></pre>
<h2 id="layout-constraints"><a class="header" href="#layout-constraints">Layout Constraints</a></h2>
<h3 id="alignment-constraints"><a class="header" href="#alignment-constraints">Alignment Constraints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{AlignmentConstraint, ConstraintType};

// Horizontal alignment
let horizontal_alignment = AlignmentConstraint {
    nodes: vec!["node1".to_string(), "node2".to_string(), "node3".to_string()],
    constraint_type: ConstraintType::HorizontalAlignment,
    offset: 0.0,
};

// Vertical alignment
let vertical_alignment = AlignmentConstraint {
    nodes: vec!["input1".to_string(), "input2".to_string()],
    constraint_type: ConstraintType::VerticalAlignment,
    offset: 50.0, // 50 pixels apart
};

// Apply constraints during layout
let config = LayoutConfig {
    algorithm: LayoutAlgorithm::Hierarchical,
    constraints: vec![horizontal_alignment, vertical_alignment],
    ..Default::default()
};

graph.apply_layout_with_constraints(&amp;config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="distance-constraints"><a class="header" href="#distance-constraints">Distance Constraints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{DistanceConstraint, DistanceType};

// Minimum distance constraint
let min_distance = DistanceConstraint {
    from_node: "source".to_string(),
    to_node: "sink".to_string(),
    distance_type: DistanceType::Minimum,
    distance: 200.0,
};

// Maximum distance constraint
let max_distance = DistanceConstraint {
    from_node: "processor1".to_string(),
    to_node: "processor2".to_string(),
    distance_type: DistanceType::Maximum,
    distance: 300.0,
};

// Fixed distance constraint
let fixed_distance = DistanceConstraint {
    from_node: "controller".to_string(),
    to_node: "display".to_string(),
    distance_type: DistanceType::Fixed,
    distance: 150.0,
};
<span class="boring">}</span></code></pre></pre>
<h3 id="boundary-constraints"><a class="header" href="#boundary-constraints">Boundary Constraints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::BoundaryConstraint;

// Keep nodes within bounds
let boundary = BoundaryConstraint {
    min_x: 0.0,
    min_y: 0.0,
    max_x: 1000.0,
    max_y: 600.0,
    enforce_during_layout: true,
};

// Apply boundary constraint
graph.set_layout_boundary(boundary);
<span class="boring">}</span></code></pre></pre>
<h2 id="layout-optimization"><a class="header" href="#layout-optimization">Layout Optimization</a></h2>
<h3 id="minimize-edge-crossings"><a class="header" href="#minimize-edge-crossings">Minimize Edge Crossings</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Optimize layout to reduce edge crossings
let optimized_positions = graph.minimize_edge_crossings()?;

// Apply optimization with maximum iterations
let crossings_config = EdgeCrossingConfig {
    max_iterations: 50,
    improvement_threshold: 0.01,
    use_barycenter_heuristic: true,
};

graph.optimize_edge_crossings(&amp;crossings_config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="edge-bundling"><a class="header" href="#edge-bundling">Edge Bundling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::EdgeBundling;

// Enable edge bundling for cleaner layouts
let bundling_config = EdgeBundling {
    enable: true,
    strength: 0.8,
    step_size: 0.1,
    iterations: 60,
    min_distance: 10.0,
};

graph.apply_edge_bundling(&amp;bundling_config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="compact-layout"><a class="header" href="#compact-layout">Compact Layout</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create compact layout by minimizing overall area
let compact_config = CompactLayoutConfig {
    preserve_aspect_ratio: true,
    min_node_spacing: 20.0,
    pack_components: true,
};

graph.create_compact_layout(&amp;compact_config)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="layer-based-layout"><a class="header" href="#layer-based-layout">Layer-Based Layout</a></h2>
<h3 id="automatic-layer-detection"><a class="header" href="#automatic-layer-detection">Automatic Layer Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{LayerAnalysis, LayerDirection};

// Detect natural layers in the graph
let layer_analysis = graph.analyze_layers();

println!("Detected {} layers:", layer_analysis.layers.len());
for (level, nodes) in layer_analysis.layers.iter().enumerate() {
    println!("  Layer {}: {:?}", level, nodes);
}

// Apply layer-based layout
let layer_config = LayerLayoutConfig {
    direction: LayerDirection::LeftToRight,
    layer_spacing: 150.0,
    node_spacing: 100.0,
    center_nodes_in_layer: true,
};

graph.apply_layer_layout(&amp;layer_config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="manual-layer-assignment"><a class="header" href="#manual-layer-assignment">Manual Layer Assignment</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manually assign nodes to layers
let layer_assignments = HashMap::from([
    ("input1".to_string(), 0),
    ("input2".to_string(), 0),
    ("processor1".to_string(), 1),
    ("processor2".to_string(), 1),
    ("output".to_string(), 2),
]);

graph.set_layer_assignments(layer_assignments);
graph.apply_layer_layout(&amp;layer_config)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="group-based-layout"><a class="header" href="#group-based-layout">Group-Based Layout</a></h2>
<h3 id="layout-node-groups"><a class="header" href="#layout-node-groups">Layout Node Groups</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::GroupLayoutConfig;

// Layout nodes within groups
let group_config = GroupLayoutConfig {
    group_spacing: 200.0,
    internal_spacing: 50.0,
    group_padding: 20.0,
    layout_algorithm: LayoutAlgorithm::Grid,
};

// Apply group-aware layout
graph.layout_groups(&amp;group_config)?;

// Layout specific group
graph.layout_group("data_processing", &amp;group_config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="group-boundaries"><a class="header" href="#group-boundaries">Group Boundaries</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Calculate group boundaries
let group_bounds = graph.calculate_group_bounds("data_processing");
if let Some(bounds) = group_bounds {
    println!("Group bounds: ({}, {}) to ({}, {})", 
        bounds.min_x, bounds.min_y, bounds.max_x, bounds.max_y);
}

// Set custom group boundary
let custom_bounds = BoundingBox {
    min_x: 100.0,
    min_y: 50.0,
    max_x: 400.0,
    max_y: 250.0,
};
graph.set_group_bounds("data_processing", custom_bounds);
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-layout-features"><a class="header" href="#advanced-layout-features">Advanced Layout Features</a></h2>
<h3 id="multi-level-layout"><a class="header" href="#multi-level-layout">Multi-Level Layout</a></h3>
<p>For very large graphs, use multi-level layout:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::MultiLevelConfig;

let multilevel_config = MultiLevelConfig {
    coarsening_factor: 0.7,
    max_levels: 5,
    uncoarsening_iterations: 10,
    finest_level_iterations: 20,
};

let positions = graph.multilevel_layout(&amp;multilevel_config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="incremental-layout"><a class="header" href="#incremental-layout">Incremental Layout</a></h3>
<p>Update layout incrementally when nodes are added/removed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add node with incremental layout update
graph.add_node("new_processor", "DataProcessor", None);
graph.add_connection("source", "out", "new_processor", "in", None);

// Update layout incrementally
let incremental_config = IncrementalLayoutConfig {
    stabilization_iterations: 10,
    affected_nodes_only: true,
    preserve_existing_positions: true,
};

graph.incremental_layout_update(&amp;incremental_config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="layout-animation-support"><a class="header" href="#layout-animation-support">Layout Animation Support</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{LayoutAnimation, AnimationFrame};

// Generate animation frames for smooth transitions
let from_positions = graph.get_all_positions();
let to_positions = graph.calculate_layout();

let animation = LayoutAnimation::new(from_positions, to_positions, 30); // 30 frames

// Get animation frames
for (frame_idx, frame) in animation.frames().enumerate() {
    println!("Frame {}: {} position updates", frame_idx, frame.positions.len());
    
    // Apply frame in UI
    for (node_id, position) in frame.positions {
        // Update UI node position
        ui.set_node_position(&amp;node_id, position.x, position.y);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="layout-quality-metrics"><a class="header" href="#layout-quality-metrics">Layout Quality Metrics</a></h2>
<h3 id="measuring-layout-quality"><a class="header" href="#measuring-layout-quality">Measuring Layout Quality</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{LayoutMetrics, LayoutQuality};

let metrics = graph.calculate_layout_metrics();

println!("Layout Quality Metrics:");
println!("  Edge crossings: {}", metrics.edge_crossings);
println!("  Average edge length: {:.2}", metrics.average_edge_length);
println!("  Node distribution score: {:.2}", metrics.node_distribution_score);
println!("  Aspect ratio: {:.2}", metrics.aspect_ratio);
println!("  Overall score: {:.2}", metrics.overall_quality_score);

// Detailed metrics
println!("\nDetailed Metrics:");
println!("  Minimum edge length: {:.2}", metrics.min_edge_length);
println!("  Maximum edge length: {:.2}", metrics.max_edge_length);
println!("  Edge length variance: {:.2}", metrics.edge_length_variance);
println!("  Node overlap count: {}", metrics.node_overlaps);
println!("  Angular resolution: {:.2}Â°", metrics.angular_resolution);
<span class="boring">}</span></code></pre></pre>
<h3 id="layout-comparison"><a class="header" href="#layout-comparison">Layout Comparison</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compare different layout algorithms
let algorithms = vec![
    LayoutAlgorithm::Hierarchical,
    LayoutAlgorithm::ForceDirected,
    LayoutAlgorithm::Organic,
];

let mut best_layout = None;
let mut best_score = 0.0;

for algorithm in algorithms {
    let config = LayoutConfig {
        algorithm: algorithm.clone(),
        ..Default::default()
    };
    
    let positions = graph.calculate_layout_with_config(&amp;config);
    graph.apply_positions(positions);
    
    let metrics = graph.calculate_layout_metrics();
    let score = metrics.overall_quality_score;
    
    println!("{:?}: score {:.2}", algorithm, score);
    
    if score &gt; best_score {
        best_score = score;
        best_layout = Some(algorithm);
    }
}

if let Some(best) = best_layout {
    println!("Best layout algorithm: {:?} (score: {:.2})", best, best_score);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-layout-algorithms"><a class="header" href="#custom-layout-algorithms">Custom Layout Algorithms</a></h2>
<h3 id="implementing-custom-layout"><a class="header" href="#implementing-custom-layout">Implementing Custom Layout</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{CustomLayout, LayoutContext};

struct CircularLayout {
    radius: f64,
    start_angle: f64,
}

impl CustomLayout for CircularLayout {
    fn calculate_positions(&amp;self, context: &amp;LayoutContext) -&gt; HashMap&lt;String, Position&gt; {
        let mut positions = HashMap::new();
        let node_count = context.nodes.len();
        let angle_step = 2.0 * std::f64::consts::PI / node_count as f64;
        
        for (i, node_id) in context.nodes.iter().enumerate() {
            let angle = self.start_angle + i as f64 * angle_step;
            let x = self.radius * angle.cos();
            let y = self.radius * angle.sin();
            
            positions.insert(node_id.clone(), Position { x, y, anchor: None });
        }
        
        positions
    }
}

// Use custom layout
let circular = CircularLayout {
    radius: 200.0,
    start_angle: 0.0,
};

let positions = graph.apply_custom_layout(&amp;circular)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="layout-plugins"><a class="header" href="#layout-plugins">Layout Plugins</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Register layout plugin
graph.register_layout_plugin("spiral", Box::new(SpiralLayout::new()));

// Use registered plugin
let config = LayoutConfig {
    algorithm: LayoutAlgorithm::Custom("spiral".to_string()),
    ..Default::default()
};

graph.calculate_layout_with_config(&amp;config);
<span class="boring">}</span></code></pre></pre>
<h2 id="layout-events"><a class="header" href="#layout-events">Layout Events</a></h2>
<h3 id="listening-to-layout-changes"><a class="header" href="#listening-to-layout-changes">Listening to Layout Changes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::LayoutEvents;

// Subscribe to layout events
let layout_receiver = graph.layout_event_channel.1.clone();

std::thread::spawn(move || {
    while let Ok(event) = layout_receiver.recv() {
        match event {
            LayoutEvents::LayoutStarted { algorithm } =&gt; {
                println!("Layout started: {:?}", algorithm);
            }
            LayoutEvents::LayoutCompleted { algorithm, duration } =&gt; {
                println!("Layout completed: {:?} in {:?}", algorithm, duration);
            }
            LayoutEvents::NodePositionChanged { node_id, old_pos, new_pos } =&gt; {
                println!("Node {} moved: ({:.1}, {:.1}) -&gt; ({:.1}, {:.1})", 
                    node_id, old_pos.x, old_pos.y, new_pos.x, new_pos.y);
            }
            LayoutEvents::LayoutProgress { progress } =&gt; {
                println!("Layout progress: {:.1}%", progress * 100.0);
            }
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="webassembly-layout-api"><a class="header" href="#webassembly-layout-api">WebAssembly Layout API</a></h2>
<h3 id="javascript-integration"><a class="header" href="#javascript-integration">JavaScript Integration</a></h3>
<pre><code class="language-javascript">import { Graph, LayoutAlgorithm } from 'reflow-network';

const graph = new Graph("LayoutDemo", false, {});

// Add nodes and connections
graph.addNode("input", "InputNode", {});
graph.addNode("processor", "ProcessorNode", {});
graph.addNode("output", "OutputNode", {});
graph.addConnection("input", "out", "processor", "in", {});
graph.addConnection("processor", "out", "output", "in", {});

// Apply automatic layout
const positions = graph.calculateLayout({
    algorithm: LayoutAlgorithm.Hierarchical,
    nodeSpacing: 120,
    layerSpacing: 80
});

// Update UI with calculated positions
for (const [nodeId, position] of positions) {
    const nodeElement = document.getElementById(nodeId);
    nodeElement.style.left = `${position.x}px`;
    nodeElement.style.top = `${position.y}px`;
}

// Manual positioning
graph.setNodePosition("processor", 200, 100);

// Listen for layout events
graph.onLayoutChange((event) =&gt; {
    if (event.type === 'position_changed') {
        updateNodeElement(event.nodeId, event.newPosition);
    }
});
</code></pre>
<h2 id="layout-best-practices"><a class="header" href="#layout-best-practices">Layout Best Practices</a></h2>
<h3 id="performance-optimization-2"><a class="header" href="#performance-optimization-2">Performance Optimization</a></h3>
<ol>
<li><strong>Use appropriate algorithms</strong>: Choose the right algorithm for your graph type</li>
<li><strong>Limit iterations</strong>: Set reasonable iteration limits for force-directed layouts</li>
<li><strong>Cache layouts</strong>: Store calculated positions to avoid recalculation</li>
<li><strong>Incremental updates</strong>: Use incremental layout for small changes</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Incremental update for small changes
graph.add_node("new_node", "Component", None);
graph.incremental_layout_update(&amp;incremental_config)?;

// Avoid: Full recalculation for small changes
graph.auto_layout()?; // Expensive for large graphs
<span class="boring">}</span></code></pre></pre>
<h3 id="visual-quality"><a class="header" href="#visual-quality">Visual Quality</a></h3>
<ol>
<li><strong>Minimize crossings</strong>: Use algorithms that reduce edge crossings</li>
<li><strong>Consistent spacing</strong>: Maintain uniform spacing between nodes</li>
<li><strong>Respect hierarchy</strong>: Use hierarchical layout for workflow graphs</li>
<li><strong>Group related nodes</strong>: Use group layouts for related components</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Group-aware layout
let group_config = GroupLayoutConfig {
    group_spacing: 200.0,
    internal_spacing: 50.0,
    group_padding: 20.0,
    layout_algorithm: LayoutAlgorithm::Grid,
};
graph.layout_groups(&amp;group_config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="user-experience"><a class="header" href="#user-experience">User Experience</a></h3>
<ol>
<li><strong>Smooth transitions</strong>: Use animation between layout changes</li>
<li><strong>Preserve user positioning</strong>: Respect manually positioned nodes</li>
<li><strong>Provide layout options</strong>: Allow users to choose layout algorithms</li>
<li><strong>Show progress</strong>: Display progress for long-running layout calculations</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Preserve manual positions
let manual_positions = graph.get_manually_positioned_nodes();
let config = LayoutConfig {
    preserve_positions: manual_positions,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="common-layout-issues"><a class="header" href="#common-layout-issues">Common Layout Issues</a></h3>
<ol>
<li><strong>Overlapping nodes</strong>: Increase node spacing or use different algorithm</li>
<li><strong>Poor aspect ratio</strong>: Adjust layout bounds or use compact layout</li>
<li><strong>Too many crossings</strong>: Use hierarchical layout or enable crossing minimization</li>
<li><strong>Unstable force layout</strong>: Reduce spring strength or increase damping</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Fix overlapping nodes
let config = LayoutConfig {
    node_spacing: 150.0, // Increase spacing
    collision_detection: true,
    ..Default::default()
};

// Fix unstable force layout
let force_config = ForceDirectedConfig {
    spring_strength: 0.1, // Reduce from default 0.3
    damping: 0.8,         // Add damping
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li><a href="api/graph/advanced.html">Advanced Features</a> - History, subgraphs, and optimization</li>
<li><a href="api/graph/creating-graphs.html">Creating Graphs</a> - Basic graph operations</li>
<li><a href="api/graph/analysis.html">Graph Analysis</a> - Validation and performance analysis</li>
<li><a href="api/graph/../../tutorials/building-visual-editor.html">Building Visual Editors</a> - Complete tutorial</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-graph-features"><a class="header" href="#advanced-graph-features">Advanced Graph Features</a></h1>
<p>This guide covers advanced features of Reflow's graph system including history management, subgraph operations, optimization techniques, and performance tuning.</p>
<h2 id="history-management"><a class="header" href="#history-management">History Management</a></h2>
<h3 id="basic-history-operations"><a class="header" href="#basic-history-operations">Basic History Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{Graph, GraphHistory};

// Create graph with history tracking
let (mut graph, mut history) = Graph::with_history();

// Make some changes
graph.add_node("input", "InputNode", None);
graph.add_node("output", "OutputNode", None);
graph.add_connection("input", "out", "output", "in", None);

// Undo last operation
if let Some(operation) = history.undo() {
    history.apply_inverse(&amp;mut graph, operation)?;
    println!("Undid: {:?}", operation);
}

// Redo operation
if let Some(operation) = history.redo() {
    history.apply_operation(&amp;mut graph, operation)?;
    println!("Redid: {:?}", operation);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="advanced-history-configuration"><a class="header" href="#advanced-history-configuration">Advanced History Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{HistoryConfig, HistoryLimit};

// Create history with custom configuration
let history_config = HistoryConfig {
    limit: HistoryLimit::Operations(100),  // Limit to 100 operations
    compress_threshold: 50,                // Compress after 50 operations
    auto_cleanup: true,                    // Clean up old entries automatically
    track_metadata_changes: true,          // Track metadata changes
};

let (mut graph, mut history) = Graph::with_history_config(history_config);

// Alternative: Limit by memory usage
let memory_config = HistoryConfig {
    limit: HistoryLimit::Memory(10 * 1024 * 1024), // 10 MB limit
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<h3 id="history-compression"><a class="header" href="#history-compression">History Compression</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Manually compress history
history.compress()?;

// Get compression statistics
let stats = history.compression_stats();
println!("Compressed {} operations into {} snapshots", 
    stats.original_operations, stats.compressed_snapshots);
println!("Memory saved: {:.1} MB", stats.memory_saved / 1024.0 / 1024.0);

// Force full compression
history.force_compress_all()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="history-snapshots"><a class="header" href="#history-snapshots">History Snapshots</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::Snapshot;

// Create named snapshot
let snapshot_id = history.create_snapshot("before_major_changes")?;

// Make changes...
graph.add_node("processor1", "DataProcessor", None);
graph.add_node("processor2", "DataProcessor", None);

// Restore to snapshot
history.restore_snapshot(&amp;mut graph, &amp;snapshot_id)?;

// List all snapshots
let snapshots = history.list_snapshots();
for snapshot in snapshots {
    println!("Snapshot: {} (created: {})", snapshot.name, snapshot.timestamp);
}

// Delete old snapshots
history.delete_snapshot("old_snapshot")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="branching-history"><a class="header" href="#branching-history">Branching History</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::HistoryBranch;

// Create branch from current state
let branch_id = history.create_branch("experimental_feature")?;

// Switch to branch
history.switch_branch(&amp;mut graph, &amp;branch_id)?;

// Make experimental changes
graph.add_node("experimental", "ExperimentalNode", None);

// Switch back to main branch
history.switch_branch(&amp;mut graph, "main")?;

// Merge branch if satisfied with changes
history.merge_branch(&amp;mut graph, &amp;branch_id, "main")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="history-events"><a class="header" href="#history-events">History Events</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::HistoryEvents;

// Subscribe to history events
let history_receiver = history.event_channel().1.clone();

std::thread::spawn(move || {
    while let Ok(event) = history_receiver.recv() {
        match event {
            HistoryEvents::OperationAdded { operation, index } =&gt; {
                println!("Added operation {}: {:?}", index, operation);
            }
            HistoryEvents::Undo { operation } =&gt; {
                println!("Undid operation: {:?}", operation);
            }
            HistoryEvents::Redo { operation } =&gt; {
                println!("Redid operation: {:?}", operation);
            }
            HistoryEvents::SnapshotCreated { name, timestamp } =&gt; {
                println!("Created snapshot '{}' at {}", name, timestamp);
            }
            HistoryEvents::HistoryCompressed { before_size, after_size } =&gt; {
                println!("Compressed history: {} -&gt; {} operations", before_size, after_size);
            }
        }
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="subgraph-operations"><a class="header" href="#subgraph-operations">Subgraph Operations</a></h2>
<h3 id="creating-subgraphs"><a class="header" href="#creating-subgraphs">Creating Subgraphs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{Subgraph, SubgraphConfig};

// Extract subgraph by node selection
let selected_nodes = vec!["processor1", "processor2", "connector"];
let subgraph = graph.extract_subgraph(&amp;selected_nodes)?;

println!("Extracted subgraph:");
println!("  Nodes: {:?}", subgraph.nodes);
println!("  Internal connections: {}", subgraph.internal_connections.len());
println!("  External connections: {}", subgraph.external_connections.len());

// Create subgraph with configuration
let config = SubgraphConfig {
    include_metadata: true,
    preserve_external_connections: true,
    auto_add_ports: true,
};

let configured_subgraph = graph.extract_subgraph_with_config(&amp;selected_nodes, &amp;config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="subgraph-analysis-2"><a class="header" href="#subgraph-analysis-2">Subgraph Analysis</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::SubgraphAnalysis;

let analysis = graph.analyze_subgraph(&amp;subgraph);

println!("Subgraph Analysis:");
println!("  Node count: {}", analysis.node_count);
println!("  Connection count: {}", analysis.connection_count);
println!("  Max depth: {}", analysis.max_depth);
println!("  Is cyclic: {}", analysis.is_cyclic);
println!("  Branching factor: {:.2}", analysis.branching_factor);
println!("  Complexity score: {:.2}", analysis.complexity_score);

// Detailed connectivity analysis
println!("  Entry points: {:?}", analysis.entry_points);
println!("  Exit points: {:?}", analysis.exit_points);
println!("  Internal clusters: {}", analysis.internal_clusters);
<span class="boring">}</span></code></pre></pre>
<h3 id="subgraph-operations-1"><a class="header" href="#subgraph-operations-1">Subgraph Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Clone subgraph
let cloned_subgraph = subgraph.clone();

// Merge subgraphs
let merged = Subgraph::merge(vec![subgraph1, subgraph2, subgraph3])?;

// Subtract subgraph (remove nodes)
let remainder = graph.subtract_subgraph(&amp;subgraph)?;

// Replace subgraph with optimized version
let optimized = optimize_subgraph(&amp;subgraph)?;
graph.replace_subgraph(&amp;subgraph, &amp;optimized)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="subgraph-templates"><a class="header" href="#subgraph-templates">Subgraph Templates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{SubgraphTemplate, TemplateParameter};

// Create reusable subgraph template
let template = SubgraphTemplate {
    name: "data_processing_pipeline".to_string(),
    description: "Standard data processing pipeline".to_string(),
    nodes: subgraph.nodes.clone(),
    connections: subgraph.internal_connections.clone(),
    parameters: vec![
        TemplateParameter {
            name: "buffer_size".to_string(),
            param_type: "integer".to_string(),
            default_value: Some(json!(1024)),
            description: "Buffer size for data processing".to_string(),
        }
    ],
};

// Instantiate template with parameters
let instance_params = HashMap::from([
    ("buffer_size".to_string(), json!(2048))
]);

let instance = template.instantiate("pipeline_1", instance_params)?;
graph.add_subgraph_instance(instance)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-optimization"><a class="header" href="#graph-optimization">Graph Optimization</a></h2>
<h3 id="automatic-optimization"><a class="header" href="#automatic-optimization">Automatic Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{OptimizationConfig, OptimizationLevel};

// Basic optimization
let optimized_graph = graph.optimize()?;

// Advanced optimization with configuration
let optimization_config = OptimizationConfig {
    level: OptimizationLevel::Aggressive,
    remove_redundant_nodes: true,
    merge_compatible_nodes: true,
    optimize_connection_paths: true,
    reorder_for_cache_locality: true,
    minimize_communication_cost: true,
};

let optimized = graph.optimize_with_config(&amp;optimization_config)?;

// Apply optimizations in-place
graph.apply_optimizations(&amp;optimization_config)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="redundancy-elimination"><a class="header" href="#redundancy-elimination">Redundancy Elimination</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::RedundancyAnalysis;

// Find redundant nodes
let redundancy = graph.analyze_redundancy();

println!("Redundancy Analysis:");
for redundant in redundancy.redundant_nodes {
    println!("  Node '{}': {}", redundant.node, redundant.reason);
    
    match redundant.redundancy_type {
        RedundancyType::DuplicateFunction =&gt; {
            println!("    Can be merged with: {:?}", redundant.merge_candidates);
        }
        RedundancyType::NoOperation =&gt; {
            println!("    Performs no operation - can be removed");
        }
        RedundancyType::BypassableTransform =&gt; {
            println!("    Transform can be bypassed");
        }
    }
}

// Automatically remove redundant nodes
graph.remove_redundant_nodes()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="node-fusion"><a class="header" href="#node-fusion">Node Fusion</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::FusionCandidate;

// Find nodes that can be fused together
let fusion_candidates = graph.find_fusion_candidates();

for candidate in fusion_candidates {
    println!("Fusion opportunity: {:?}", candidate.nodes);
    println!("  Estimated speedup: {:.1}x", candidate.estimated_speedup);
    println!("  Memory savings: {:.1} MB", candidate.memory_savings);
    
    // Apply fusion if beneficial
    if candidate.estimated_speedup &gt; 1.5 {
        graph.fuse_nodes(&amp;candidate.nodes, &amp;candidate.fusion_strategy)?;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="connection-optimization"><a class="header" href="#connection-optimization">Connection Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::ConnectionOptimization;

// Optimize connection routing
let connection_opt = ConnectionOptimization {
    minimize_wire_length: true,
    reduce_crossings: true,
    bundle_parallel_connections: true,
    use_hierarchical_routing: true,
};

graph.optimize_connections(&amp;connection_opt)?;

// Find and eliminate unnecessary intermediate nodes
let bypass_candidates = graph.find_bypass_candidates();
for candidate in bypass_candidates {
    if candidate.is_safe_to_bypass() {
        graph.bypass_node(&amp;candidate.node)?;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tuning"><a class="header" href="#performance-tuning">Performance Tuning</a></h2>
<h3 id="memory-optimization"><a class="header" href="#memory-optimization">Memory Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{MemoryConfig, MemoryOptimization};

// Configure memory usage
let memory_config = MemoryConfig {
    node_pool_size: 1000,
    connection_pool_size: 5000,
    metadata_cache_size: 10 * 1024 * 1024, // 10 MB
    enable_lazy_loading: true,
    compress_metadata: true,
};

graph.configure_memory(&amp;memory_config)?;

// Apply memory optimizations
let memory_opt = MemoryOptimization {
    compact_node_storage: true,
    use_interned_strings: true,
    enable_copy_on_write: true,
    garbage_collect_threshold: 0.8,
};

graph.apply_memory_optimization(&amp;memory_opt)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="index-optimization"><a class="header" href="#index-optimization">Index Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::IndexConfig;

// Optimize internal indices for better performance
let index_config = IndexConfig {
    connection_index_type: IndexType::HashMap, // Fast lookups
    node_index_type: IndexType::BTreeMap,      // Ordered iteration
    spatial_index_enabled: true,               // For layout operations
    cache_frequently_accessed: true,
};

graph.rebuild_indices(&amp;index_config)?;

// Enable adaptive indexing
graph.enable_adaptive_indexing(true);
<span class="boring">}</span></code></pre></pre>
<h3 id="parallel-processing-setup"><a class="header" href="#parallel-processing-setup">Parallel Processing Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{ParallelConfig, ThreadingModel};

// Configure parallel processing
let parallel_config = ParallelConfig {
    max_threads: num_cpus::get(),
    threading_model: ThreadingModel::WorkStealing,
    enable_parallel_analysis: true,
    parallel_layout_threshold: 100, // Use parallel layout for &gt;100 nodes
    chunk_size: 50,
};

graph.configure_parallel_processing(&amp;parallel_config)?;

// Enable parallel operations
graph.enable_parallel_operations(true);
<span class="boring">}</span></code></pre></pre>
<h3 id="benchmarking-and-profiling"><a class="header" href="#benchmarking-and-profiling">Benchmarking and Profiling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{Benchmark, ProfileConfig};
use std::time::Instant;

// Benchmark graph operations
let benchmark = Benchmark::new(&amp;graph);

let results = benchmark.run_full_suite()?;
println!("Benchmark Results:");
println!("  Node addition: {:.2}Î¼s", results.node_addition_time.as_micros());
println!("  Connection creation: {:.2}Î¼s", results.connection_time.as_micros());
println!("  Cycle detection: {:.2}ms", results.cycle_detection_time.as_millis());
println!("  Layout calculation: {:.2}ms", results.layout_time.as_millis());
println!("  Validation: {:.2}ms", results.validation_time.as_millis());

// Profile specific operations
let profile_config = ProfileConfig {
    sample_rate: 1000, // Sample every 1000 operations
    track_memory: true,
    track_time: true,
    output_format: OutputFormat::Json,
};

let profiler = graph.create_profiler(&amp;profile_config)?;
profiler.start();

// Perform operations...
graph.add_node("test", "TestNode", None);
// ... more operations

let profile_results = profiler.stop_and_collect();
profile_results.save_to_file("graph_profile.json")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="large-graph-handling"><a class="header" href="#large-graph-handling">Large Graph Handling</a></h2>
<h3 id="streaming-operations"><a class="header" href="#streaming-operations">Streaming Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{StreamingConfig, GraphStream};

// Handle very large graphs with streaming
let streaming_config = StreamingConfig {
    chunk_size: 1000,
    memory_limit: 100 * 1024 * 1024, // 100 MB
    enable_disk_spillover: true,
    compression_level: 6,
};

let graph_stream = GraphStream::new(streaming_config);

// Process graph in chunks
for chunk in graph_stream.process_in_chunks(&amp;large_graph) {
    let chunk_result = process_graph_chunk(chunk)?;
    graph_stream.accumulate_result(chunk_result);
}

let final_result = graph_stream.finalize()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="lazy-loading"><a class="header" href="#lazy-loading">Lazy Loading</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::LazyGraph;

// Create lazy-loading graph for very large datasets
let lazy_graph = LazyGraph::from_file("massive_graph.json")?;

// Nodes and connections are loaded on demand
if let Some(node) = lazy_graph.get_node("some_node")? {
    // Node is loaded into memory only when accessed
    println!("Node component: {}", node.component);
}

// Preload specific subgraphs for better performance
lazy_graph.preload_subgraph(&amp;["critical_node_1", "critical_node_2"])?;
<span class="boring">}</span></code></pre></pre>
<h3 id="distributed-graph-processing"><a class="header" href="#distributed-graph-processing">Distributed Graph Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{DistributedGraph, NodePartition};

// Partition graph across multiple nodes
let partitions = graph.create_partitions(4)?; // 4 partitions

for (i, partition) in partitions.iter().enumerate() {
    println!("Partition {}: {} nodes", i, partition.nodes.len());
    
    // Deploy partition to worker node
    let worker_id = format!("worker_{}", i);
    deploy_partition_to_worker(&amp;worker_id, partition)?;
}

// Coordinate distributed operations
let distributed_graph = DistributedGraph::new(partitions);
let distributed_result = distributed_graph.execute_distributed_analysis().await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-analysis"><a class="header" href="#advanced-analysis">Advanced Analysis</a></h2>
<h3 id="machine-learning-integration"><a class="header" href="#machine-learning-integration">Machine Learning Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{MLFeatures, GraphEmbedding};

// Extract features for machine learning
let features = graph.extract_ml_features();

println!("Graph ML Features:");
println!("  Node features: {} dimensions", features.node_features.len());
println!("  Edge features: {} dimensions", features.edge_features.len());
println!("  Global features: {} dimensions", features.global_features.len());

// Generate graph embeddings
let embedding_config = EmbeddingConfig {
    embedding_size: 128,
    walk_length: 10,
    num_walks: 100,
    context_size: 5,
};

let embeddings = graph.generate_embeddings(&amp;embedding_config)?;

// Use embeddings for similarity analysis
let similar_nodes = embeddings.find_similar_nodes("reference_node", 5)?;
for (node, similarity) in similar_nodes {
    println!("Similar node: {} (similarity: {:.3})", node, similarity);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-mining"><a class="header" href="#pattern-mining">Pattern Mining</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{PatternMiner, FrequentPattern};

// Mine frequent subgraph patterns
let miner = PatternMiner::new();
let patterns = miner.mine_frequent_patterns(&amp;graph, 0.1)?; // 10% minimum support

for pattern in patterns {
    println!("Frequent pattern (support: {:.1}%):", pattern.support * 100.0);
    println!("  Nodes: {:?}", pattern.nodes);
    println!("  Connections: {:?}", pattern.connections);
    
    // Find all instances of this pattern
    let instances = graph.find_pattern_instances(&amp;pattern)?;
    println!("  Found in {} locations", instances.len());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="anomaly-detection"><a class="header" href="#anomaly-detection">Anomaly Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{AnomalyDetector, AnomalyType};

// Detect structural anomalies
let detector = AnomalyDetector::new();
let anomalies = detector.detect_anomalies(&amp;graph)?;

for anomaly in anomalies {
    match anomaly.anomaly_type {
        AnomalyType::UnusualDegree =&gt; {
            println!("Node '{}' has unusual connectivity: {} connections", 
                anomaly.node, anomaly.score);
        }
        AnomalyType::IsolatedCluster =&gt; {
            println!("Isolated cluster detected around node '{}'", anomaly.node);
        }
        AnomalyType::UnexpectedPattern =&gt; {
            println!("Unexpected pattern at node '{}' (novelty: {:.2})", 
                anomaly.node, anomaly.score);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="graph-transformation"><a class="header" href="#graph-transformation">Graph Transformation</a></h2>
<h3 id="rule-based-transformations"><a class="header" href="#rule-based-transformations">Rule-Based Transformations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{TransformationRule, RuleEngine};

// Define transformation rules
let rule = TransformationRule {
    name: "optimize_serial_processors".to_string(),
    pattern: GraphPattern::parse("A -&gt; B -&gt; C where A.type == B.type == 'Processor'")?,
    replacement: GraphReplacement::parse("A+B+C -&gt; OptimizedProcessor")?,
    condition: |nodes| {
        // Custom condition logic
        nodes.iter().all(|n| n.metadata.get("parallelizable") == Some(&amp;json!(true)))
    },
};

// Apply transformation rules
let rule_engine = RuleEngine::new();
rule_engine.add_rule(rule);

let transformed_graph = rule_engine.apply_rules(&amp;graph)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="graph-morphing"><a class="header" href="#graph-morphing">Graph Morphing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{MorphingConfig, MorphingStrategy};

// Gradually transform graph structure
let morphing_config = MorphingConfig {
    strategy: MorphingStrategy::Gradual,
    steps: 10,
    preserve_semantics: true,
    target_layout: Some(target_positions),
};

let morphing_steps = graph.create_morphing_sequence(&amp;target_graph, &amp;morphing_config)?;

for (step, intermediate_graph) in morphing_steps.enumerate() {
    println!("Morphing step {}/{}", step + 1, morphing_config.steps);
    
    // Apply intermediate graph state
    apply_graph_state(&amp;intermediate_graph);
    
    // Optional: pause for animation
    std::thread::sleep(std::time::Duration::from_millis(100));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-extensions"><a class="header" href="#custom-extensions">Custom Extensions</a></h2>
<h3 id="plugin-system"><a class="header" href="#plugin-system">Plugin System</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{GraphPlugin, PluginConfig};

// Create custom graph plugin
struct MyCustomPlugin {
    config: PluginConfig,
}

impl GraphPlugin for MyCustomPlugin {
    fn initialize(&amp;mut self, graph: &amp;mut Graph) -&gt; Result&lt;(), GraphError&gt; {
        // Plugin initialization logic
        println!("Initializing custom plugin for graph: {}", graph.name);
        Ok(())
    }
    
    fn on_node_added(&amp;mut self, graph: &amp;Graph, node: &amp;GraphNode) {
        // Custom logic when nodes are added
        println!("Plugin: Node added: {}", node.id);
    }
    
    fn on_connection_added(&amp;mut self, graph: &amp;Graph, connection: &amp;GraphConnection) {
        // Custom logic when connections are added
        println!("Plugin: Connection added");
    }
    
    fn custom_analysis(&amp;self, graph: &amp;Graph) -&gt; CustomAnalysisResult {
        // Custom analysis implementation
        CustomAnalysisResult::new()
    }
}

// Register and use plugin
graph.register_plugin("my_plugin", Box::new(MyCustomPlugin::new()))?;
graph.enable_plugin("my_plugin")?;

// Call custom analysis
let custom_result = graph.call_plugin_analysis("my_plugin")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="event-hooks"><a class="header" href="#event-hooks">Event Hooks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{EventHook, HookPriority};

// Create custom event hook
let custom_hook = EventHook::new()
    .on_node_added(|graph, node| {
        println!("Custom hook: Node {} added to graph {}", node.id, graph.name);
    })
    .on_connection_added(|graph, connection| {
        println!("Custom hook: Connection added");
    })
    .with_priority(HookPriority::High);

// Register hook
graph.register_hook("custom_logger", custom_hook)?;

// Temporary hooks for specific operations
graph.with_temporary_hook("validation_hook", |graph| {
    // This hook only applies during this operation
    let validation = graph.validate_flow()?;
    Ok(validation)
})?;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-recovery"><a class="header" href="#error-recovery">Error Recovery</a></h2>
<h3 id="automatic-error-recovery"><a class="header" href="#automatic-error-recovery">Automatic Error Recovery</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{ErrorRecovery, RecoveryStrategy};

// Configure automatic error recovery
let recovery_config = ErrorRecovery {
    strategy: RecoveryStrategy::Rollback,
    max_retries: 3,
    backup_frequency: 10, // Create backup every 10 operations
    auto_fix_common_issues: true,
};

graph.configure_error_recovery(&amp;recovery_config)?;

// Operations are automatically protected
match graph.add_connection("nonexistent", "out", "target", "in", None) {
    Err(e) =&gt; {
        // Graph automatically attempts recovery
        println!("Error occurred but graph recovered: {}", e);
    }
    Ok(_) =&gt; println!("Operation succeeded"),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="manual-recovery-operations"><a class="header" href="#manual-recovery-operations">Manual Recovery Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create manual checkpoint
let checkpoint = graph.create_checkpoint("before_risky_operation")?;

// Perform risky operations
match risky_graph_operation(&amp;mut graph) {
    Ok(result) =&gt; {
        // Success - commit changes
        graph.commit_checkpoint(&amp;checkpoint)?;
        Ok(result)
    }
    Err(e) =&gt; {
        // Failure - rollback to checkpoint
        graph.rollback_to_checkpoint(&amp;checkpoint)?;
        Err(e)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="event-sourcing"><a class="header" href="#event-sourcing">Event Sourcing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{EventStore, GraphEvent};

// Set up event sourcing
let event_store = EventStore::new("graph_events.log")?;
graph.enable_event_sourcing(&amp;event_store)?;

// All graph changes are automatically logged
graph.add_node("event_sourced", "EventNode", None);
// Event is automatically persisted

// Replay events to reconstruct graph state
let events = event_store.read_events_from(timestamp)?;
let reconstructed_graph = Graph::replay_events(events)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="cqrs-pattern"><a class="header" href="#cqrs-pattern">CQRS Pattern</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::graph::{CommandHandler, QueryHandler};

// Separate command and query responsibilities
let command_handler = CommandHandler::new(&amp;mut graph);
let query_handler = QueryHandler::new(&amp;graph);

// Commands modify state
command_handler.execute(AddNodeCommand {
    id: "cmd_node".to_string(),
    component: "CommandNode".to_string(),
    metadata: None,
})?;

// Queries read state (potentially from optimized read models)
let node_info = query_handler.get_node_info("cmd_node")?;
let analysis = query_handler.analyze_connectivity("cmd_node")?;
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-summary"><a class="header" href="#best-practices-summary">Best Practices Summary</a></h2>
<h3 id="performance-best-practices"><a class="header" href="#performance-best-practices">Performance Best Practices</a></h3>
<ol>
<li><strong>Use appropriate data structures</strong>: Choose indices based on access patterns</li>
<li><strong>Enable lazy loading</strong>: For large graphs, load data on demand</li>
<li><strong>Configure memory limits</strong>: Prevent memory exhaustion</li>
<li><strong>Use parallel processing</strong>: Enable for CPU-intensive operations</li>
<li><strong>Cache analysis results</strong>: Store expensive computations</li>
</ol>
<h3 id="scalability-best-practices"><a class="header" href="#scalability-best-practices">Scalability Best Practices</a></h3>
<ol>
<li><strong>Partition large graphs</strong>: Distribute across multiple nodes</li>
<li><strong>Stream large operations</strong>: Process data in chunks</li>
<li><strong>Use compression</strong>: Reduce memory and storage requirements</li>
<li><strong>Implement backpressure</strong>: Control data flow rates</li>
<li><strong>Monitor resource usage</strong>: Track memory and CPU consumption</li>
</ol>
<h3 id="maintainability-best-practices"><a class="header" href="#maintainability-best-practices">Maintainability Best Practices</a></h3>
<ol>
<li><strong>Use version control</strong>: Track graph schema changes</li>
<li><strong>Implement proper error handling</strong>: Handle edge cases gracefully</li>
<li><strong>Document custom extensions</strong>: Maintain clear plugin documentation</li>
<li><strong>Use consistent naming</strong>: Follow naming conventions</li>
<li><strong>Implement comprehensive testing</strong>: Test all graph operations</li>
</ol>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<ul>
<li><a href="api/graph/../../tutorials/building-visual-editor.html">Building Visual Editors</a> - Complete tutorial</li>
<li><a href="api/graph/../../tutorials/performance-optimization.html">Performance Optimization</a> - Advanced optimization techniques</li>
<li><a href="api/graph/creating-graphs.html">Creating Graph</a> - Basic operations</li>
<li><a href="api/graph/analysis.html">Graph Analysis</a> - Validation and analysis</li>
<li><a href="api/graph/layout.html">Layout System</a> - Positioning and visualization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-library"><a class="header" href="#standard-library">Standard Library</a></h1>
<p>Reflow's standard library provides a collection of pre-built components for common workflow operations.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The standard library includes components for:</p>
<ul>
<li><strong>Flow Control</strong>: Conditional logic, loops, and branching</li>
<li><strong>Data Operations</strong>: Transformations, aggregations, and validation</li>
<li><strong>Integration</strong>: External API connectivity and data sources</li>
<li><strong>Synchronization</strong>: Coordination and timing primitives</li>
<li><strong>Utility</strong>: Helper functions and common operations</li>
</ul>
<h2 id="flow-control-components"><a class="header" href="#flow-control-components">Flow Control Components</a></h2>
<h3 id="conditionalactor"><a class="header" href="#conditionalactor">ConditionalActor</a></h3>
<p>Routes messages based on conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::flow_control::ConditionalActor;
use reflow_network::message::Message;

// Create conditional actor
let conditional = ConditionalActor::new(|payload| {
    if let Some(Message::Integer(n)) = payload.get("value") {
        *n &gt; 0
    } else {
        false
    }
});

// Usage in workflow
let mut network = Network::new();
network.add_actor("filter", Box::new(conditional)).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="switchactor"><a class="header" href="#switchactor">SwitchActor</a></h3>
<p>Multi-way routing based on message content:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::flow_control::SwitchActor;

let switch = SwitchActor::new()
    .route("user_event", |msg| {
        matches!(msg.get("type"), Some(Message::String(s)) if s == "user")
    })
    .route("system_event", |msg| {
        matches!(msg.get("type"), Some(Message::String(s)) if s == "system")
    })
    .default_route("unknown");
<span class="boring">}</span></code></pre></pre>
<h3 id="loopactor"><a class="header" href="#loopactor">LoopActor</a></h3>
<p>Iterative processing with configurable conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::flow_control::LoopActor;

let loop_actor = LoopActor::new()
    .max_iterations(100)
    .condition(|payload, iteration| {
        // Continue looping while condition is true
        if let Some(Message::Array(items)) = payload.get("items") {
            !items.is_empty() &amp;&amp; iteration &lt; 50
        } else {
            false
        }
    });
<span class="boring">}</span></code></pre></pre>
<h2 id="data-operations"><a class="header" href="#data-operations">Data Operations</a></h2>
<h3 id="transformactor"><a class="header" href="#transformactor">TransformActor</a></h3>
<p>Applies transformations to input data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::data_operations::TransformActor;
use reflow_network::{Network, NetworkConfig};

// Create network and add transform actor
let mut network = Network::new(NetworkConfig::default());
network.register_actor("transform", TransformActor::new())?;
network.add_node("transformer", "transform")?;

// Usage: Send data with optional transform function
let transform_request = HashMap::from([
    ("In".to_string(), Message::String("hello world".to_string())),
    ("Function".to_string(), Message::String("uppercase".to_string())),
]);

// Supported transformations:
// - "identity": No change
// - "uppercase": Convert string to uppercase
// - "lowercase": Convert string to lowercase  
// - "number_to_string": Convert numbers to strings
// - "parse_int": Parse string to integer
// - "parse_float": Parse string to float
// - "to_json": Convert to JSON string
// - "from_json": Parse JSON string
<span class="boring">}</span></code></pre></pre>
<h3 id="mapactor"><a class="header" href="#mapactor">MapActor</a></h3>
<p>Apply transformations to each item in a collection:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::data_operations::MapActor;

// Create map actor
let mut network = Network::new(NetworkConfig::default());
network.register_actor("map", MapActor::new())?;
network.add_node("mapper", "map")?;

// Usage: Transform each item in an array
let map_request = HashMap::from([
    ("Collection".to_string(), Message::Array(vec![
        Message::String("hello".to_string()).into(),
        Message::String("world".to_string()).into(),
    ])),
    ("Function".to_string(), Message::String("uppercase".to_string())),
]);
// Result: ["HELLO", "WORLD"]
<span class="boring">}</span></code></pre></pre>
<h3 id="reduceactor"><a class="header" href="#reduceactor">ReduceActor</a></h3>
<p>Combine collection items into a single value:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::data_operations::ReduceActor;

// Create reduce actor
let mut network = Network::new(NetworkConfig::default());
network.register_actor("reduce", ReduceActor::new())?;
network.add_node("reducer", "reduce")?;

// Usage: Sum numbers in an array
let reduce_request = HashMap::from([
    ("Collection".to_string(), Message::Array(vec![
        Message::Integer(1).into(),
        Message::Integer(2).into(),
        Message::Integer(3).into(),
    ])),
    ("Function".to_string(), Message::String("sum".to_string())),
]);
// Result: 6

// Supported operations:
// - "sum": Add all numbers or concatenate strings
// - "product": Multiply all numbers
// - "join": Join strings with separator
// - "max": Find maximum value
// - "min": Find minimum value
<span class="boring">}</span></code></pre></pre>
<h3 id="groupactor"><a class="header" href="#groupactor">GroupActor</a></h3>
<p>Group collection items by key or criteria:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::data_operations::GroupActor;

// Create group actor
let mut network = Network::new(NetworkConfig::default());
network.register_actor("group", GroupActor::new())?;
network.add_node("grouper", "group")?;

// Usage: Group objects by property
let group_request = HashMap::from([
    ("Collection".to_string(), Message::Array(vec![
        Message::Object(serde_json::json!({"type": "user", "name": "Alice"}).into()).into(),
        Message::Object(serde_json::json!({"type": "admin", "name": "Bob"}).into()).into(),
        Message::Object(serde_json::json!({"type": "user", "name": "Charlie"}).into()).into(),
    ])),
    ("Key".to_string(), Message::String("type".to_string())),
]);
// Result: {"user": [Alice, Charlie], "admin": [Bob]}
<span class="boring">}</span></code></pre></pre>
<h3 id="sortactor"><a class="header" href="#sortactor">SortActor</a></h3>
<p>Sort collection items by criteria:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::data_operations::SortActor;

// Create sort actor
let mut network = Network::new(NetworkConfig::default());
network.register_actor("sort", SortActor::new())?;
network.add_node("sorter", "sort")?;

// Usage: Sort numbers in descending order
let sort_request = HashMap::from([
    ("Collection".to_string(), Message::Array(vec![
        Message::Integer(3).into(),
        Message::Integer(1).into(),
        Message::Integer(2).into(),
    ])),
    ("Order".to_string(), Message::String("desc".to_string())),
]);
// Result: [3, 2, 1]

// Sort objects by property:
let sort_objects = HashMap::from([
    ("Collection".to_string(), Message::Array(vec![
        Message::Object(serde_json::json!({"age": 30, "name": "Alice"}).into()).into(),
        Message::Object(serde_json::json!({"age": 25, "name": "Bob"}).into()).into(),
    ])),
    ("Key".to_string(), Message::String("age".to_string())),
    ("Order".to_string(), Message::String("asc".to_string())),
]);
// Result: [Bob, Alice] (sorted by age)
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-components"><a class="header" href="#integration-components">Integration Components</a></h2>
<h3 id="httprequestactor"><a class="header" href="#httprequestactor">HttpRequestActor</a></h3>
<p>Make HTTP requests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::integration::HttpRequestActor;

let http_client = HttpRequestActor::new()
    .timeout(Duration::from_secs(30))
    .retry_count(3)
    .default_headers(vec![
        ("User-Agent".to_string(), "Reflow/1.0".to_string()),
        ("Accept".to_string(), "application/json".to_string()),
    ]);

// Usage: send message with url, method, headers, body
let request = HashMap::from([
    ("url".to_string(), Message::String("https://api.example.com/data".to_string())),
    ("method".to_string(), Message::String("GET".to_string())),
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="databaseactor"><a class="header" href="#databaseactor">DatabaseActor</a></h3>
<p>Database connectivity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::integration::DatabaseActor;

let db_actor = DatabaseActor::new("postgresql://user:pass@localhost/db")
    .pool_size(10)
    .connection_timeout(Duration::from_secs(5));

// Usage: send SQL queries
let query = HashMap::from([
    ("sql".to_string(), Message::String("SELECT * FROM users WHERE active = $1".to_string())),
    ("params".to_string(), Message::Array(vec![Message::Boolean(true)])),
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="filesystemactor"><a class="header" href="#filesystemactor">FileSystemActor</a></h3>
<p>File operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::integration::FileSystemActor;

let fs_actor = FileSystemActor::new()
    .base_path("/data")
    .allowed_extensions(vec!["txt", "json", "csv"]);

// Read file
let read_request = HashMap::from([
    ("operation".to_string(), Message::String("read".to_string())),
    ("path".to_string(), Message::String("input.txt".to_string())),
]);

// Write file
let write_request = HashMap::from([
    ("operation".to_string(), Message::String("write".to_string())),
    ("path".to_string(), Message::String("output.txt".to_string())),
    ("content".to_string(), Message::String("Hello, World!".to_string())),
]);
<span class="boring">}</span></code></pre></pre>
<h2 id="synchronization-components"><a class="header" href="#synchronization-components">Synchronization Components</a></h2>
<h3 id="barrieractor"><a class="header" href="#barrieractor">BarrierActor</a></h3>
<p>Wait for multiple inputs before proceeding:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::synchronization::BarrierActor;

let barrier = BarrierActor::new()
    .input_count(3) // Wait for 3 inputs
    .timeout(Duration::from_secs(60)) // Max wait time
    .combine_strategy(CombineStrategy::Merge); // How to combine inputs

// Outputs combined message when all inputs received
<span class="boring">}</span></code></pre></pre>
<h3 id="throttleactor"><a class="header" href="#throttleactor">ThrottleActor</a></h3>
<p>Rate limiting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::synchronization::ThrottleActor;

let throttle = ThrottleActor::new()
    .rate_limit(100) // Max 100 messages per second
    .burst_size(10)  // Allow burst of 10 messages
    .strategy(ThrottleStrategy::DropOldest);
<span class="boring">}</span></code></pre></pre>
<h3 id="delayactor"><a class="header" href="#delayactor">DelayActor</a></h3>
<p>Add delays to message processing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::synchronization::DelayActor;

let delay = DelayActor::new()
    .fixed_delay(Duration::from_millis(500))
    .jitter_range(Duration::from_millis(100)); // Add random jitter
<span class="boring">}</span></code></pre></pre>
<h3 id="scheduleractor"><a class="header" href="#scheduleractor">SchedulerActor</a></h3>
<p>Time-based message generation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::synchronization::SchedulerActor;

let scheduler = SchedulerActor::new()
    .cron_schedule("0 0 * * *") // Daily at midnight
    .message_template(HashMap::from([
        ("event".to_string(), Message::String("daily_job".to_string())),
        ("timestamp".to_string(), Message::String("{{now}}".to_string())),
    ]));
<span class="boring">}</span></code></pre></pre>
<h2 id="utility-components"><a class="header" href="#utility-components">Utility Components</a></h2>
<h3 id="loggeractor"><a class="header" href="#loggeractor">LoggerActor</a></h3>
<p>Structured logging:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::utility::LoggerActor;

let logger = LoggerActor::new()
    .level(LogLevel::Info)
    .format(LogFormat::Json)
    .output(LogOutput::File("/var/log/reflow.log"));

// Usage: send messages to log
let log_message = HashMap::from([
    ("level".to_string(), Message::String("info".to_string())),
    ("message".to_string(), Message::String("Processing started".to_string())),
    ("context".to_string(), Message::Object(context_data)),
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="metricsactor"><a class="header" href="#metricsactor">MetricsActor</a></h3>
<p>Collect and emit metrics:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::utility::MetricsActor;

let metrics = MetricsActor::new()
    .endpoint("http://prometheus:9090/metrics")
    .namespace("reflow")
    .labels(vec![
        ("environment".to_string(), "production".to_string()),
        ("service".to_string(), "workflow-engine".to_string()),
    ]);

// Usage: send metrics data
let metric = HashMap::from([
    ("type".to_string(), Message::String("counter".to_string())),
    ("name".to_string(), Message::String("messages_processed".to_string())),
    ("value".to_string(), Message::Integer(1)),
    ("tags".to_string(), Message::Object(tags)),
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="cacheactor"><a class="header" href="#cacheactor">CacheActor</a></h3>
<p>In-memory caching:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::utility::CacheActor;

let cache = CacheActor::new()
    .max_size(1000)
    .ttl(Duration::from_hours(1))
    .eviction_strategy(EvictionStrategy::LRU);

// Get from cache
let get_request = HashMap::from([
    ("operation".to_string(), Message::String("get".to_string())),
    ("key".to_string(), Message::String("user:123".to_string())),
]);

// Set cache value
let set_request = HashMap::from([
    ("operation".to_string(), Message::String("set".to_string())),
    ("key".to_string(), Message::String("user:123".to_string())),
    ("value".to_string(), Message::Object(user_data)),
    ("ttl".to_string(), Message::Integer(3600)), // Optional custom TTL
]);
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<h3 id="building-a-data-pipeline"><a class="header" href="#building-a-data-pipeline">Building a Data Pipeline</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::Network;
use reflow_components::*;

async fn create_data_pipeline() -&gt; Result&lt;Network, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut network = Network::new();
    
    // 1. HTTP source to fetch data
    let http_source = integration::HttpRequestActor::new()
        .timeout(Duration::from_secs(30));
    
    // 2. Validate incoming data
    let validator = data_operations::ValidatorActor::new()
        .add_rule("required_field", |v| !matches!(v, Message::Null));
    
    // 3. Transform data
    let transformer = data_operations::MapActor::new(|payload| {
        // Custom transformation logic
        transform_data(payload)
    });
    
    // 4. Filter based on criteria
    let filter = data_operations::FilterActor::new(|payload| {
        filter_criteria(payload)
    });
    
    // 5. Aggregate results
    let aggregator = data_operations::AggregateActor::new()
        .window_size(100)
        .timeout(Duration::from_secs(60));
    
    // 6. Store results
    let database = integration::DatabaseActor::new("postgresql://...")
        .pool_size(5);
    
    // 7. Log activity
    let logger = utility::LoggerActor::new()
        .level(LogLevel::Info);
    
    // Add actors to network
    network.add_actor("http_source", Box::new(http_source)).await?;
    network.add_actor("validator", Box::new(validator)).await?;
    network.add_actor("transformer", Box::new(transformer)).await?;
    network.add_actor("filter", Box::new(filter)).await?;
    network.add_actor("aggregator", Box::new(aggregator)).await?;
    network.add_actor("database", Box::new(database)).await?;
    network.add_actor("logger", Box::new(logger)).await?;
    
    // Connect the pipeline
    network.connect("http_source", "output", "validator", "input").await?;
    network.connect("validator", "valid", "transformer", "input").await?;
    network.connect("transformer", "output", "filter", "input").await?;
    network.connect("filter", "output", "aggregator", "input").await?;
    network.connect("aggregator", "output", "database", "input").await?;
    
    // Log all stages
    network.connect("validator", "output", "logger", "input").await?;
    network.connect("transformer", "output", "logger", "input").await?;
    network.connect("aggregator", "output", "logger", "input").await?;
    
    Ok(network)
}

fn transform_data(payload: &amp;HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    // Implementation details...
    Ok(HashMap::new())
}

fn filter_criteria(payload: &amp;HashMap&lt;String, Message&gt;) -&gt; bool {
    // Implementation details...
    true
}
<span class="boring">}</span></code></pre></pre>
<h3 id="real-time-processing-workflow"><a class="header" href="#real-time-processing-workflow">Real-time Processing Workflow</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn create_realtime_workflow() -&gt; Result&lt;Network, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut network = Network::new();
    
    // Stream processor with throttling
    let throttle = synchronization::ThrottleActor::new()
        .rate_limit(1000) // 1000 msgs/sec
        .burst_size(50);
    
    // Real-time analytics
    let analytics = data_operations::AggregateActor::new()
        .window_size(1000)
        .timeout(Duration::from_secs(5)) // 5-second windows
        .aggregation_fn(|messages| {
            let mut stats = HashMap::new();
            
            // Calculate real-time statistics
            let count = messages.len() as i64;
            let avg_processing_time = calculate_avg_time(&amp;messages);
            
            stats.insert("count".to_string(), Message::Integer(count));
            stats.insert("avg_time".to_string(), Message::Float(avg_processing_time));
            stats.insert("window_end".to_string(), 
                        Message::String(chrono::Utc::now().to_rfc3339()));
            
            stats
        });
    
    // Metrics collection
    let metrics = utility::MetricsActor::new()
        .namespace("realtime")
        .endpoint("http://prometheus:9090/metrics");
    
    // Alert on anomalies
    let anomaly_detector = flow_control::ConditionalActor::new(|payload| {
        if let Some(Message::Float(avg_time)) = payload.get("avg_time") {
            *avg_time &gt; 1000.0 // Alert if avg time &gt; 1 second
        } else {
            false
        }
    });
    
    // Add to network
    network.add_actor("throttle", Box::new(throttle)).await?;
    network.add_actor("analytics", Box::new(analytics)).await?;
    network.add_actor("metrics", Box::new(metrics)).await?;
    network.add_actor("anomaly_detector", Box::new(anomaly_detector)).await?;
    
    // Connect pipeline
    network.connect("throttle", "output", "analytics", "input").await?;
    network.connect("analytics", "output", "metrics", "input").await?;
    network.connect("analytics", "output", "anomaly_detector", "input").await?;
    
    Ok(network)
}

fn calculate_avg_time(messages: &amp;[HashMap&lt;String, Message&gt;]) -&gt; f64 {
    // Calculate average processing time
    0.0
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-component-creation"><a class="header" href="#custom-component-creation">Custom Component Creation</a></h2>
<h3 id="creating-a-custom-component"><a class="header" href="#creating-a-custom-component">Creating a Custom Component</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::ComponentBuilder;

// Define component configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
struct CustomConfig {
    threshold: f64,
    operation: String,
}

// Create component using builder
let custom_component = ComponentBuilder::new("custom_processor")
    .description("Custom data processor")
    .input_ports(vec!["data", "control"])
    .output_ports(vec!["result", "error"])
    .config_schema(serde_json::to_value(CustomConfig::default())?)
    .behavior(|payload, config| {
        Box::pin(async move {
            let config: CustomConfig = serde_json::from_value(config)?;
            
            // Custom processing logic
            process_custom_logic(payload, &amp;config).await
        })
    })
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="component-registration"><a class="header" href="#component-registration">Component Registration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::ComponentRegistry;

// Register custom components
let mut registry = ComponentRegistry::new();

registry.register("custom_processor", custom_component)?;
registry.register("special_filter", special_filter_component)?;

// Use in workflows
let component = registry.create("custom_processor", custom_config)?;
network.add_actor("processor", component).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-8"><a class="header" href="#error-handling-8">Error Handling</a></h2>
<h3 id="error-propagation-1"><a class="header" href="#error-propagation-1">Error Propagation</a></h3>
<p>Components follow consistent error handling patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Components return structured errors
let error_result = HashMap::from([
    ("error".to_string(), Message::Error("Validation failed".to_string())),
    ("error_code".to_string(), Message::String("VALIDATION_ERROR".to_string())),
    ("details".to_string(), Message::Object(error_details)),
    ("timestamp".to_string(), Message::String(Utc::now().to_rfc3339())),
]);
<span class="boring">}</span></code></pre></pre>
<h3 id="error-recovery-1"><a class="header" href="#error-recovery-1">Error Recovery</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use error handling components
let error_handler = flow_control::ConditionalActor::new(|payload| {
    payload.contains_key("error")
});

let retry_actor = utility::RetryActor::new()
    .max_attempts(3)
    .backoff_strategy(BackoffStrategy::Exponential);

// Connect for error recovery
network.connect("processor", "error", "error_handler", "input").await?;
network.connect("error_handler", "true", "retry_actor", "input").await?;
network.connect("retry_actor", "output", "processor", "input").await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-tuning-1"><a class="header" href="#performance-tuning-1">Performance Tuning</a></h2>
<h3 id="batching"><a class="header" href="#batching">Batching</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use batching for high-throughput scenarios
let batch_processor = data_operations::MapActor::new(|payload| {
    if let Some(Message::Array(batch)) = payload.get("batch") {
        // Process entire batch at once
        process_batch(batch)
    } else {
        // Handle single message
        process_single(payload)
    }
});

let batcher = utility::BatchActor::new()
    .batch_size(100)
    .timeout(Duration::from_millis(100));
<span class="boring">}</span></code></pre></pre>
<h3 id="parallel-processing"><a class="header" href="#parallel-processing">Parallel Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Distribute work across multiple workers
let load_balancer = flow_control::LoadBalancerActor::new()
    .strategy(LoadBalanceStrategy::RoundRobin)
    .worker_count(4);

// Workers process in parallel
for i in 0..4 {
    let worker = data_operations::MapActor::new(process_function);
    network.add_actor(&amp;format!("worker_{}", i), Box::new(worker)).await?;
    network.connect("load_balancer", &amp;format!("output_{}", i), 
                   &amp;format!("worker_{}", i), "input").await?;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="component-selection"><a class="header" href="#component-selection">Component Selection</a></h3>
<ol>
<li><strong>Use appropriate granularity</strong> - Not too fine, not too coarse</li>
<li><strong>Prefer composition</strong> - Combine simple components over complex ones</li>
<li><strong>Consider performance</strong> - Choose components based on throughput requirements</li>
<li><strong>Plan for errors</strong> - Include error handling components in workflows</li>
</ol>
<h3 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h3>
<ol>
<li><strong>Validate configuration</strong> - Use schema validation</li>
<li><strong>Use environment variables</strong> - For deployment-specific settings</li>
<li><strong>Document requirements</strong> - Clear component dependencies</li>
<li><strong>Test configurations</strong> - Validate settings before deployment</li>
</ol>
<h3 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h3>
<ol>
<li><strong>Add logging</strong> - Include LoggerActor for observability</li>
<li><strong>Collect metrics</strong> - Use MetricsActor for performance monitoring</li>
<li><strong>Set up alerts</strong> - Use ConditionalActor for anomaly detection</li>
<li><strong>Monitor resource usage</strong> - Track memory and CPU usage</li>
</ol>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<ul>
<li><a href="components/./custom-components.html">Creating Custom Components</a> - Build your own components</li>
<li><a href="components/./component-testing.html">Component Testing</a> - Testing strategies</li>
<li><a href="components/./performance-optimization.html">Performance Guide</a> - Optimization techniques</li>
<li><a href="components/../examples/README.html">Examples</a> - Real-world component usage</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deno-runtime-1"><a class="header" href="#deno-runtime-1">Deno Runtime</a></h1>
<p>Reflow's Deno runtime enables JavaScript and TypeScript actors with secure, sandboxed execution.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The Deno runtime provides:</p>
<ul>
<li><strong>Secure sandbox</strong> with configurable permissions</li>
<li><strong>TypeScript support</strong> out of the box</li>
<li><strong>NPM package</strong> ecosystem access</li>
<li><strong>Modern JavaScript</strong> features (ES2022+)</li>
<li><strong>Async/await</strong> support for non-blocking operations</li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<h3 id="creating-a-javascript-actor"><a class="header" href="#creating-a-javascript-actor">Creating a JavaScript Actor</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_script::{ScriptActor, LanguageEngine};
use reflow_network::{Network, NetworkConfig};
use reflow_network::connector::{Connector, ConnectionPoint, InitialPacket};
use reflow_network::message::Message;

// Create script actor with JavaScript/Deno engine
let script_content = r#"
function process(inputs, context) {
    const data = inputs.data;
    
    if (typeof data === 'string') {
        return {
            result: data.toUpperCase(),
            length: data.length,
            timestamp: new Date().toISOString()
        };
    }
    
    return { error: 'Expected string input' };
}
"#;

let actor = ScriptActor::new(LanguageEngine::JavaScript, script_content.to_string());

// Register and use in network
let mut network = Network::new(NetworkConfig::default());
network.register_actor("js_processor", actor)?;
network.add_node("script1", "js_processor")?;

// Connect to other actors
network.add_connection(Connector {
    from: ConnectionPoint {
        actor: "source_actor".to_owned(),
        port: "output".to_owned(),
        ..Default::default()
    },
    to: ConnectionPoint {
        actor: "script1".to_owned(),
        port: "data".to_owned(),
        ..Default::default()
    },
});
<span class="boring">}</span></code></pre></pre>
<h3 id="javascript-actor-script"><a class="header" href="#javascript-actor-script">JavaScript Actor Script</a></h3>
<pre><code class="language-javascript">// script.js - Simple transformation actor
function process(inputs, context) {
    const data = inputs.data;
    
    if (typeof data === 'string') {
        return {
            result: data.toUpperCase(),
            length: data.length,
            timestamp: new Date().toISOString()
        };
    }
    
    return { error: 'Expected string input' };
}

// Export for Reflow
exports.process = process;
</code></pre>
<h2 id="actor-function-signature"><a class="header" href="#actor-function-signature">Actor Function Signature</a></h2>
<h3 id="input-parameters"><a class="header" href="#input-parameters">Input Parameters</a></h3>
<pre><code class="language-javascript">function process(inputs, context) {
    // inputs: Object containing input port data
    // context: Actor execution context
}
</code></pre>
<h3 id="context-object"><a class="header" href="#context-object">Context Object</a></h3>
<pre><code class="language-javascript">const context = {
    // Actor configuration
    config: {
        // Custom configuration values
    },
    
    // Utility functions
    log: (level, message) =&gt; {},
    
    // State management
    getState: () =&gt; {},
    setState: (state) =&gt; {},
    
    // Metrics
    incrementCounter: (name) =&gt; {},
    recordTimer: (name, duration) =&gt; {},
};
</code></pre>
<h3 id="return-values"><a class="header" href="#return-values">Return Values</a></h3>
<pre><code class="language-javascript">// Success - return output object
return {
    output1: "value1",
    output2: 42,
    status: "success"
};

// Error - return error object
return {
    error: "Something went wrong",
    code: 500
};

// Async operations
async function process(inputs, context) {
    const result = await fetchData(inputs.url);
    return { data: result };
}
</code></pre>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<h3 id="supported-types"><a class="header" href="#supported-types">Supported Types</a></h3>
<pre><code class="language-javascript">// Primitive types
return {
    string: "hello",
    number: 42,
    boolean: true,
    null: null,
};

// Complex types
return {
    array: [1, 2, 3],
    object: { key: "value" },
    nested: {
        array: [{ id: 1 }, { id: 2 }],
        metadata: { timestamp: Date.now() }
    }
};

// Binary data
return {
    buffer: new Uint8Array([1, 2, 3, 4])
};
</code></pre>
<h2 id="state-management-3"><a class="header" href="#state-management-3">State Management</a></h2>
<h3 id="persistent-state"><a class="header" href="#persistent-state">Persistent State</a></h3>
<pre><code class="language-javascript">function process(inputs, context) {
    // Get current state
    const state = context.getState() || { counter: 0 };
    
    // Update state
    state.counter += 1;
    state.lastInput = inputs.data;
    
    // Save state
    context.setState(state);
    
    return {
        count: state.counter,
        data: state.lastInput
    };
}
</code></pre>
<h2 id="async-operations"><a class="header" href="#async-operations">Async Operations</a></h2>
<h3 id="http-requests"><a class="header" href="#http-requests">HTTP Requests</a></h3>
<pre><code class="language-javascript">async function process(inputs, context) {
    try {
        const response = await fetch(inputs.url, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (!response.ok) {
            return { error: `HTTP ${response.status}` };
        }
        
        const data = await response.json();
        return { result: data };
        
    } catch (error) {
        return { error: error.message };
    }
}
</code></pre>
<h3 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h3>
<pre><code class="language-javascript">async function process(inputs, context) {
    try {
        // Read file (requires --allow-read permission)
        const content = await Deno.readTextFile(inputs.filename);
        
        // Process content
        const lines = content.split('\n').length;
        
        return {
            content: content,
            lineCount: lines
        };
        
    } catch (error) {
        return { error: `File error: ${error.message}` };
    }
}
</code></pre>
<h2 id="npm-package-support"><a class="header" href="#npm-package-support">NPM Package Support</a></h2>
<h3 id="using-external-packages"><a class="header" href="#using-external-packages">Using External Packages</a></h3>
<pre><code class="language-javascript">// Import from NPM
import { format } from "https://deno.land/x/date_fns/index.js";
import _ from "https://cdn.skypack.dev/lodash";

function process(inputs, context) {
    const now = new Date();
    const formatted = format(now, 'yyyy-MM-dd HH:mm:ss');
    
    const processed = _.map(inputs.data, item =&gt; ({
        ...item,
        timestamp: formatted
    }));
    
    return { result: processed };
}
</code></pre>
<h3 id="package-configuration"><a class="header" href="#package-configuration">Package Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = ScriptConfig {
    environment: ScriptEnvironment::SYSTEM,
    runtime: ScriptRuntime::JavaScript,
    source: script_source,
    entry_point: "process".to_string(),
    packages: Some(vec![
        "https://deno.land/x/date_fns@v2.29.3/index.js".to_string(),
        "https://cdn.skypack.dev/lodash@4.17.21".to_string(),
    ]),
};
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-9"><a class="header" href="#error-handling-9">Error Handling</a></h2>
<h3 id="error-patterns"><a class="header" href="#error-patterns">Error Patterns</a></h3>
<pre><code class="language-javascript">function process(inputs, context) {
    try {
        // Validate inputs
        if (!inputs.data) {
            return { error: "Missing required 'data' input" };
        }
        
        if (typeof inputs.data !== 'string') {
            return { 
                error: "Invalid input type",
                expected: "string",
                received: typeof inputs.data
            };
        }
        
        // Process data
        const result = inputs.data.toLowerCase();
        
        if (result.length === 0) {
            return { 
                error: "Empty result",
                warning: "Input data was empty after processing"
            };
        }
        
        return { result: result };
        
    } catch (error) {
        // Log error for debugging
        context.log('error', `Processing failed: ${error.message}`);
        
        return {
            error: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
        };
    }
}
</code></pre>
<h2 id="security-and-permissions"><a class="header" href="#security-and-permissions">Security and Permissions</a></h2>
<h3 id="permission-configuration"><a class="header" href="#permission-configuration">Permission Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_script::PermissionConfig;

let config = ScriptConfig {
    // ... other fields
    permissions: Some(PermissionConfig {
        allow_net: vec!["https://api.example.com".to_string()],
        allow_read: vec!["/tmp/data".to_string()],
        allow_write: vec!["/tmp/output".to_string()],
        allow_run: false,
        allow_env: false,
    }),
};
<span class="boring">}</span></code></pre></pre>
<h3 id="safe-practices"><a class="header" href="#safe-practices">Safe Practices</a></h3>
<pre><code class="language-javascript">function process(inputs, context) {
    // Validate and sanitize inputs
    const sanitized = sanitizeInput(inputs.userInput);
    
    // Use try-catch for external operations
    try {
        return processData(sanitized);
    } catch (error) {
        // Don't expose internal details
        return { error: "Processing failed" };
    }
}

function sanitizeInput(input) {
    if (typeof input !== 'string') return '';
    
    // Remove potentially dangerous characters
    return input
        .replace(/[&lt;&gt;]/g, '')
        .trim()
        .substring(0, 1000); // Limit length
}
</code></pre>
<h2 id="performance-optimization-3"><a class="header" href="#performance-optimization-3">Performance Optimization</a></h2>
<h3 id="efficient-processing"><a class="header" href="#efficient-processing">Efficient Processing</a></h3>
<pre><code class="language-javascript">// Use streaming for large data
async function process(inputs, context) {
    const results = [];
    
    // Process in chunks to avoid memory issues
    const chunkSize = 100;
    const data = inputs.data || [];
    
    for (let i = 0; i &lt; data.length; i += chunkSize) {
        const chunk = data.slice(i, i + chunkSize);
        const processed = await processChunk(chunk);
        results.push(...processed);
        
        // Allow other actors to run
        if (i % 1000 === 0) {
            await new Promise(resolve =&gt; setTimeout(resolve, 0));
        }
    }
    
    return { results: results };
}

async function processChunk(chunk) {
    return chunk.map(item =&gt; ({
        ...item,
        processed: true,
        timestamp: Date.now()
    }));
}
</code></pre>
<h3 id="caching"><a class="header" href="#caching">Caching</a></h3>
<pre><code class="language-javascript">// Simple in-memory cache
const cache = new Map();

function process(inputs, context) {
    const key = inputs.cacheKey;
    
    // Check cache first
    if (cache.has(key)) {
        context.log('info', `Cache hit for key: ${key}`);
        return { result: cache.get(key), fromCache: true };
    }
    
    // Expensive computation
    const result = expensiveOperation(inputs.data);
    
    // Store in cache with TTL
    cache.set(key, result);
    setTimeout(() =&gt; cache.delete(key), 60000); // 1 minute TTL
    
    return { result: result, fromCache: false };
}
</code></pre>
<h2 id="testing-javascript-actors"><a class="header" href="#testing-javascript-actors">Testing JavaScript Actors</a></h2>
<h3 id="unit-testing-1"><a class="header" href="#unit-testing-1">Unit Testing</a></h3>
<pre><code class="language-javascript">// test_actor.js
import { assertEquals } from "https://deno.land/std/testing/asserts.ts";

// Import your actor function
import { process } from "./my_actor.js";

Deno.test("actor processes string input", () =&gt; {
    const inputs = { data: "hello world" };
    const context = { 
        log: () =&gt; {},
        getState: () =&gt; ({}),
        setState: () =&gt; {}
    };
    
    const result = process(inputs, context);
    
    assertEquals(result.result, "HELLO WORLD");
    assertEquals(result.length, 11);
});

Deno.test("actor handles missing input", () =&gt; {
    const inputs = {};
    const context = { log: () =&gt; {} };
    
    const result = process(inputs, context);
    
    assertEquals(result.error, "Expected string input");
});
</code></pre>
<h3 id="integration-testing-2"><a class="header" href="#integration-testing-2">Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_javascript_actor_integration() {
    let script = include_str!("test_script.js");
    let config = ScriptConfig {
        environment: ScriptEnvironment::SYSTEM,
        runtime: ScriptRuntime::JavaScript,
        source: script.as_bytes().to_vec(),
        entry_point: "process".to_string(),
        packages: None,
    };
    
    let actor = ScriptActor::new(config);
    
    // Test actor behavior
    let inputs = HashMap::from([
        ("data".to_string(), Message::String("test".to_string()))
    ]);
    
    let result = test_actor_behavior(actor, inputs).await;
    assert!(result.is_ok());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="data-transformation"><a class="header" href="#data-transformation">Data Transformation</a></h3>
<pre><code class="language-javascript">// Transform JSON data
function process(inputs, context) {
    const data = inputs.json_data;
    
    if (!Array.isArray(data)) {
        return { error: "Expected array input" };
    }
    
    const transformed = data.map(item =&gt; ({
        id: item.id,
        name: item.name?.toUpperCase(),
        email: item.email?.toLowerCase(),
        createdAt: new Date(item.created_at).toISOString(),
        tags: item.tags?.map(tag =&gt; tag.toLowerCase()) || []
    }));
    
    return {
        data: transformed,
        count: transformed.length,
        processedAt: new Date().toISOString()
    };
}
</code></pre>
<h3 id="api-integration"><a class="header" href="#api-integration">API Integration</a></h3>
<pre><code class="language-javascript">async function process(inputs, context) {
    const { endpoint, payload, authToken } = inputs;
    
    try {
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify(payload)
        });
        
        const result = await response.json();
        
        return {
            status: response.status,
            data: result,
            success: response.ok
        };
        
    } catch (error) {
        return {
            error: error.message,
            success: false
        };
    }
}
</code></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="code-organization"><a class="header" href="#code-organization">Code Organization</a></h3>
<pre><code class="language-javascript">// Separate concerns into functions
function process(inputs, context) {
    try {
        const validated = validateInputs(inputs);
        const processed = processData(validated);
        const formatted = formatOutput(processed);
        
        return { result: formatted };
    } catch (error) {
        return handleError(error, context);
    }
}

function validateInputs(inputs) {
    if (!inputs.data) throw new Error("Missing data");
    return inputs;
}

function processData(inputs) {
    // Main processing logic
    return inputs.data.map(transform);
}

function formatOutput(data) {
    return {
        items: data,
        timestamp: new Date().toISOString()
    };
}

function handleError(error, context) {
    context.log('error', error.message);
    return { error: "Processing failed" };
}
</code></pre>
<h3 id="resource-management"><a class="header" href="#resource-management">Resource Management</a></h3>
<pre><code class="language-javascript">// Clean up resources
function process(inputs, context) {
    const resources = [];
    
    try {
        // Acquire resources
        const db = openDatabase(inputs.connectionString);
        resources.push(db);
        
        const file = openFile(inputs.filename);
        resources.push(file);
        
        // Use resources
        const result = processWithResources(db, file);
        
        return { result: result };
        
    } finally {
        // Always clean up
        resources.forEach(resource =&gt; {
            try {
                resource.close();
            } catch (e) {
                // Log but don't throw
                console.error("Cleanup error:", e);
            }
        });
    }
}
</code></pre>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<ul>
<li><a href="scripting/javascript/../python/python-engine.html">Python Runtime</a> - Python scripting support</li>
<li><a href="scripting/javascript/../wasm/wasm-plugins.html">WebAssembly Runtime</a> - WASM plugin system</li>
<li><a href="scripting/javascript/./script-configuration.html">Script Configuration</a> - Advanced configuration</li>
<li><a href="scripting/javascript/../../api/actors/creating-actors.html">Creating Actors</a> - Actor development guide</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-visual-graph-editor"><a class="header" href="#building-a-visual-graph-editor">Building a Visual Graph Editor</a></h1>
<p>Complete tutorial for creating a visual graph editor using Reflow's WebAssembly APIs.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>This tutorial walks through building a complete visual graph editor that allows users to:</p>
<ul>
<li>Create and edit graphs visually</li>
<li>Add nodes by dragging from a component palette</li>
<li>Connect nodes with visual links</li>
<li>Configure node properties through forms</li>
<li>Execute workflows and see real-time results</li>
<li>Save and load graph files</li>
</ul>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<ul>
<li>Basic HTML, CSS, and JavaScript knowledge</li>
<li>Understanding of Reflow's graph concepts</li>
<li>Node.js and npm installed</li>
</ul>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<h3 id="1-initialize-project"><a class="header" href="#1-initialize-project">1. Initialize Project</a></h3>
<pre><code class="language-bash">mkdir reflow-visual-editor
cd reflow-visual-editor
npm init -y
</code></pre>
<h3 id="2-install-dependencies"><a class="header" href="#2-install-dependencies">2. Install Dependencies</a></h3>
<pre><code class="language-bash"># Core dependencies
npm install reflow-network-wasm

# Development dependencies
npm install --save-dev webpack webpack-cli webpack-dev-server
npm install --save-dev html-webpack-plugin css-loader style-loader
npm install --save-dev @babel/core @babel/preset-env babel-loader
</code></pre>
<h3 id="3-project-structure"><a class="header" href="#3-project-structure">3. Project Structure</a></h3>
<pre><code>reflow-visual-editor/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ index.js
â”‚   â”œâ”€â”€ style.css
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Graph.js
â”‚   â”‚   â”œâ”€â”€ Node.js
â”‚   â”‚   â”œâ”€â”€ Connection.js
â”‚   â”‚   â”œâ”€â”€ Palette.js
â”‚   â”‚   â””â”€â”€ PropertyPanel.js
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ drag-drop.js
â”‚   â”‚   â”œâ”€â”€ events.js
â”‚   â”‚   â””â”€â”€ serialization.js
â”‚   â””â”€â”€ workers/
â”‚       â””â”€â”€ execution-worker.js
â”œâ”€â”€ webpack.config.js
â””â”€â”€ package.json
</code></pre>
<h2 id="core-implementation"><a class="header" href="#core-implementation">Core Implementation</a></h2>
<h3 id="1-basic-html-structure"><a class="header" href="#1-basic-html-structure">1. Basic HTML Structure</a></h3>
<pre><code class="language-html">&lt;!-- src/index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Reflow Visual Editor&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;header class="toolbar"&gt;
            &lt;div class="toolbar-group"&gt;
                &lt;button id="new-graph"&gt;New&lt;/button&gt;
                &lt;button id="open-graph"&gt;Open&lt;/button&gt;
                &lt;button id="save-graph"&gt;Save&lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="toolbar-group"&gt;
                &lt;button id="run-graph"&gt;Run&lt;/button&gt;
                &lt;button id="stop-graph"&gt;Stop&lt;/button&gt;
                &lt;button id="validate-graph"&gt;Validate&lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="toolbar-group"&gt;
                &lt;button id="auto-layout"&gt;Auto Layout&lt;/button&gt;
                &lt;button id="zoom-fit"&gt;Zoom to Fit&lt;/button&gt;
            &lt;/div&gt;
        &lt;/header&gt;
        
        &lt;div class="editor-container"&gt;
            &lt;div class="sidebar"&gt;
                &lt;div class="component-palette" id="palette"&gt;
                    &lt;h3&gt;Components&lt;/h3&gt;
                    &lt;div class="palette-category" data-category="data"&gt;
                        &lt;h4&gt;Data Operations&lt;/h4&gt;
                        &lt;div class="palette-items"&gt;
                            &lt;!-- Component items will be populated by JavaScript --&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="palette-category" data-category="flow"&gt;
                        &lt;h4&gt;Flow Control&lt;/h4&gt;
                        &lt;div class="palette-items"&gt;
                            &lt;!-- Component items will be populated by JavaScript --&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="palette-category" data-category="io"&gt;
                        &lt;h4&gt;Input/Output&lt;/h4&gt;
                        &lt;div class="palette-items"&gt;
                            &lt;!-- Component items will be populated by JavaScript --&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class="graph-canvas-container"&gt;
                &lt;svg id="graph-canvas" class="graph-canvas"&gt;
                    &lt;defs&gt;
                        &lt;marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                refX="10" refY="3.5" orient="auto"&gt;
                            &lt;polygon points="0 0, 10 3.5, 0 7" fill="#666" /&gt;
                        &lt;/marker&gt;
                    &lt;/defs&gt;
                    &lt;g id="connections-layer"&gt;&lt;/g&gt;
                    &lt;g id="nodes-layer"&gt;&lt;/g&gt;
                &lt;/svg&gt;
                
                &lt;div class="canvas-overlay"&gt;
                    &lt;div class="zoom-controls"&gt;
                        &lt;button id="zoom-in"&gt;+&lt;/button&gt;
                        &lt;button id="zoom-out"&gt;-&lt;/button&gt;
                        &lt;span id="zoom-level"&gt;100%&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class="properties-panel" id="properties-panel"&gt;
                &lt;h3&gt;Properties&lt;/h3&gt;
                &lt;div id="property-form"&gt;
                    &lt;p&gt;Select a node to edit properties&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="status-bar"&gt;
            &lt;span id="status-text"&gt;Ready&lt;/span&gt;
            &lt;div class="status-indicators"&gt;
                &lt;span id="node-count"&gt;0 nodes&lt;/span&gt;
                &lt;span id="connection-count"&gt;0 connections&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="2-main-application-class"><a class="header" href="#2-main-application-class">2. Main Application Class</a></h3>
<pre><code class="language-javascript">// src/index.js
import { Graph } from 'reflow-network-wasm';
import GraphEditor from './components/Graph.js';
import ComponentPalette from './components/Palette.js';
import PropertyPanel from './components/PropertyPanel.js';
import './style.css';

class VisualEditor {
    constructor() {
        this.graph = new Graph("VisualWorkflow", true, {});
        this.graphEditor = new GraphEditor(this.graph, '#graph-canvas');
        this.palette = new ComponentPalette('#palette');
        this.propertyPanel = new PropertyPanel('#properties-panel');
        
        this.selectedNode = null;
        this.isExecuting = false;
        
        this.initializeEventListeners();
        this.initializeComponents();
    }
    
    initializeEventListeners() {
        // Toolbar events
        document.getElementById('new-graph').addEventListener('click', () =&gt; this.newGraph());
        document.getElementById('open-graph').addEventListener('click', () =&gt; this.openGraph());
        document.getElementById('save-graph').addEventListener('click', () =&gt; this.saveGraph());
        document.getElementById('run-graph').addEventListener('click', () =&gt; this.runGraph());
        document.getElementById('stop-graph').addEventListener('click', () =&gt; this.stopGraph());
        document.getElementById('validate-graph').addEventListener('click', () =&gt; this.validateGraph());
        document.getElementById('auto-layout').addEventListener('click', () =&gt; this.autoLayout());
        document.getElementById('zoom-fit').addEventListener('click', () =&gt; this.zoomToFit());
        
        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', () =&gt; this.graphEditor.zoomIn());
        document.getElementById('zoom-out').addEventListener('click', () =&gt; this.graphEditor.zoomOut());
        
        // Graph events
        this.graphEditor.on('nodeSelected', (node) =&gt; this.selectNode(node));
        this.graphEditor.on('nodeDeselected', () =&gt; this.deselectNode());
        this.graphEditor.on('nodeAdded', (node) =&gt; this.updateStatus());
        this.graphEditor.on('nodeRemoved', (node) =&gt; this.updateStatus());
        this.graphEditor.on('connectionAdded', (connection) =&gt; this.updateStatus());
        this.graphEditor.on('connectionRemoved', (connection) =&gt; this.updateStatus());
        
        // Palette events
        this.palette.on('componentDragStart', (component) =&gt; this.handleComponentDrag(component));
        
        // Property panel events
        this.propertyPanel.on('propertyChanged', (property, value) =&gt; this.updateNodeProperty(property, value));
    }
    
    initializeComponents() {
        this.palette.loadComponents([
            // Data Operations
            { 
                name: 'Map', 
                category: 'data', 
                component: 'MapActor',
                description: 'Transform data using a function',
                icon: 'ğŸ”„',
                ports: {
                    input: [{ name: 'input', type: 'any' }],
                    output: [{ name: 'output', type: 'any' }]
                }
            },
            { 
                name: 'Filter', 
                category: 'data', 
                component: 'FilterActor',
                description: 'Filter data based on conditions',
                icon: 'ğŸ”',
                ports: {
                    input: [{ name: 'input', type: 'any' }],
                    output: [{ name: 'output', type: 'any' }]
                }
            },
            { 
                name: 'Aggregate', 
                category: 'data', 
                component: 'AggregateActor',
                description: 'Aggregate multiple inputs',
                icon: 'ğŸ“Š',
                ports: {
                    input: [{ name: 'input', type: 'any' }],
                    output: [{ name: 'output', type: 'any' }]
                }
            },
            
            // Flow Control
            { 
                name: 'Conditional', 
                category: 'flow', 
                component: 'ConditionalActor',
                description: 'Branch based on condition',
                icon: 'ğŸ”€',
                ports: {
                    input: [{ name: 'input', type: 'any' }],
                    output: [
                        { name: 'true', type: 'any' },
                        { name: 'false', type: 'any' }
                    ]
                }
            },
            { 
                name: 'Merge', 
                category: 'flow', 
                component: 'MergeActor',
                description: 'Merge multiple inputs',
                icon: 'ğŸ”—',
                ports: {
                    input: [
                        { name: 'input1', type: 'any' },
                        { name: 'input2', type: 'any' }
                    ],
                    output: [{ name: 'output', type: 'any' }]
                }
            },
            
            // Input/Output
            { 
                name: 'HTTP Request', 
                category: 'io', 
                component: 'HttpRequestActor',
                description: 'Make HTTP requests',
                icon: 'ğŸŒ',
                ports: {
                    input: [{ name: 'url', type: 'string' }],
                    output: [
                        { name: 'response', type: 'object' },
                        { name: 'error', type: 'object' }
                    ]
                }
            },
            { 
                name: 'Logger', 
                category: 'io', 
                component: 'LoggerActor',
                description: 'Log messages',
                icon: 'ğŸ“',
                ports: {
                    input: [{ name: 'message', type: 'any' }],
                    output: []
                }
            }
        ]);
        
        this.updateStatus();
    }
    
    newGraph() {
        if (this.hasUnsavedChanges()) {
            if (!confirm('You have unsaved changes. Create a new graph anyway?')) {
                return;
            }
        }
        
        this.graph = new Graph("VisualWorkflow", true, {});
        this.graphEditor.setGraph(this.graph);
        this.deselectNode();
        this.updateStatus();
        this.setStatus('New graph created');
    }
    
    async openGraph() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) =&gt; {
            const file = e.target.files[0];
            if (file) {
                try {
                    const text = await file.text();
                    const graphData = JSON.parse(text);
                    this.graph = Graph.fromJson(graphData);
                    this.graphEditor.setGraph(this.graph);
                    this.deselectNode();
                    this.updateStatus();
                    this.setStatus(`Opened: ${file.name}`);
                } catch (error) {
                    alert(`Error opening file: ${error.message}`);
                }
            }
        };
        input.click();
    }
    
    saveGraph() {
        try {
            const graphData = this.graph.toJson();
            const blob = new Blob([JSON.stringify(graphData, null, 2)], 
                                { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${this.graph.name || 'workflow'}.json`;
            a.click();
            
            URL.revokeObjectURL(url);
            this.setStatus('Graph saved');
        } catch (error) {
            alert(`Error saving graph: ${error.message}`);
        }
    }
    
    async runGraph() {
        try {
            this.setStatus('Validating graph...');
            const validation = this.graph.validate();
            
            if (!validation.isValid) {
                alert(`Graph validation failed:\n${validation.errors.join('\n')}`);
                return;
            }
            
            this.setStatus('Starting execution...');
            this.isExecuting = true;
            
            // Use Web Worker for graph execution
            if (!this.executionWorker) {
                this.executionWorker = new Worker('./workers/execution-worker.js');
                this.executionWorker.onmessage = (e) =&gt; this.handleExecutionMessage(e);
            }
            
            this.executionWorker.postMessage({
                type: 'execute',
                graph: this.graph.toJson()
            });
            
            this.updateToolbarState();
        } catch (error) {
            this.setStatus(`Execution error: ${error.message}`);
            this.isExecuting = false;
            this.updateToolbarState();
        }
    }
    
    stopGraph() {
        if (this.executionWorker) {
            this.executionWorker.postMessage({ type: 'stop' });
        }
        this.isExecuting = false;
        this.updateToolbarState();
        this.setStatus('Execution stopped');
    }
    
    validateGraph() {
        try {
            const validation = this.graph.validate();
            
            if (validation.isValid) {
                this.setStatus('Graph is valid');
                // Highlight valid state in UI
                this.graphEditor.highlightValidation(validation);
            } else {
                this.setStatus(`Validation failed: ${validation.errors.length} errors`);
                // Show validation errors in UI
                this.graphEditor.showValidationErrors(validation.errors);
                
                // Show detailed errors in console or modal
                console.log('Validation errors:', validation.errors);
            }
        } catch (error) {
            this.setStatus(`Validation error: ${error.message}`);
        }
    }
    
    autoLayout() {
        try {
            this.setStatus('Calculating layout...');
            const positions = this.graph.calculateLayout({
                algorithm: 'hierarchical',
                nodeSpacing: 120,
                layerSpacing: 80
            });
            
            this.graphEditor.animateToPositions(positions);
            this.setStatus('Layout applied');
        } catch (error) {
            this.setStatus(`Layout error: ${error.message}`);
        }
    }
    
    zoomToFit() {
        this.graphEditor.zoomToFit();
        this.setStatus('Zoomed to fit');
    }
    
    selectNode(node) {
        this.selectedNode = node;
        this.propertyPanel.showNodeProperties(node);
        this.graphEditor.highlightNode(node.id);
    }
    
    deselectNode() {
        this.selectedNode = null;
        this.propertyPanel.clear();
        this.graphEditor.clearHighlight();
    }
    
    updateNodeProperty(property, value) {
        if (this.selectedNode) {
            this.selectedNode.metadata[property] = value;
            this.graphEditor.updateNode(this.selectedNode);
            this.setStatus(`Updated ${property}`);
        }
    }
    
    handleComponentDrag(component) {
        this.graphEditor.enableDropZone(component);
    }
    
    handleExecutionMessage(e) {
        const { type, data } = e.data;
        
        switch (type) {
            case 'progress':
                this.setStatus(`Executing... ${data.progress}%`);
                this.graphEditor.updateExecutionProgress(data);
                break;
                
            case 'completed':
                this.setStatus('Execution completed successfully');
                this.isExecuting = false;
                this.updateToolbarState();
                this.graphEditor.showExecutionResults(data.results);
                break;
                
            case 'error':
                this.setStatus(`Execution failed: ${data.error}`);
                this.isExecuting = false;
                this.updateToolbarState();
                this.graphEditor.showExecutionError(data);
                break;
                
            case 'nodeExecuted':
                this.graphEditor.highlightExecutedNode(data.nodeId);
                break;
        }
    }
    
    updateStatus() {
        const nodeCount = this.graph.getNodes().length;
        const connectionCount = this.graph.getConnections().length;
        
        document.getElementById('node-count').textContent = `${nodeCount} nodes`;
        document.getElementById('connection-count').textContent = `${connectionCount} connections`;
    }
    
    updateToolbarState() {
        document.getElementById('run-graph').disabled = this.isExecuting;
        document.getElementById('stop-graph').disabled = !this.isExecuting;
    }
    
    setStatus(message) {
        document.getElementById('status-text').textContent = message;
        console.log(`Status: ${message}`);
    }
    
    hasUnsavedChanges() {
        // Implement change tracking logic
        return false;
    }
}

// Initialize application when DOM is ready
document.addEventListener('DOMContentLoaded', () =&gt; {
    new VisualEditor();
});
</code></pre>
<h3 id="3-graph-editor-component"><a class="header" href="#3-graph-editor-component">3. Graph Editor Component</a></h3>
<pre><code class="language-javascript">// src/components/Graph.js
import { EventEmitter } from '../utils/events.js';
import Node from './Node.js';
import Connection from './Connection.js';

class GraphEditor extends EventEmitter {
    constructor(graph, canvasSelector) {
        super();
        this.graph = graph;
        this.canvas = document.querySelector(canvasSelector);
        this.nodesLayer = this.canvas.querySelector('#nodes-layer');
        this.connectionsLayer = this.canvas.querySelector('#connections-layer');
        
        this.nodes = new Map();
        this.connections = new Map();
        this.scale = 1;
        this.panX = 0;
        this.panY = 0;
        
        this.dragState = null;
        this.connectionDragState = null;
        
        this.initializeEventListeners();
        this.updateView();
    }
    
    initializeEventListeners() {
        // Mouse events for panning and selection
        this.canvas.addEventListener('mousedown', (e) =&gt; this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) =&gt; this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) =&gt; this.handleMouseUp(e));
        this.canvas.addEventListener('wheel', (e) =&gt; this.handleWheel(e));
        
        // Drag and drop for components
        this.canvas.addEventListener('dragover', (e) =&gt; e.preventDefault());
        this.canvas.addEventListener('drop', (e) =&gt; this.handleDrop(e));
        
        // Keyboard events
        document.addEventListener('keydown', (e) =&gt; this.handleKeyDown(e));
    }
    
    setGraph(graph) {
        this.graph = graph;
        this.updateView();
    }
    
    updateView() {
        this.clearView();
        this.renderConnections();
        this.renderNodes();
    }
    
    clearView() {
        this.nodesLayer.innerHTML = '';
        this.connectionsLayer.innerHTML = '';
        this.nodes.clear();
        this.connections.clear();
    }
    
    renderNodes() {
        const graphNodes = this.graph.getNodes();
        
        graphNodes.forEach(nodeData =&gt; {
            const node = new Node(nodeData, this);
            this.nodes.set(nodeData.id, node);
            this.nodesLayer.appendChild(node.element);
        });
    }
    
    renderConnections() {
        const graphConnections = this.graph.getConnections();
        
        graphConnections.forEach(connectionData =&gt; {
            const connection = new Connection(connectionData, this);
            this.connections.set(connection.id, connection);
            this.connectionsLayer.appendChild(connection.element);
        });
    }
    
    addNode(componentType, position) {
        const nodeId = `node_${Date.now()}`;
        const nodeData = {
            id: nodeId,
            component: componentType.component,
            metadata: {
                x: position.x,
                y: position.y,
                label: componentType.name,
                ...componentType.defaultProperties
            }
        };
        
        this.graph.addNode(nodeId, componentType.component, nodeData.metadata);
        
        const node = new Node(nodeData, this);
        this.nodes.set(nodeId, node);
        this.nodesLayer.appendChild(node.element);
        
        this.emit('nodeAdded', nodeData);
        return node;
    }
    
    removeNode(nodeId) {
        const node = this.nodes.get(nodeId);
        if (node) {
            // Remove all connections to this node
            const connections = this.graph.getConnections()
                .filter(conn =&gt; conn.fromNode === nodeId || conn.toNode === nodeId);
            
            connections.forEach(conn =&gt; this.removeConnection(conn.id));
            
            // Remove node from graph
            this.graph.removeNode(nodeId);
            
            // Remove from UI
            node.element.remove();
            this.nodes.delete(nodeId);
            
            this.emit('nodeRemoved', { id: nodeId });
        }
    }
    
    addConnection(fromNode, fromPort, toNode, toPort) {
        try {
            const connectionId = this.graph.addConnection(fromNode, fromPort, toNode, toPort, {});
            
            const connectionData = {
                id: connectionId,
                fromNode,
                fromPort,
                toNode,
                toPort
            };
            
            const connection = new Connection(connectionData, this);
            this.connections.set(connectionId, connection);
            this.connectionsLayer.appendChild(connection.element);
            
            this.emit('connectionAdded', connectionData);
            return connection;
        } catch (error) {
            console.error('Failed to create connection:', error);
            throw error;
        }
    }
    
    removeConnection(connectionId) {
        const connection = this.connections.get(connectionId);
        if (connection) {
            this.graph.removeConnection(connectionId);
            connection.element.remove();
            this.connections.delete(connectionId);
            
            this.emit('connectionRemoved', { id: connectionId });
        }
    }
    
    getNodePosition(nodeId) {
        const node = this.nodes.get(nodeId);
        return node ? node.getPosition() : null;
    }
    
    updateNodePosition(nodeId, position) {
        const node = this.nodes.get(nodeId);
        if (node) {
            node.setPosition(position);
            this.updateConnectionsForNode(nodeId);
        }
    }
    
    updateConnectionsForNode(nodeId) {
        this.connections.forEach(connection =&gt; {
            if (connection.fromNode === nodeId || connection.toNode === nodeId) {
                connection.updatePath();
            }
        });
    }
    
    handleMouseDown(e) {
        if (e.target === this.canvas) {
            this.startPanning(e);
        }
    }
    
    handleMouseMove(e) {
        if (this.dragState?.type === 'pan') {
            this.updatePanning(e);
        } else if (this.connectionDragState) {
            this.updateConnectionDrag(e);
        }
    }
    
    handleMouseUp(e) {
        if (this.dragState?.type === 'pan') {
            this.endPanning();
        } else if (this.connectionDragState) {
            this.endConnectionDrag(e);
        }
    }
    
    handleWheel(e) {
        e.preventDefault();
        const delta = e.deltaY &gt; 0 ? 0.9 : 1.1;
        this.zoom(delta, { x: e.clientX, y: e.clientY });
    }
    
    handleDrop(e) {
        e.preventDefault();
        const componentData = JSON.parse(e.dataTransfer.getData('component'));
        const rect = this.canvas.getBoundingClientRect();
        const position = this.screenToWorld({
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        });
        
        this.addNode(componentData, position);
    }
    
    handleKeyDown(e) {
        if (e.key === 'Delete' &amp;&amp; this.selectedNode) {
            this.removeNode(this.selectedNode.id);
        }
    }
    
    startPanning(e) {
        this.dragState = {
            type: 'pan',
            startX: e.clientX,
            startY: e.clientY,
            initialPanX: this.panX,
            initialPanY: this.panY
        };
    }
    
    updatePanning(e) {
        if (this.dragState?.type === 'pan') {
            const dx = e.clientX - this.dragState.startX;
            const dy = e.clientY - this.dragState.startY;
            
            this.panX = this.dragState.initialPanX + dx;
            this.panY = this.dragState.initialPanY + dy;
            
            this.updateTransform();
        }
    }
    
    endPanning() {
        this.dragState = null;
    }
    
    startConnectionDrag(fromNode, fromPort, startPosition) {
        this.connectionDragState = {
            fromNode,
            fromPort,
            startPosition,
            currentPosition: startPosition
        };
        
        // Create temporary connection line
        this.createTempConnectionLine();
    }
    
    updateConnectionDrag(e) {
        if (this.connectionDragState) {
            const rect = this.canvas.getBoundingClientRect();
            this.connectionDragState.currentPosition = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
            
            this.updateTempConnectionLine();
        }
    }
    
    endConnectionDrag(e) {
        if (this.connectionDragState) {
            // Find target node and port
            const target = this.findConnectionTarget(e);
            
            if (target) {
                try {
                    this.addConnection(
                        this.connectionDragState.fromNode,
                        this.connectionDragState.fromPort,
                        target.nodeId,
                        target.portName
                    );
                } catch (error) {
                    console.error('Connection failed:', error);
                }
            }
            
            this.removeTempConnectionLine();
            this.connectionDragState = null;
        }
    }
    
    zoom(factor, center) {
        const newScale = Math.max(0.1, Math.min(3, this.scale * factor));
        
        if (center) {
            const worldCenter = this.screenToWorld(center);
            this.scale = newScale;
            const newScreenCenter = this.worldToScreen(worldCenter);
            
            this.panX += center.x - newScreenCenter.x;
            this.panY += center.y - newScreenCenter.y;
        } else {
            this.scale = newScale;
        }
        
        this.updateTransform();
        this.updateZoomDisplay();
    }
    
    zoomIn() {
        this.zoom(1.2);
    }
    
    zoomOut() {
        this.zoom(0.8);
    }
    
    zoomToFit() {
        if (this.nodes.size === 0) return;
        
        // Calculate bounding box of all nodes
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        this.nodes.forEach(node =&gt; {
            const pos = node.getPosition();
            minX = Math.min(minX, pos.x);
            minY = Math.min(minY, pos.y);
            maxX = Math.max(maxX, pos.x + 120); // Node width
            maxY = Math.max(maxY, pos.y + 80);  // Node height
        });
        
        const padding = 50;
        const contentWidth = maxX - minX + 2 * padding;
        const contentHeight = maxY - minY + 2 * padding;
        
        const canvasRect = this.canvas.getBoundingClientRect();
        const scaleX = canvasRect.width / contentWidth;
        const scaleY = canvasRect.height / contentHeight;
        
        this.scale = Math.min(scaleX, scaleY, 1);
        this.panX = (canvasRect.width - contentWidth * this.scale) / 2 - (minX - padding) * this.scale;
        this.panY = (canvasRect.height - contentHeight * this.scale) / 2 - (minY - padding) * this.scale;
        
        this.updateTransform();
        this.updateZoomDisplay();
    }
    
    updateTransform() {
        const transform = `translate(${this.panX}px, ${this.panY}px) scale(${this.scale})`;
        this.nodesLayer.style.transform = transform;
        this.connectionsLayer.style.transform = transform;
    }
    
    updateZoomDisplay() {
        const zoomPercent = Math.round(this.scale * 100);
        document.getElementById('zoom-level').textContent = `${zoomPercent}%`;
    }
    
    screenToWorld(screenPos) {
        return {
            x: (screenPos.x - this.panX) / this.scale,
            y: (screenPos.y - this.panY) / this.scale
        };
    }
    
    worldToScreen(worldPos) {
        return {
            x: worldPos.x * this.scale + this.panX,
            y: worldPos.y * this.scale + this.panY
        };
    }
    
    // Additional methods for animations, validation display, etc.
    animateToPositions
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-a-reactflow-editor-with-reflow-engine-in-a-web-worker"><a class="header" href="#building-a-reactflow-editor-with-reflow-engine-in-a-web-worker">Building a ReactFlow Editor with Reflow Engine in a Web Worker</a></h1>
<p>This tutorial demonstrates how to build a modern visual workflow editor using <strong>ReactFlow</strong> for the user interface and <strong>Reflow engine</strong> running in a Web Worker for graph execution and state management.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="tutorials/reactflow-reflow-integration.html#architecture-overview">Architecture Overview</a></li>
<li><a href="tutorials/reactflow-reflow-integration.html#project-setup">Project Setup</a></li>
<li><a href="tutorials/reactflow-reflow-integration.html#worker-integration">Worker Integration</a></li>
<li><a href="tutorials/reactflow-reflow-integration.html#reactflow-integration">ReactFlow Integration</a></li>
<li><a href="tutorials/reactflow-reflow-integration.html#custom-node-components">Custom Node Components</a></li>
<li><a href="tutorials/reactflow-reflow-integration.html#real-time-communication">Real-time Communication</a></li>
<li><a href="tutorials/reactflow-reflow-integration.html#advanced-features">Advanced Features</a></li>
<li><a href="tutorials/reactflow-reflow-integration.html#complete-example">Complete Example</a></li>
<li><a href="tutorials/reactflow-reflow-integration.html#performance-optimization">Performance Optimization</a></li>
</ol>
<h2 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h2>
<p>Our architecture separates concerns between the UI layer (ReactFlow) and the execution engine (Reflow WebAssembly):</p>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    React Application                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   ReactFlow     â”‚  â”‚  Component      â”‚  â”‚   Execution     â”‚ â”‚
â”‚  â”‚     Editor      â”‚  â”‚    Palette      â”‚  â”‚    Controls     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚            â”‚                    â”‚                    â”‚         â”‚
â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                 â”‚                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚ PostMessage API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          Web Worker                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Reflow WebAssm  â”‚  â”‚  Graph State    â”‚  â”‚   Persistence   â”‚ â”‚
â”‚  â”‚     Engine      â”‚  â”‚   Management    â”‚  â”‚   (IndexedDB)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Performance</strong>: Heavy graph operations don't block the UI thread</li>
<li><strong>Scalability</strong>: Can handle large, complex workflows</li>
<li><strong>Persistence</strong>: Graph state maintained separately from UI state</li>
<li><strong>Modularity</strong>: Clear separation between presentation and logic</li>
</ul>
<h2 id="project-setup-1"><a class="header" href="#project-setup-1">Project Setup</a></h2>
<h3 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h3>
<ul>
<li>Node.js 18+ and npm/yarn</li>
<li>Rust toolchain with <code>wasm-pack</code> installed</li>
<li>Basic knowledge of React and TypeScript</li>
</ul>
<h3 id="1-initialize-react-project"><a class="header" href="#1-initialize-react-project">1. Initialize React Project</a></h3>
<pre><code class="language-bash"># Create new React TypeScript project
npm create react-app@latest reflow-editor --template typescript
cd reflow-editor

# Install ReactFlow and dependencies
npm install reactflow
npm install @types/web
</code></pre>
<h3 id="2-install-reflow-webassembly-package"><a class="header" href="#2-install-reflow-webassembly-package">2. Install Reflow WebAssembly Package</a></h3>
<pre><code class="language-bash"># Build the Reflow WebAssembly package (from Reflow repo root)
cd crates/reflow_network
wasm-pack build --target web --out-dir pkg

# Copy the generated package to your React project
cp -r pkg/ /path/to/reflow-editor/src/reflow-wasm/
</code></pre>
<h3 id="3-project-structure-1"><a class="header" href="#3-project-structure-1">3. Project Structure</a></h3>
<pre><code>reflow-editor/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Editor/
â”‚   â”‚   â”‚   â”œâ”€â”€ ReactFlowEditor.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ CustomNodes/
â”‚   â”‚   â”‚   â””â”€â”€ CustomEdges/
â”‚   â”‚   â”œâ”€â”€ Palette/
â”‚   â”‚   â”‚   â””â”€â”€ ComponentPalette.tsx
â”‚   â”‚   â””â”€â”€ Controls/
â”‚   â”‚       â””â”€â”€ ExecutionControls.tsx
â”‚   â”œâ”€â”€ workers/
â”‚   â”‚   â””â”€â”€ reflow-worker.ts
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useReflowWorker.ts
â”‚   â”‚   â””â”€â”€ useGraphSync.ts
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ reflow.ts
â”‚   â”œâ”€â”€ reflow-wasm/          # Copied from Reflow build
â”‚   â””â”€â”€ App.tsx
</code></pre>
<h2 id="worker-integration"><a class="header" href="#worker-integration">Worker Integration</a></h2>
<h3 id="1-create-the-reflow-worker"><a class="header" href="#1-create-the-reflow-worker">1. Create the Reflow Worker</a></h3>
<p>First, let's create the Web Worker that manages the Reflow engine:</p>
<pre><code class="language-typescript">// src/workers/reflow-worker.ts
import { Graph, GraphHistory, StorageManager, initSync } from '../reflow-wasm/reflow_network.js';

// Worker state
let graph: Graph | null = null;
let history: GraphHistory | null = null;
let storage: StorageManager | null = null;

// Message types for type safety
export interface WorkerMessage {
  type: 'INIT' | 'ADD_NODE' | 'ADD_EDGE' | 'UPDATE_NODE' | 'ADD_GROUP' | 'EXECUTE';
  payload?: any;
}

export interface WorkerResponse {
  type: 'READY' | 'GRAPH_LOADED' | 'NODE_ADDED' | 'EDGE_ADDED' | 'ERROR';
  payload?: any;
}

// Initialize WebAssembly
fetch('/reflow_network_bg.wasm').then(async (res) =&gt; {
  initSync(await res.arrayBuffer());
  self.postMessage({ type: 'READY' } as WorkerResponse);
});

// Auto-save functionality
let saveTimeout: NodeJS.Timeout;
const autoSave = () =&gt; {
  if (saveTimeout) clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() =&gt; saveGraphState(), 1000);
};

// Message handler
self.addEventListener('message', async (event: MessageEvent&lt;WorkerMessage&gt;) =&gt; {
  const { type, payload } = event.data;

  try {
    switch (type) {
      case 'INIT':
        await initializeGraph(payload.name);
        break;

      case 'ADD_NODE':
        if (!graph) throw new Error('Graph not initialized');
        addNode(payload);
        break;

      case 'ADD_EDGE':
        if (!graph) throw new Error('Graph not initialized');
        addEdge(payload);
        break;

      case 'UPDATE_NODE':
        if (!graph) throw new Error('Graph not initialized');
        updateNode(payload);
        break;

      case 'ADD_GROUP':
        if (!graph) throw new Error('Graph not initialized');
        addGroup(payload);
        break;

      case 'EXECUTE':
        if (!graph) throw new Error('Graph not initialized');
        executeGraph();
        break;

      default:
        console.warn('Unknown message type:', type);
    }
  } catch (error) {
    self.postMessage({
      type: 'ERROR',
      payload: { message: error.message }
    } as WorkerResponse);
  }
});

// Initialize graph with persistence
async function initializeGraph(name: string) {
  [graph, history] = Graph.withHistory();
  storage = GraphHistory.createStorageManager(name, 'history');
  
  await storage.initDatabase();

  // Load existing state
  try {
    const snapshot = await storage.loadFromIndexedDB('latest');
    if (snapshot) {
      history = GraphHistory.loadFromSnapshot(snapshot, graph);
    }
  } catch (error) {
    console.warn('No previous state found:', error);
  }

  // Subscribe to graph events
  graph.subscribe((graphEvent) =&gt; {
    self.postMessage({
      type: 'GRAPH_EVENT',
      payload: graphEvent
    } as WorkerResponse);
  });

  self.postMessage({
    type: 'GRAPH_LOADED',
    payload: { graph: graph.toJSON() }
  } as WorkerResponse);
}

// Graph operation functions
function addNode(nodeData: any) {
  if (!graph || !history) return;

  graph.addNode(nodeData.id, nodeData.process, nodeData.metadata);
  history.processEvents(graph);
  autoSave();

  self.postMessage({
    type: 'NODE_ADDED',
    payload: nodeData
  } as WorkerResponse);
}

function addEdge(edgeData: any) {
  if (!graph || !history) return;

  const { from, to } = edgeData;
  
  // Add ports if they don't exist
  graph.addOutport(from.port.id, from.actor, from.port.name, true, from.port.metadata);
  graph.addInport(to.port.id, to.actor, to.port.name, true, to.port.metadata);
  
  // Add connection
  graph.addConnection(from.actor, from.port.id, to.actor, to.port.id, edgeData.metadata);
  
  history.processEvents(graph);
  autoSave();

  self.postMessage({
    type: 'EDGE_ADDED',
    payload: edgeData
  } as WorkerResponse);
}

function updateNode(nodeData: any) {
  if (!graph || !history) return;

  graph.setNodeMetadata(nodeData.id, nodeData.metadata);
  history.processEvents(graph);
  autoSave();
}

function addGroup(groupData: any) {
  if (!graph || !history) return;

  graph.addGroup(groupData.id, groupData.nodes, groupData.metadata);
  history.processEvents(graph);
  autoSave();
}

function executeGraph() {
  if (!graph) return;
  
  // Implement graph execution logic here
  console.log('Executing graph:', graph.toJSON());
}

// Save graph state
async function saveGraphState() {
  if (!graph || !history || !storage) return;

  try {
    await storage.saveToIndexedDB('latest', graph, history);
  } catch (error) {
    console.warn('Failed to save to IndexedDB:', error);
    try {
      storage.saveToLocalStorage('latest', graph, history);
    } catch (storageError) {
      console.error('Failed to save state:', storageError);
    }
  }
}
</code></pre>
<h3 id="2-create-worker-hook"><a class="header" href="#2-create-worker-hook">2. Create Worker Hook</a></h3>
<p>Create a React hook to manage the worker communication:</p>
<pre><code class="language-typescript">// src/hooks/useReflowWorker.ts
import { useEffect, useRef, useCallback, useState } from 'react';
import type { WorkerMessage, WorkerResponse } from '../workers/reflow-worker';

export interface ReflowWorkerHook {
  isReady: boolean;
  sendMessage: (message: WorkerMessage) =&gt; void;
  addEventListener: (listener: (event: WorkerResponse) =&gt; void) =&gt; void;
  removeEventListener: (listener: (event: WorkerResponse) =&gt; void) =&gt; void;
}

export function useReflowWorker(): ReflowWorkerHook {
  const workerRef = useRef&lt;Worker | null&gt;(null);
  const [isReady, setIsReady] = useState(false);
  const listenersRef = useRef&lt;Set&lt;(event: WorkerResponse) =&gt; void&gt;&gt;(new Set());

  useEffect(() =&gt; {
    // Create worker
    workerRef.current = new Worker('/src/workers/reflow-worker.ts', {
      type: 'module'
    });

    // Handle worker messages
    const handleMessage = (event: MessageEvent&lt;WorkerResponse&gt;) =&gt; {
      const message = event.data;
      
      if (message.type === 'READY') {
        setIsReady(true);
      }

      // Notify all listeners
      listenersRef.current.forEach(listener =&gt; listener(message));
    };

    workerRef.current.addEventListener('message', handleMessage);

    return () =&gt; {
      workerRef.current?.terminate();
    };
  }, []);

  const sendMessage = useCallback((message: WorkerMessage) =&gt; {
    if (workerRef.current &amp;&amp; isReady) {
      workerRef.current.postMessage(message);
    }
  }, [isReady]);

  const addEventListener = useCallback((listener: (event: WorkerResponse) =&gt; void) =&gt; {
    listenersRef.current.add(listener);
  }, []);

  const removeEventListener = useCallback((listener: (event: WorkerResponse) =&gt; void) =&gt; {
    listenersRef.current.delete(listener);
  }, []);

  return {
    isReady,
    sendMessage,
    addEventListener,
    removeEventListener
  };
}
</code></pre>
<h2 id="reactflow-integration"><a class="header" href="#reactflow-integration">ReactFlow Integration</a></h2>
<h3 id="1-main-editor-component"><a class="header" href="#1-main-editor-component">1. Main Editor Component</a></h3>
<pre><code class="language-typescript">// src/components/Editor/ReactFlowEditor.tsx
import React, { useCallback, useEffect, useState } from 'react';
import ReactFlow, {
  Node,
  Edge,
  addEdge,
  useNodesState,
  useEdgesState,
  Connection,
  ReactFlowProvider,
  Controls,
  Background,
  Panel,
} from 'reactflow';

import 'reactflow/dist/style.css';

import { useReflowWorker } from '../../hooks/useReflowWorker';
import { useGraphSync } from '../../hooks/useGraphSync';
import { ReflowNode } from './CustomNodes/ReflowNode';
import { ComponentPalette } from '../Palette/ComponentPalette';
import { ExecutionControls } from '../Controls/ExecutionControls';

// Custom node types
const nodeTypes = {
  reflow: ReflowNode,
};

export function ReactFlowEditor() {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const worker = useReflowWorker();

  // Sync ReactFlow state with Reflow worker
  const { syncToWorker, syncFromWorker } = useGraphSync(worker, setNodes, setEdges);

  useEffect(() =&gt; {
    if (worker.isReady) {
      // Initialize the graph in the worker
      worker.sendMessage({
        type: 'INIT',
        payload: { name: 'ReactFlow Graph' }
      });
    }
  }, [worker.isReady]);

  const onConnect = useCallback(
    (params: Edge | Connection) =&gt; {
      // Update ReactFlow state
      setEdges((eds) =&gt; addEdge(params, eds));
      
      // Sync to worker
      syncToWorker.addEdge({
        from: {
          actor: params.source,
          port: {
            id: `${params.source}-${params.sourceHandle}`,
            name: params.sourceHandle || 'output',
          }
        },
        to: {
          actor: params.target,
          port: {
            id: `${params.target}-${params.targetHandle}`,
            name: params.targetHandle || 'input',
          }
        }
      });
    },
    [setEdges, syncToWorker]
  );

  const onDrop = useCallback(
    (event: React.DragEvent) =&gt; {
      event.preventDefault();

      const reactFlowBounds = event.currentTarget.getBoundingClientRect();
      const type = event.dataTransfer.getData('application/reactflow');
      const position = {
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      };

      const newNode: Node = {
        id: `${type}-${Date.now()}`,
        type: 'reflow',
        position,
        data: {
          label: type,
          process: type,
          inports: getDefaultInports(type),
          outports: getDefaultOutports(type),
        },
      };

      // Update ReactFlow state
      setNodes((nds) =&gt; nds.concat(newNode));
      
      // Sync to worker
      syncToWorker.addNode({
        id: newNode.id,
        process: type,
        metadata: {
          position,
          name: type,
          inports: newNode.data.inports,
          outports: newNode.data.outports,
        }
      });
    },
    [setNodes, syncToWorker]
  );

  const onDragOver = useCallback((event: React.DragEvent) =&gt; {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  return (
    &lt;div style={{ width: '100vw', height: '100vh', display: 'flex' }}&gt;
      {/* Component Palette */}
      &lt;ComponentPalette /&gt;
      
      {/* Main ReactFlow Editor */}
      &lt;div style={{ flex: 1 }} onDrop={onDrop} onDragOver={onDragOver}&gt;
        &lt;ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          nodeTypes={nodeTypes}
          fitView
        &gt;
          &lt;Controls /&gt;
          &lt;Background /&gt;
          
          {/* Execution Controls Panel */}
          &lt;Panel position="top-right"&gt;
            &lt;ExecutionControls 
              onExecute={() =&gt; worker.sendMessage({ type: 'EXECUTE' })}
              isReady={worker.isReady}
            /&gt;
          &lt;/Panel&gt;
        &lt;/ReactFlow&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Helper functions for default port configurations
function getDefaultInports(nodeType: string) {
  const configs = {
    'DataSource': [],
    'MapActor': [{ id: 'input', name: 'input', trait: 'data' }],
    'Logger': [{ id: 'input', name: 'input', trait: 'data' }],
    'FilterActor': [{ id: 'input', name: 'input', trait: 'data' }],
  };
  return configs[nodeType] || [{ id: 'input', name: 'input', trait: 'data' }];
}

function getDefaultOutports(nodeType: string) {
  const configs = {
    'DataSource': [{ id: 'output', name: 'output', trait: 'data' }],
    'MapActor': [{ id: 'output', name: 'output', trait: 'data' }],
    'Logger': [],
    'FilterActor': [{ id: 'output', name: 'output', trait: 'data' }],
  };
  return configs[nodeType] || [{ id: 'output', name: 'output', trait: 'data' }];
}
</code></pre>
<h2 id="custom-node-components"><a class="header" href="#custom-node-components">Custom Node Components</a></h2>
<h3 id="1-reflow-node-component"><a class="header" href="#1-reflow-node-component">1. Reflow Node Component</a></h3>
<pre><code class="language-typescript">// src/components/Editor/CustomNodes/ReflowNode.tsx
import React, { memo } from 'react';
import { Handle, Position } from 'reactflow';

interface ReflowNodeData {
  label: string;
  process: string;
  inports: Array&lt;{ id: string; name: string; trait: string }&gt;;
  outports: Array&lt;{ id: string; name: string; trait: string }&gt;;
}

interface ReflowNodeProps {
  data: ReflowNodeData;
  isConnectable: boolean;
}

export const ReflowNode = memo(({ data, isConnectable }: ReflowNodeProps) =&gt; {
  return (
    &lt;div className="reflow-node"&gt;
      {/* Input Handles */}
      {data.inports.map((port, index) =&gt; (
        &lt;Handle
          key={port.id}
          type="target"
          position={Position.Left}
          id={port.id}
          isConnectable={isConnectable}
          style={{
            top: `${20 + (index * 25)}px`,
            background: getPortColor(port.trait),
          }}
        /&gt;
      ))}

      {/* Node Content */}
      &lt;div className="node-content"&gt;
        &lt;div className="node-header"&gt;
          &lt;strong&gt;{data.label}&lt;/strong&gt;
        &lt;/div&gt;
        &lt;div className="node-type"&gt;
          {data.process}
        &lt;/div&gt;
        
        {/* Port Labels */}
        &lt;div className="port-labels"&gt;
          &lt;div className="input-labels"&gt;
            {data.inports.map((port) =&gt; (
              &lt;div key={port.id} className="port-label"&gt;
                {port.name}
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
          &lt;div className="output-labels"&gt;
            {data.outports.map((port) =&gt; (
              &lt;div key={port.id} className="port-label"&gt;
                {port.name}
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Output Handles */}
      {data.outports.map((port, index) =&gt; (
        &lt;Handle
          key={port.id}
          type="source"
          position={Position.Right}
          id={port.id}
          isConnectable={isConnectable}
          style={{
            top: `${20 + (index * 25)}px`,
            background: getPortColor(port.trait),
          }}
        /&gt;
      ))}
    &lt;/div&gt;
  );
});

// Utility function for port colors
function getPortColor(trait: string): string {
  const colors = {
    data: '#3b82f6',      // Blue for data
    control: '#ef4444',   // Red for control
    event: '#10b981',     // Green for events
    config: '#f59e0b',    // Yellow for configuration
  };
  return colors[trait] || '#6b7280'; // Gray as default
}
</code></pre>
<h3 id="2-node-styles"><a class="header" href="#2-node-styles">2. Node Styles</a></h3>
<pre><code class="language-css">/* src/components/Editor/CustomNodes/ReflowNode.css */
.reflow-node {
  background: #ffffff;
  border: 2px solid #e5e7eb;
  border-radius: 8px;
  padding: 10px;
  min-width: 150px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  position: relative;
}

.reflow-node:hover {
  border-color: #3b82f6;
}

.node-content {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.node-header {
  font-size: 14px;
  font-weight: bold;
  color: #1f2937;
}

.node-type {
  font-size: 12px;
  color: #6b7280;
  font-style: italic;
}

.port-labels {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: #9ca3af;
}

.input-labels,
.output-labels {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.port-label {
  line-height: 1.2;
}

/* ReactFlow handle overrides */
.react-flow__handle {
  width: 8px;
  height: 8px;
  border: 2px solid #ffffff;
}

.react-flow__handle-left {
  left: -6px;
}

.react-flow__handle-right {
  right: -6px;
}
</code></pre>
<h2 id="real-time-communication"><a class="header" href="#real-time-communication">Real-time Communication</a></h2>
<h3 id="1-graph-synchronization-hook"><a class="header" href="#1-graph-synchronization-hook">1. Graph Synchronization Hook</a></h3>
<pre><code class="language-typescript">// src/hooks/useGraphSync.ts
import { useCallback, useEffect } from 'react';
import { Node, Edge } from 'reactflow';
import type { ReflowWorkerHook } from './useReflowWorker';

export function useGraphSync(
  worker: ReflowWorkerHook,
  setNodes: React.Dispatch&lt;React.SetStateAction&lt;Node[]&gt;&gt;,
  setEdges: React.Dispatch&lt;React.SetStateAction&lt;Edge[]&gt;&gt;
) {
  
  // Listen to worker events and sync to ReactFlow
  useEffect(() =&gt; {
    const handleWorkerMessage = (message: any) =&gt; {
      switch (message.type) {
        case 'GRAPH_LOADED':
          syncGraphFromWorker(message.payload.graph);
          break;
          
        case 'NODE_ADDED':
          // Handle real-time node additions from other sources
          break;
          
        case 'EDGE_ADDED':
          // Handle real-time edge additions from other sources
          break;
          
        case 'GRAPH_EVENT':
          // Handle live graph execution events
          console.log('Graph event:', message.payload);
          break;
      }
    };

    worker.addEventListener(handleWorkerMessage);
    
    return () =&gt; {
      worker.removeEventListener(handleWorkerMessage);
    };
  }, [worker]);

  // Convert Reflow graph to ReactFlow format
  const syncGraphFromWorker = useCallback((reflowGraph: any) =&gt; {
    const reactFlowNodes: Node[] = [];
    const reactFlowEdges: Edge[] = [];

    // Convert Reflow processes to ReactFlow nodes
    if (reflowGraph.processes) {
      Array.from(reflowGraph.processes.values()).forEach((process: any) =&gt; {
        const metadata = Object.fromEntries(process.metadata);
        const position = Object.fromEntries(metadata.position || new Map());
        
        reactFlowNodes.push({
          id: process.id,
          type: 'reflow',
          position: position,
          data: {
            label: metadata.name || process.component,
            process: process.component,
            inports: metadata.inports || [],
            outports: metadata.outports || [],
          },
        });
      });
    }

    // Convert Reflow connections to ReactFlow edges
    if (reflowGraph.connections) {
      reflowGraph.connections.forEach((connection: any) =&gt; {
        reactFlowEdges.push({
          id: `${connection.from.node_id}-${connection.from.port_name}-to-${connection.to.node_id}-${connection.to.port_name}`,
          source: connection.from.node_id,
          target: connection.to.node_id,
          sourceHandle: connection.from.port_name,
          targetHandle: connection.to.port_name,
        });
      });
    }

    setNodes(reactFlowNodes);
    setEdges(reactFlowEdges);
  }, [setNodes, setEdges]);

  // Functions to sync ReactFlow changes to worker
  const syncToWorker = {
    addNode: useCallback((nodeData: any) =&gt; {
      worker.sendMessage({
        type: 'ADD_NODE',
        payload: nodeData
      });
    }, [worker]),

    addEdge: useCallback((edgeData: any) =&gt; {
      worker.sendMessage({
        type: 'ADD_EDGE',
        payload: edgeData
      });
    }, [worker]),

    updateNode: useCallback((nodeData: any) =&gt; {
      worker.sendMessage({
        type: 'UPDATE_NODE',
        payload: nodeData
      });
    }, [worker]),
  };

  return {
    syncToWorker,
    syncFromWorker: syncGraphFromWorker,
  };
}
</code></pre>
<h2 id="advanced-features-1"><a class="header" href="#advanced-features-1">Advanced Features</a></h2>
<h3 id="1-component-palette"><a class="header" href="#1-component-palette">1. Component Palette</a></h3>
<pre><code class="language-typescript">// src/components/Palette/ComponentPalette.tsx
import React from 'react';

const COMPONENT_CATEGORIES = {
  'Data Sources': [
    { type: 'DataSource', label: 'Data Source', description: 'Generate or load data' },
    { type: 'FileReader', label: 'File Reader', description: 'Read files from disk' },
    { type: 'APISource', label: 'API Source', description: 'Fetch data from REST APIs' },
  ],
  'Processors': [
    { type: 'MapActor', label: 'Map', description: 'Transform data elements' },
    { type: 'FilterActor', label: 'Filter', description: 'Filter data elements' },
    { type: 'ReduceActor', label: 'Reduce', description: 'Aggregate data' },
    { type: 'SortActor', label: 'Sort', description: 'Sort data elements' },
  ],
  'Outputs': [
    { type: 'Logger', label: 'Logger', description: 'Log data to console' },
    { type: 'FileWriter', label: 'File Writer', description: 'Write data to file' },
    { type: 'ChartDisplay', label: 'Chart Display', description: 'Visualize data' },
  ],
};

export function ComponentPalette() {
  const onDragStart = (event: React.DragEvent, nodeType: string) =&gt; {
    event.dataTransfer.setData('application/reactflow', nodeType);
    event.dataTransfer.effectAllowed = 'move';
  };

  return (
    &lt;div className="component-palette"&gt;
      &lt;div className="palette-header"&gt;
        &lt;h3&gt;Components&lt;/h3&gt;
      &lt;/div&gt;
      
      &lt;div className="palette-content"&gt;
        {Object.entries(COMPONENT_CATEGORIES).map(([category, components]) =&gt; (
          &lt;div key={category} className="component-category"&gt;
            &lt;h4&gt;{category}&lt;/h4&gt;
            &lt;div className="component-list"&gt;
              {components.map((component) =&gt; (
                &lt;div
                  key={component.type}
                  className="component-item"
                  draggable
                  onDragStart={(event) =&gt; onDragStart(event, component.type)}
                &gt;
                  &lt;div className="component-label"&gt;{component.label}&lt;/div&gt;
                  &lt;div className="component-description"&gt;{component.description}&lt;/div&gt;
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h3 id="2-execution-controls"><a class="header" href="#2-execution-controls">2. Execution Controls</a></h3>
<pre><code class="language-typescript">// src/components/Controls/ExecutionControls.tsx
import React, { useState } from 'react';

interface ExecutionControlsProps {
  onExecute: () =&gt; void;
  isReady: boolean;
}

export function ExecutionControls({ onExecute, isReady }: ExecutionControlsProps) {
  const [isExecuting, setIsExecuting] = useState(false);

  const handleExecute = async () =&gt; {
    setIsExecuting(true);
    try {
      onExecute();
      // You can add execution status monitoring here
      setTimeout(() =&gt; setIsExecuting(false), 2000); // Simulate execution time
    } catch (error) {
      console.error('Execution failed:', error);
      setIsExecuting(false);
    }
  };

  return (
    &lt;div className="execution-controls"&gt;
      &lt;button
        onClick={handleExecute}
        disabled={!isReady || isExecuting}
        className={`execute-button ${isExecuting ? 'executing' : ''}`}
      &gt;
        {isExecuting ? 'Executing...' : 'Execute Workflow'}
      &lt;/button&gt;
      
      &lt;div className="status-indicator"&gt;
        &lt;div className={`status-dot ${isReady ? 'ready' : 'not-ready'}`} /&gt;
        &lt;span&gt;{isReady ? 'Ready' : 'Initializing...'}&lt;/span&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<h3 id="1-main-app-component"><a class="header" href="#1-main-app-component">1. Main App Component</a></h3>
<pre><code class="language-typescript">// src/App.tsx
import React from 'react';
import { ReactFlowProvider } from 'reactflow';
import { ReactFlowEditor } from './components/Editor/ReactFlowEditor';

import './App.css';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;ReactFlowProvider&gt;
        &lt;ReactFlowEditor /&gt;
      &lt;/ReactFlowProvider&gt;
    &lt;/div&gt;
  );
}

export default App;
</code></pre>
<h3 id="2-complete-styling"><a class="header" href="#2-complete-styling">2. Complete Styling</a></h3>
<pre><code class="language-css">/* src/App.css */
.App {
  height: 100vh;
  width: 100vw;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
}

/* Component Palette Styles */
.component-palette {
  width: 300px;
  height: 100vh;
  background: #f8f9fa;
  border-right: 1px solid #e9ecef;
  display: flex;
  flex-direction: column;
  overflow-y: auto;
}

.palette-header {
  padding: 16px;
  background: #ffffff;
  border-bottom: 1px solid #e9ecef;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.palette-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #495057;
}

.palette-content {
  flex: 1;
  padding: 16px;
}

.component-category {
  margin-bottom: 24px;
}

.component-category h4 {
  margin: 0 0 12px 0;
  font-size: 14px;
  font-weight: 600;
  color: #6c757d;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.component-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.component-item {
  padding: 12px;
  background: #ffffff;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  cursor: grab;
  transition: all 0.2s ease;
  user-select: none;
}

.component-item:hover {
  border-color: #3b82f6;
  box-shadow: 0 2px 8px rgba(59, 130, 246, 0.15);
  transform: translateY(-1px);
}

.component-item:active {
  cursor: grabbing;
  transform: translateY(0);
}

.component-label {
  font-weight: 600;
  color: #212529;
  margin-bottom: 4px;
}

.component-description {
  font-size: 12px;
  color: #6c757d;
  line-height: 1.4;
}

/* Execution Controls Styles */
.execution-controls {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 16px;
  background: #ffffff;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  min-width: 200px;
}

.execute-button {
  padding: 10px 16px;
  background: #10b981;
  color: white;
  border: none;
  border-radius: 6px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.execute-button:hover:not(:disabled) {
  background: #059669;
  transform: translateY(-1px);
}

.execute-button:disabled {
  background: #9ca3af;
  cursor: not-allowed;
  transform: none;
}

.execute-button.executing {
  background: #f59e0b;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.status-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: #6c757d;
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  transition: background-color 0.3s ease;
}

.status-dot.ready {
  background: #10b981;
}

.status-dot.not-ready {
  background: #ef4444;
  animation: blink 1s infinite;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

/* ReactFlow Customizations */
.react-flow__node.react-flow__node-reflow {
  background: transparent;
  border: none;
}

.react-flow__edge-path {
  stroke: #3b82f6;
  stroke-width: 2;
}

.react-flow__edge:hover .react-flow__edge-path {
  stroke: #1d4ed8;
  stroke-width: 3;
}

.react-flow__controls {
  background: #ffffff;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.react-flow__controls button {
  background: #ffffff;
  border: none;
  border-bottom: 1px solid #e9ecef;
}

.react-flow__controls button:hover {
  background: #f8f9fa;
}
</code></pre>
<h3 id="3-typescript-type-definitions"><a class="header" href="#3-typescript-type-definitions">3. TypeScript Type Definitions</a></h3>
<pre><code class="language-typescript">// src/types/reflow.ts
export interface ReflowPort {
  id: string;
  name: string;
  trait: 'data' | 'control' | 'event' | 'config';
  position?: { x: number; y: number };
  metadata?: Record&lt;string, any&gt;;
}

export interface ReflowNodeMetadata {
  position: { x: number; y: number };
  name: string;
  inports: ReflowPort[];
  outports: ReflowPort[];
  [key: string]: any;
}

export interface ReflowConnectionPoint {
  actor: string;
  port: {
    id: string;
    name: string;
    metadata?: Record&lt;string, any&gt;;
  };
}

export interface ReflowConnection {
  from: ReflowConnectionPoint;
  to: ReflowConnectionPoint;
  metadata?: Record&lt;string, any&gt;;
}

export interface ReflowGraphEvent {
  type: 'node_added' | 'edge_added' | 'node_updated' | 'execution_started' | 'execution_completed';
  data: any;
  timestamp: number;
}
</code></pre>
<h3 id="4-packagejson-configuration"><a class="header" href="#4-packagejson-configuration">4. Package.json Configuration</a></h3>
<pre><code class="language-json">{
  "name": "reflow-editor",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.0",
    "@types/web": "^0.0.99",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "reactflow": "^11.10.0",
    "typescript": "^4.9.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      "&gt;0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
</code></pre>
<h2 id="performance-optimization-4"><a class="header" href="#performance-optimization-4">Performance Optimization</a></h2>
<h3 id="1-memory-management"><a class="header" href="#1-memory-management">1. Memory Management</a></h3>
<pre><code class="language-typescript">// Optimize large graphs with virtualization
import { useCallback, useMemo } from 'react';

function useOptimizedNodes(nodes: Node[], viewport: { x: number; y: number; zoom: number }) {
  const visibleNodes = useMemo(() =&gt; {
    // Only render nodes in viewport to improve performance
    const padding = 200; // Extra padding around viewport
    const viewportBounds = {
      left: -viewport.x - padding,
      top: -viewport.y - padding,
      right: (-viewport.x + window.innerWidth) / viewport.zoom + padding,
      bottom: (-viewport.y + window.innerHeight) / viewport.zoom + padding,
    };

    return nodes.filter(node =&gt; {
      return (
        node.position.x &gt;= viewportBounds.left &amp;&amp;
        node.position.x &lt;= viewportBounds.right &amp;&amp;
        node.position.y &gt;= viewportBounds.top &amp;&amp;
        node.position.y &lt;= viewportBounds.bottom
      );
    });
  }, [nodes, viewport]);

  return visibleNodes;
}
</code></pre>
<h3 id="2-worker-optimization"><a class="header" href="#2-worker-optimization">2. Worker Optimization</a></h3>
<pre><code class="language-typescript">// Batch worker messages to reduce overhead
class WorkerMessageBatcher {
  private batchedMessages: WorkerMessage[] = [];
  private batchTimeout: NodeJS.Timeout | null = null;
  private worker: Worker;

  constructor(worker: Worker) {
    this.worker = worker;
  }

  sendMessage(message: WorkerMessage) {
    this.batchedMessages.push(message);
    
    if (this.batchTimeout) {
      clearTimeout(this.batchTimeout);
    }

    this.batchTimeout = setTimeout(() =&gt; {
      this.flushBatch();
    }, 16); // Batch messages for ~60fps
  }

  private flushBatch() {
    if (this.batchedMessages.length &gt; 0) {
      this.worker.postMessage({
        type: 'BATCH',
        payload: this.batchedMessages
      });
      this.batchedMessages = [];
    }
    this.batchTimeout = null;
  }
}
</code></pre>
<h3 id="3-state-management-optimization"><a class="header" href="#3-state-management-optimization">3. State Management Optimization</a></h3>
<pre><code class="language-typescript">// Use React.memo and useMemo for expensive operations
import { memo, useMemo } from 'react';

export const OptimizedReflowNode = memo(({ data, isConnectable }: ReflowNodeProps) =&gt; {
  const portColors = useMemo(() =&gt; {
    return {
      inports: data.inports.map(port =&gt; getPortColor(port.trait)),
      outports: data.outports.map(port =&gt; getPortColor(port.trait))
    };
  }, [data.inports, data.outports]);

  return (
    &lt;div className="reflow-node"&gt;
      {/* Optimized rendering with memoized colors */}
    &lt;/div&gt;
  );
}, (prevProps, nextProps) =&gt; {
  // Custom comparison for better performance
  return (
    prevProps.data.label === nextProps.data.label &amp;&amp;
    prevProps.data.process === nextProps.data.process &amp;&amp;
    prevProps.isConnectable === nextProps.isConnectable &amp;&amp;
    JSON.stringify(prevProps.data.inports) === JSON.stringify(nextProps.data.inports) &amp;&amp;
    JSON.stringify(prevProps.data.outports) === JSON.stringify(nextProps.data.outports)
  );
});
</code></pre>
<h3 id="4-webassembly-loading-optimization"><a class="header" href="#4-webassembly-loading-optimization">4. WebAssembly Loading Optimization</a></h3>
<pre><code class="language-typescript">// Pre-load and cache WebAssembly modules
class WasmCache {
  private static instance: WasmCache;
  private wasmModule: WebAssembly.Module | null = null;
  private loading: Promise&lt;WebAssembly.Module&gt; | null = null;

  static getInstance() {
    if (!WasmCache.instance) {
      WasmCache.instance = new WasmCache();
    }
    return WasmCache.instance;
  }

  async getModule(): Promise&lt;WebAssembly.Module&gt; {
    if (this.wasmModule) {
      return this.wasmModule;
    }

    if (this.loading) {
      return this.loading;
    }

    this.loading = this.loadModule();
    this.wasmModule = await this.loading;
    return this.wasmModule;
  }

  private async loadModule(): Promise&lt;WebAssembly.Module&gt; {
    const response = await fetch('/reflow_network_bg.wasm');
    const bytes = await response.arrayBuffer();
    return WebAssembly.compile(bytes);
  }
}
</code></pre>
<h2 id="best-practices--tips"><a class="header" href="#best-practices--tips">Best Practices &amp; Tips</a></h2>
<h3 id="1-error-handling"><a class="header" href="#1-error-handling">1. Error Handling</a></h3>
<ul>
<li>Always wrap worker communication in try-catch blocks</li>
<li>Implement proper error boundaries in React components</li>
<li>Provide meaningful error messages to users</li>
<li>Log errors for debugging but don't expose sensitive information</li>
</ul>
<h3 id="2-state-synchronization"><a class="header" href="#2-state-synchronization">2. State Synchronization</a></h3>
<ul>
<li>Keep ReactFlow state as the source of truth for UI</li>
<li>Use the worker for business logic and persistence</li>
<li>Implement debouncing for frequent updates</li>
<li>Handle race conditions in async operations</li>
</ul>
<h3 id="3-performance"><a class="header" href="#3-performance">3. Performance</a></h3>
<ul>
<li>Use React.memo for components that render frequently</li>
<li>Implement virtualization for large graphs (&gt;1000 nodes)</li>
<li>Batch worker messages to reduce overhead</li>
<li>Optimize WebAssembly loading and initialization</li>
</ul>
<h3 id="4-user-experience"><a class="header" href="#4-user-experience">4. User Experience</a></h3>
<ul>
<li>Show loading states during initialization</li>
<li>Provide feedback for long-running operations</li>
<li>Implement undo/redo functionality</li>
<li>Add keyboard shortcuts for common operations</li>
</ul>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This tutorial demonstrated how to build a modern, high-performance visual workflow editor by combining ReactFlow's excellent UI capabilities with Reflow's powerful WebAssembly engine running in a Web Worker.</p>
<h3 id="key-benefits-achieved"><a class="header" href="#key-benefits-achieved">Key Benefits Achieved</a></h3>
<ul>
<li><strong>Performance</strong>: UI remains responsive during heavy graph operations</li>
<li><strong>Scalability</strong>: Can handle complex workflows with hundreds of nodes</li>
<li><strong>Persistence</strong>: Automatic saving and loading of graph state</li>
<li><strong>Type Safety</strong>: Full TypeScript integration for better development experience</li>
<li><strong>Modularity</strong>: Clean separation between UI and business logic</li>
</ul>
<h3 id="next-steps-16"><a class="header" href="#next-steps-16">Next Steps</a></h3>
<ul>
<li><strong>Custom Components</strong>: Extend the component palette with domain-specific actors</li>
<li><strong>Real-time Collaboration</strong>: Add WebSocket support for multi-user editing</li>
<li><strong>Advanced Debugging</strong>: Implement step-through execution and breakpoints</li>
<li><strong>Plugin System</strong>: Create an extensible architecture for custom functionality</li>
<li><strong>Cloud Integration</strong>: Add support for cloud storage and sharing</li>
</ul>
<p>The architecture presented here provides a solid foundation for building production-ready workflow editors that can scale to enterprise requirements while maintaining excellent user experience.</p>
<p>For more advanced topics and examples, explore the <a href="tutorials/../README.html">main Reflow documentation</a> and the <a href="tutorials/../../examples/audio-flow/">audio-flow example</a> which demonstrates many of these concepts in action.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-optimization-guide"><a class="header" href="#performance-optimization-guide">Performance Optimization Guide</a></h1>
<p>Advanced techniques for optimizing Reflow workflows and applications.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>This guide covers comprehensive performance optimization strategies for Reflow applications, from basic configuration tweaks to advanced architectural patterns.</p>
<h2 id="performance-analysis-2"><a class="header" href="#performance-analysis-2">Performance Analysis</a></h2>
<h3 id="1-profiling-your-application"><a class="header" href="#1-profiling-your-application">1. Profiling Your Application</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::profiling::{ProfileConfig, Profiler, PerformanceMetrics};
use std::time::Instant;

// Enable comprehensive profiling
let profile_config = ProfileConfig {
    enable_memory_tracking: true,
    enable_cpu_profiling: true,
    enable_network_monitoring: true,
    sample_rate: 1000, // Sample every 1000 operations
    output_format: OutputFormat::Json,
};

let profiler = Profiler::new(profile_config);
profiler.start();

// Run your workflow
let start = Instant::now();
network.execute().await?;
let duration = start.elapsed();

// Collect profiling data
let metrics = profiler.stop_and_collect();
println!("Execution time: {:?}", duration);
println!("Memory peak: {:.2} MB", metrics.peak_memory_mb);
println!("CPU utilization: {:.1}%", metrics.avg_cpu_percent);

// Save detailed report
metrics.save_report("performance_report.json")?;
<span class="boring">}</span></code></pre></pre>
<h3 id="2-benchmarking-workflows"><a class="header" href="#2-benchmarking-workflows">2. Benchmarking Workflows</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};

fn benchmark_workflow_variants(c: &amp;mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    let mut group = c.benchmark_group("workflow_comparison");
    
    // Test different configurations
    for batch_size in [10, 50, 100, 500].iter() {
        group.bench_with_input(
            BenchmarkId::new("batched_workflow", batch_size),
            batch_size,
            |b, &amp;batch_size| {
                b.iter(|| {
                    rt.block_on(async {
                        let network = create_batched_workflow(batch_size).await;
                        black_box(network.execute().await)
                    })
                })
            },
        );
    }
    
    group.finish();
}

criterion_group!(benches, benchmark_workflow_variants);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<h2 id="memory-optimization-1"><a class="header" href="#memory-optimization-1">Memory Optimization</a></h2>
<h3 id="1-memory-pool-configuration"><a class="header" href="#1-memory-pool-configuration">1. Memory Pool Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::{MemoryPool, PoolConfig};

// Configure memory pools for different object types
let pool_config = PoolConfig {
    message_pool_size: 10000,
    node_pool_size: 1000, 
    connection_pool_size: 5000,
    enable_auto_scaling: true,
    max_pool_size: 50000,
    cleanup_threshold: 0.8,
};

let memory_pool = MemoryPool::new(pool_config);

// Use pooled objects
let network = Network::with_memory_pool(memory_pool);
<span class="boring">}</span></code></pre></pre>
<h3 id="2-message-optimization"><a class="header" href="#2-message-optimization">2. Message Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::{Message, MessageBuilder, CompactMessage};

// Use compact message format for large data
fn create_efficient_message(data: &amp;[u8]) -&gt; Message {
    if data.len() &gt; 1024 {
        // Use compressed format for large payloads
        MessageBuilder::new()
            .compress_payload(true)
            .use_binary_format(true)
            .build_from_bytes(data)
    } else {
        // Use standard format for small payloads
        Message::Binary(data.to_vec())
    }
}

// Implement message recycling
struct MessageCache {
    cache: Vec&lt;Message&gt;,
    max_size: usize,
}

impl MessageCache {
    fn get_or_create(&amp;mut self) -&gt; Message {
        self.cache.pop().unwrap_or_else(|| Message::Null)
    }
    
    fn return_message(&amp;mut self, mut msg: Message) {
        if self.cache.len() &lt; self.max_size {
            // Reset message and return to cache
            msg.clear();
            self.cache.push(msg);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-zero-copy-optimizations"><a class="header" href="#3-zero-copy-optimizations">3. Zero-Copy Optimizations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use bytes::Bytes;

// Use reference counting for large shared data
#[derive(Clone)]
struct SharedData {
    inner: Arc&lt;Bytes&gt;,
}

impl SharedData {
    fn new(data: Vec&lt;u8&gt;) -&gt; Self {
        Self {
            inner: Arc::new(Bytes::from(data))
        }
    }
    
    fn as_slice(&amp;self) -&gt; &amp;[u8] {
        &amp;self.inner
    }
}

// Actor implementation with zero-copy semantics
impl Actor for OptimizedProcessor {
    fn process(&amp;mut self, inputs: HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, ActorError&gt; {
        let mut outputs = HashMap::new();
        
        if let Some(Message::Binary(data)) = inputs.get("input") {
            // Process without copying the data
            let shared_data = SharedData::new(data.clone());
            
            // Pass reference to multiple outputs
            outputs.insert("output1".to_string(), 
                          Message::Custom(Box::new(shared_data.clone())));
            outputs.insert("output2".to_string(), 
                          Message::Custom(Box::new(shared_data)));
        }
        
        Ok(outputs)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cpu-optimization"><a class="header" href="#cpu-optimization">CPU Optimization</a></h2>
<h3 id="1-parallel-processing"><a class="header" href="#1-parallel-processing">1. Parallel Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rayon::prelude::*;
use tokio::task;

// Parallel data processing
impl Actor for ParallelProcessor {
    fn process(&amp;mut self, inputs: HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, ActorError&gt; {
        if let Some(Message::Array(items)) = inputs.get("input") {
            // Process items in parallel
            let results: Vec&lt;Message&gt; = items
                .par_iter()
                .map(|item| self.process_item(item))
                .collect();
            
            let mut outputs = HashMap::new();
            outputs.insert("output".to_string(), Message::Array(results));
            Ok(outputs)
        } else {
            Err(ActorError::InvalidInput)
        }
    }
}

// Async parallel processing
async fn process_batch_async(items: Vec&lt;Message&gt;) -&gt; Result&lt;Vec&lt;Message&gt;, ActorError&gt; {
    let tasks: Vec&lt;_&gt; = items.into_iter()
        .map(|item| task::spawn(async move { process_item_async(item).await }))
        .collect();
    
    let mut results = Vec::new();
    for task in tasks {
        results.push(task.await??);
    }
    
    Ok(results)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-cpu-affinity-and-thread-management"><a class="header" href="#2-cpu-affinity-and-thread-management">2. CPU Affinity and Thread Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::{ThreadConfig, CpuAffinity};

// Configure thread affinity for specific actors
let thread_config = ThreadConfig {
    worker_threads: num_cpus::get(),
    enable_work_stealing: true,
    cpu_affinity: CpuAffinity::Balanced,
    thread_priority: ThreadPriority::High,
};

// Pin specific actors to dedicated threads
let high_priority_executor = ThreadPoolBuilder::new()
    .num_threads(2)
    .thread_name(|i| format!("high-priority-{}", i))
    .build()?;

network.set_actor_executor("critical_processor", high_priority_executor);
<span class="boring">}</span></code></pre></pre>
<h3 id="3-simd-optimizations"><a class="header" href="#3-simd-optimizations">3. SIMD Optimizations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::simd::{f32x8, SimdFloat};

// SIMD-optimized data processing
fn process_array_simd(data: &amp;mut [f32]) {
    let chunks = data.chunks_exact_mut(8);
    let remainder = chunks.remainder();
    
    for chunk in chunks {
        let vec = f32x8::from_slice(chunk);
        let processed = vec * f32x8::splat(2.0) + f32x8::splat(1.0);
        processed.copy_to_slice(chunk);
    }
    
    // Handle remainder
    for item in remainder {
        *item = *item * 2.0 + 1.0;
    }
}

impl Actor for SIMDProcessor {
    fn process(&amp;mut self, inputs: HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, ActorError&gt; {
        if let Some(Message::Array(items)) = inputs.get("input") {
            let mut float_data: Vec&lt;f32&gt; = items.iter()
                .filter_map(|item| {
                    if let Message::Float(f) = item {
                        Some(*f as f32)
                    } else {
                        None
                    }
                })
                .collect();
            
            process_array_simd(&amp;mut float_data);
            
            let results: Vec&lt;Message&gt; = float_data.into_iter()
                .map(|f| Message::Float(f as f64))
                .collect();
            
            let mut outputs = HashMap::new();
            outputs.insert("output".to_string(), Message::Array(results));
            Ok(outputs)
        } else {
            Err(ActorError::InvalidInput)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="network-optimization"><a class="header" href="#network-optimization">Network Optimization</a></h2>
<h3 id="1-connection-pooling"><a class="header" href="#1-connection-pooling">1. Connection Pooling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::{ConnectionPool, PooledConnection};

// HTTP client with connection pooling
struct OptimizedHttpClient {
    pool: ConnectionPool,
    config: HttpConfig,
}

impl OptimizedHttpClient {
    fn new() -&gt; Self {
        let pool = ConnectionPool::builder()
            .max_connections(100)
            .idle_timeout(Duration::from_secs(30))
            .connection_timeout(Duration::from_secs(5))
            .keepalive(true)
            .build();
            
        Self {
            pool,
            config: HttpConfig::default(),
        }
    }
    
    async fn request(&amp;self, url: &amp;str) -&gt; Result&lt;Response, HttpError&gt; {
        let connection = self.pool.get_connection(url).await?;
        let response = connection.request(url).await?;
        
        // Connection is automatically returned to pool
        Ok(response)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-batch-network-operations"><a class="header" href="#2-batch-network-operations">2. Batch Network Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::integration::BatchHttpActor;

// Batch multiple HTTP requests
let batch_http = BatchHttpActor::new()
    .batch_size(10)
    .batch_timeout(Duration::from_millis(100))
    .max_concurrent_batches(5)
    .retry_config(RetryConfig {
        max_attempts: 3,
        backoff: BackoffStrategy::Exponential,
        ..Default::default()
    });

// Configure request batching
impl Actor for BatchHttpActor {
    fn process(&amp;mut self, inputs: HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, ActorError&gt; {
        if let Some(Message::Array(urls)) = inputs.get("urls") {
            // Batch requests automatically
            let batched_requests = self.create_batches(urls);
            let futures: Vec&lt;_&gt; = batched_requests.into_iter()
                .map(|batch| self.execute_batch(batch))
                .collect();
            
            // Execute batches concurrently
            let results = futures::future::join_all(futures).await;
            
            let mut outputs = HashMap::new();
            outputs.insert("responses".to_string(), Message::Array(results));
            Ok(outputs)
        } else {
            Err(ActorError::InvalidInput)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-websocket-optimization"><a class="header" href="#3-websocket-optimization">3. WebSocket Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio_tungstenite::{WebSocketStream, MaybeTlsStream};

// Optimized WebSocket handling
struct OptimizedWebSocket {
    stream: WebSocketStream&lt;MaybeTlsStream&lt;TcpStream&gt;&gt;,
    send_buffer: VecDeque&lt;Message&gt;,
    batch_size: usize,
}

impl OptimizedWebSocket {
    async fn send_batched(&amp;mut self) -&gt; Result&lt;(), WebSocketError&gt; {
        if self.send_buffer.len() &gt;= self.batch_size {
            let batch: Vec&lt;_&gt; = self.send_buffer.drain(..).collect();
            let combined_message = self.combine_messages(batch);
            self.stream.send(combined_message).await?;
        }
        Ok(())
    }
    
    fn combine_messages(&amp;self, messages: Vec&lt;Message&gt;) -&gt; tungstenite::Message {
        // Combine multiple messages into a single frame
        let combined_data = messages.into_iter()
            .map(|msg| msg.to_bytes())
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .concat();
        
        tungstenite::Message::Binary(combined_data)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="io-optimization"><a class="header" href="#io-optimization">I/O Optimization</a></h2>
<h3 id="1-async-io-best-practices"><a class="header" href="#1-async-io-best-practices">1. Async I/O Best Practices</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::fs::File;
use tokio::io::{AsyncReadExt, AsyncWriteExt, BufReader, BufWriter};

// Efficient file processing
async fn process_large_file(path: &amp;str) -&gt; Result&lt;(), std::io::Error&gt; {
    let file = File::open(path).await?;
    let mut reader = BufReader::with_capacity(64 * 1024, file); // 64KB buffer
    
    let output_file = File::create("output.txt").await?;
    let mut writer = BufWriter::with_capacity(64 * 1024, output_file);
    
    let mut buffer = vec![0; 8192]; // 8KB read buffer
    
    loop {
        let bytes_read = reader.read(&amp;mut buffer).await?;
        if bytes_read == 0 {
            break;
        }
        
        // Process data in chunks
        let processed = process_chunk(&amp;buffer[..bytes_read]).await;
        writer.write_all(&amp;processed).await?;
    }
    
    writer.flush().await?;
    Ok(())
}

// Parallel file processing
async fn process_files_parallel(file_paths: Vec&lt;String&gt;) -&gt; Result&lt;(), std::io::Error&gt; {
    let semaphore = Arc::new(Semaphore::new(10)); // Limit concurrent file operations
    
    let tasks: Vec&lt;_&gt; = file_paths.into_iter()
        .map(|path| {
            let sem = semaphore.clone();
            tokio::spawn(async move {
                let _permit = sem.acquire().await.unwrap();
                process_large_file(&amp;path).await
            })
        })
        .collect();
    
    futures::future::try_join_all(tasks).await?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-database-optimization"><a class="header" href="#2-database-optimization">2. Database Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::{Pool, Postgres, Row};

// Optimized database operations
struct OptimizedDbActor {
    pool: Pool&lt;Postgres&gt;,
    prepared_statements: HashMap&lt;String, String&gt;,
}

impl OptimizedDbActor {
    async fn new(database_url: &amp;str) -&gt; Result&lt;Self, sqlx::Error&gt; {
        let pool = sqlx::postgres::PgPoolOptions::new()
            .max_connections(20)
            .min_connections(5)
            .acquire_timeout(Duration::from_secs(3))
            .idle_timeout(Duration::from_secs(600))
            .max_lifetime(Duration::from_secs(1800))
            .connect(database_url)
            .await?;
        
        Ok(Self {
            pool,
            prepared_statements: HashMap::new(),
        })
    }
    
    async fn batch_insert(&amp;self, records: Vec&lt;Record&gt;) -&gt; Result&lt;(), sqlx::Error&gt; {
        let mut tx = self.pool.begin().await?;
        
        for chunk in records.chunks(1000) { // Process in batches of 1000
            let query = self.build_batch_insert_query(chunk);
            sqlx::query(&amp;query).execute(&amp;mut *tx).await?;
        }
        
        tx.commit().await?;
        Ok(())
    }
    
    async fn execute_prepared(&amp;self, statement_name: &amp;str, params: &amp;[&amp;dyn sqlx::Encode&lt;'_, Postgres&gt;]) -&gt; Result&lt;Vec&lt;Row&gt;, sqlx::Error&gt; {
        if let Some(sql) = self.prepared_statements.get(statement_name) {
            let mut query = sqlx::query(sql);
            for param in params {
                query = query.bind(param);
            }
            query.fetch_all(&amp;self.pool).await
        } else {
            Err(sqlx::Error::RowNotFound)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="workflow-specific-optimizations"><a class="header" href="#workflow-specific-optimizations">Workflow-Specific Optimizations</a></h2>
<h3 id="1-pipeline-optimization"><a class="header" href="#1-pipeline-optimization">1. Pipeline Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Optimized pipeline with backpressure
use tokio::sync::mpsc;

struct OptimizedPipeline {
    stages: Vec&lt;Box&lt;dyn Actor&gt;&gt;,
    buffer_sizes: Vec&lt;usize&gt;,
    channels: Vec&lt;mpsc::Sender&lt;Message&gt;&gt;,
}

impl OptimizedPipeline {
    fn new() -&gt; Self {
        Self {
            stages: Vec::new(),
            buffer_sizes: Vec::new(),
            channels: Vec::new(),
        }
    }
    
    fn add_stage(&amp;mut self, actor: Box&lt;dyn Actor&gt;, buffer_size: usize) {
        self.stages.push(actor);
        self.buffer_sizes.push(buffer_size);
        
        let (tx, rx) = mpsc::channel(buffer_size);
        self.channels.push(tx);
    }
    
    async fn execute_with_backpressure(&amp;mut self, input: Message) -&gt; Result&lt;Message, ActorError&gt; {
        let mut current_message = input;
        
        for (i, stage) in self.stages.iter_mut().enumerate() {
            // Apply backpressure using channel capacity
            if let Some(tx) = self.channels.get(i) {
                tx.send(current_message.clone()).await
                    .map_err(|_| ActorError::ChannelClosed)?;
            }
            
            let inputs = HashMap::from([("input".to_string(), current_message)]);
            let outputs = stage.process(inputs)?;
            
            current_message = outputs.get("output")
                .ok_or(ActorError::MissingOutput)?
                .clone();
        }
        
        Ok(current_message)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-dynamic-load-balancing"><a class="header" href="#2-dynamic-load-balancing">2. Dynamic Load Balancing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicUsize, Ordering};

struct LoadBalancer {
    workers: Vec&lt;Box&lt;dyn Actor&gt;&gt;,
    load_counters: Vec&lt;AtomicUsize&gt;,
    strategy: LoadBalanceStrategy,
}

impl LoadBalancer {
    fn select_worker(&amp;self) -&gt; usize {
        match self.strategy {
            LoadBalanceStrategy::RoundRobin =&gt; {
                static COUNTER: AtomicUsize = AtomicUsize::new(0);
                COUNTER.fetch_add(1, Ordering::Relaxed) % self.workers.len()
            }
            LoadBalanceStrategy::LeastLoaded =&gt; {
                self.load_counters
                    .iter()
                    .enumerate()
                    .min_by_key(|(_, counter)| counter.load(Ordering::Relaxed))
                    .map(|(index, _)| index)
                    .unwrap_or(0)
            }
            LoadBalanceStrategy::WeightedRoundRobin =&gt; {
                // Implement weighted selection based on worker capacity
                self.select_weighted_worker()
            }
        }
    }
    
    fn update_load_metrics(&amp;self, worker_index: usize, processing_time: Duration) {
        // Update load metrics for adaptive load balancing
        let load_score = self.calculate_load_score(processing_time);
        self.load_counters[worker_index].store(load_score, Ordering::Relaxed);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="monitoring-and-optimization"><a class="header" href="#monitoring-and-optimization">Monitoring and Optimization</a></h2>
<h3 id="1-real-time-metrics"><a class="header" href="#1-real-time-metrics">1. Real-time Metrics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{Counter, Histogram, Gauge, register_counter, register_histogram, register_gauge};

struct PerformanceMonitor {
    message_counter: Counter,
    processing_time: Histogram,
    memory_usage: Gauge,
    active_connections: Gauge,
}

impl PerformanceMonitor {
    fn new() -&gt; Self {
        Self {
            message_counter: register_counter!("reflow_messages_total", "Total messages processed").unwrap(),
            processing_time: register_histogram!("reflow_processing_duration_seconds", "Processing time in seconds").unwrap(),
            memory_usage: register_gauge!("reflow_memory_usage_bytes", "Memory usage in bytes").unwrap(),
            active_connections: register_gauge!("reflow_active_connections", "Number of active connections").unwrap(),
        }
    }
    
    fn record_message_processed(&amp;self, processing_time: Duration) {
        self.message_counter.inc();
        self.processing_time.observe(processing_time.as_secs_f64());
    }
    
    fn update_memory_usage(&amp;self, bytes: u64) {
        self.memory_usage.set(bytes as f64);
    }
    
    async fn collect_system_metrics(&amp;self) {
        if let Some(usage) = memory_stats::memory_stats() {
            self.update_memory_usage(usage.physical_mem as u64);
        }
        
        // Collect other system metrics
        let cpu_usage = get_cpu_usage().await;
        // ... record other metrics
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-adaptive-optimization"><a class="header" href="#2-adaptive-optimization">2. Adaptive Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AdaptiveOptimizer {
    performance_history: VecDeque&lt;PerformanceSnapshot&gt;,
    optimization_strategies: Vec&lt;Box&lt;dyn OptimizationStrategy&gt;&gt;,
    current_config: OptimizationConfig,
}

impl AdaptiveOptimizer {
    async fn optimize_based_on_metrics(&amp;mut self, current_metrics: &amp;PerformanceMetrics) {
        let snapshot = PerformanceSnapshot {
            timestamp: std::time::Instant::now(),
            metrics: current_metrics.clone(),
            config: self.current_config.clone(),
        };
        
        self.performance_history.push_back(snapshot);
        if self.performance_history.len() &gt; 100 {
            self.performance_history.pop_front();
        }
        
        // Analyze trends and apply optimizations
        if let Some(optimization) = self.analyze_and_suggest_optimization() {
            self.apply_optimization(optimization).await;
        }
    }
    
    fn analyze_and_suggest_optimization(&amp;self) -&gt; Option&lt;OptimizationAction&gt; {
        // Machine learning-based optimization suggestions
        let trend_analyzer = TrendAnalyzer::new(&amp;self.performance_history);
        
        if trend_analyzer.detect_memory_pressure() {
            Some(OptimizationAction::ReduceMemoryUsage)
        } else if trend_analyzer.detect_cpu_bottleneck() {
            Some(OptimizationAction::IncreaseParallelism)
        } else if trend_analyzer.detect_io_bottleneck() {
            Some(OptimizationAction::OptimizeIo)
        } else {
            None
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="platform-specific-optimizations"><a class="header" href="#platform-specific-optimizations">Platform-Specific Optimizations</a></h2>
<h3 id="1-linux-specific-optimizations"><a class="header" href="#1-linux-specific-optimizations">1. Linux-Specific Optimizations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = "linux")]
mod linux_optimizations {
    use libc::{sched_setaffinity, cpu_set_t, CPU_SET, CPU_ZERO};
    
    pub fn set_cpu_affinity(thread_id: u32, cpu_cores: &amp;[usize]) -&gt; Result&lt;(), std::io::Error&gt; {
        unsafe {
            let mut cpuset: cpu_set_t = std::mem::zeroed();
            CPU_ZERO(&amp;mut cpuset);
            
            for &amp;core in cpu_cores {
                CPU_SET(core, &amp;mut cpuset);
            }
            
            let result = sched_setaffinity(
                thread_id, 
                std::mem::size_of::&lt;cpu_set_t&gt;(), 
                &amp;cpuset
            );
            
            if result == 0 {
                Ok(())
            } else {
                Err(std::io::Error::last_os_error())
            }
        }
    }
    
    pub fn configure_memory_policy() {
        // Configure NUMA memory policy for optimal performance
        use libc::{mbind, MPOL_BIND};
        // Implementation details...
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-macos-specific-optimizations"><a class="header" href="#2-macos-specific-optimizations">2. macOS-Specific Optimizations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = "macos")]
mod macos_optimizations {
    use std::ffi::CString;
    use libc::{pthread_t, pthread_self, thread_policy_set, THREAD_PRECEDENCE_POLICY};
    
    pub fn set_thread_priority(priority: i32) -&gt; Result&lt;(), std::io::Error&gt; {
        unsafe {
            let thread = pthread_self();
            let policy = THREAD_PRECEDENCE_POLICY;
            
            let result = thread_policy_set(
                thread as *mut _,
                policy,
                &amp;priority as *const _ as *const _,
                1
            );
            
            if result == 0 {
                Ok(())
            } else {
                Err(std::io::Error::last_os_error())
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-summary-1"><a class="header" href="#best-practices-summary-1">Best Practices Summary</a></h2>
<h3 id="1-general-optimization-principles"><a class="header" href="#1-general-optimization-principles">1. General Optimization Principles</a></h3>
<ul>
<li><strong>Measure First</strong>: Always profile before optimizing</li>
<li><strong>Optimize Bottlenecks</strong>: Focus on the slowest components</li>
<li><strong>Cache Wisely</strong>: Cache expensive computations, not cheap ones</li>
<li><strong>Batch Operations</strong>: Group similar operations together</li>
<li><strong>Use Appropriate Data Structures</strong>: Choose the right tool for the job</li>
</ul>
<h3 id="2-memory-management"><a class="header" href="#2-memory-management">2. Memory Management</a></h3>
<ul>
<li><strong>Pool Resources</strong>: Use object pools for frequently allocated items</li>
<li><strong>Minimize Allocations</strong>: Reuse buffers and data structures</li>
<li><strong>Compress Large Data</strong>: Use compression for large payloads</li>
<li><strong>Monitor Memory Usage</strong>: Track allocation patterns</li>
</ul>
<h3 id="3-concurrency-and-parallelism"><a class="header" href="#3-concurrency-and-parallelism">3. Concurrency and Parallelism</a></h3>
<ul>
<li><strong>Match Threading to Workload</strong>: CPU-bound vs I/O-bound considerations</li>
<li><strong>Avoid Lock Contention</strong>: Use lock-free data structures when possible</li>
<li><strong>Balance Load</strong>: Distribute work evenly across threads</li>
<li><strong>Handle Backpressure</strong>: Prevent memory exhaustion in pipelines</li>
</ul>
<h3 id="4-network-and-io"><a class="header" href="#4-network-and-io">4. Network and I/O</a></h3>
<ul>
<li><strong>Connection Pooling</strong>: Reuse network connections</li>
<li><strong>Batch Network Operations</strong>: Reduce round-trip overhead</li>
<li><strong>Async I/O</strong>: Use non-blocking I/O operations</li>
<li><strong>Buffer Sizing</strong>: Optimize buffer sizes for your workload</li>
</ul>
<h2 id="troubleshooting-performance-issues"><a class="header" href="#troubleshooting-performance-issues">Troubleshooting Performance Issues</a></h2>
<h3 id="common-performance-problems"><a class="header" href="#common-performance-problems">Common Performance Problems</a></h3>
<ol>
<li><strong>Memory Leaks</strong>: Use memory profilers to identify leaks</li>
<li><strong>CPU Hotspots</strong>: Profile CPU usage to find bottlenecks</li>
<li><strong>Lock Contention</strong>: Monitor lock wait times</li>
<li><strong>I/O Blocking</strong>: Identify blocking I/O operations</li>
<li><strong>Network Latency</strong>: Measure network round-trip times</li>
</ol>
<h3 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod performance_tests {
    use super::*;
    use criterion::{criterion_group, criterion_main, Criterion};
    
    fn benchmark_workflow_throughput(c: &amp;mut Criterion) {
        c.bench_function("workflow_1000_messages", |b| {
            b.iter(|| {
                let rt = tokio::runtime::Runtime::new().unwrap();
                rt.block_on(async {
                    let network = create_test_network().await;
                    let messages = create_test_messages(1000);
                    
                    let start = std::time::Instant::now();
                    for message in messages {
                        network.process_message(message).await.unwrap();
                    }
                    start.elapsed()
                })
            })
        });
    }
    
    criterion_group!(benches, benchmark_workflow_throughput);
    criterion_main!(benches);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-17"><a class="header" href="#next-steps-17">Next Steps</a></h2>
<ul>
<li><a href="tutorials/../architecture/overview.html">Architecture Overview</a> - Understanding Reflow's architecture</li>
<li><a href="tutorials/../api/graph/advanced.html">Advanced Features</a> - Advanced graph operations</li>
<li><a href="tutorials/../reference/troubleshooting-guide.html">Troubleshooting Guide</a> - Common issues and solutions</li>
<li><a href="tutorials/../deployment/native-deployment.html">Deployment Guide</a> - Production deployment strategies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-deployment"><a class="header" href="#native-deployment">Native Deployment</a></h1>
<p>This guide covers deploying Reflow workflows as native applications on various platforms.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>Native deployment provides:</p>
<ul>
<li><strong>Maximum performance</strong> - Direct OS integration</li>
<li><strong>Resource efficiency</strong> - No containerization overhead</li>
<li><strong>Platform integration</strong> - Native system services</li>
<li><strong>Debugging capabilities</strong> - Full toolchain access</li>
</ul>
<h2 id="deployment-options"><a class="header" href="#deployment-options">Deployment Options</a></h2>
<h3 id="standalone-binary"><a class="header" href="#standalone-binary">Standalone Binary</a></h3>
<p>Compile workflows into self-contained executables:</p>
<pre><code class="language-bash"># Build optimized release binary
cargo build --release

# Binary includes all dependencies
./target/release/my-workflow

# Cross-compilation for different targets
cargo build --release --target x86_64-pc-windows-gnu
cargo build --release --target aarch64-apple-darwin
</code></pre>
<h3 id="system-service"><a class="header" href="#system-service">System Service</a></h3>
<p>Deploy as a system service for automatic startup:</p>
<h4 id="linux-systemd"><a class="header" href="#linux-systemd">Linux (systemd)</a></h4>
<p>Create <code>/etc/systemd/system/reflow-workflow.service</code>:</p>
<pre><code class="language-ini">[Unit]
Description=Reflow Workflow Service
After=network.target
Wants=network.target

[Service]
Type=exec
User=reflow
Group=reflow
ExecStart=/opt/reflow/bin/my-workflow
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=5
StandardOutput=journal
StandardError=journal

# Environment variables
Environment=RUST_LOG=info
Environment=REFLOW_CONFIG=/etc/reflow/config.toml

# Security settings
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/lib/reflow /var/log/reflow

[Install]
WantedBy=multi-user.target
</code></pre>
<p>Enable and start the service:</p>
<pre><code class="language-bash">sudo systemctl enable reflow-workflow
sudo systemctl start reflow-workflow
sudo systemctl status reflow-workflow
</code></pre>
<h4 id="macos-launchd"><a class="header" href="#macos-launchd">macOS (launchd)</a></h4>
<p>Create <code>/Library/LaunchDaemons/com.yourcompany.reflow.plist</code>:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
    &lt;key&gt;Label&lt;/key&gt;
    &lt;string&gt;com.yourcompany.reflow&lt;/string&gt;
    
    &lt;key&gt;ProgramArguments&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;/usr/local/bin/my-workflow&lt;/string&gt;
    &lt;/array&gt;
    
    &lt;key&gt;RunAtLoad&lt;/key&gt;
    &lt;true/&gt;
    
    &lt;key&gt;KeepAlive&lt;/key&gt;
    &lt;true/&gt;
    
    &lt;key&gt;StandardOutPath&lt;/key&gt;
    &lt;string&gt;/usr/local/var/log/reflow.log&lt;/string&gt;
    
    &lt;key&gt;StandardErrorPath&lt;/key&gt;
    &lt;string&gt;/usr/local/var/log/reflow.error.log&lt;/string&gt;
    
    &lt;key&gt;EnvironmentVariables&lt;/key&gt;
    &lt;dict&gt;
        &lt;key&gt;RUST_LOG&lt;/key&gt;
        &lt;string&gt;info&lt;/string&gt;
    &lt;/dict&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>Load the service:</p>
<pre><code class="language-bash">sudo launchctl load /Library/LaunchDaemons/com.yourcompany.reflow.plist
</code></pre>
<h4 id="windows-service"><a class="header" href="#windows-service">Windows Service</a></h4>
<p>Using the <code>windows-service</code> crate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Cargo.toml
[dependencies]
windows-service = "0.6"

// src/main.rs
use windows_service::{
    define_windows_service,
    service::{
        ServiceAccess, ServiceErrorControl, ServiceInfo, ServiceStartType,
        ServiceState, ServiceType,
    },
    service_control_handler::{self, ServiceControlHandlerResult},
    service_dispatcher, Result,
};

define_windows_service!(ffi_service_main, my_service_main);

fn my_service_main(arguments: Vec&lt;std::ffi::OsString&gt;) {
    if let Err(_e) = run_service(arguments) {
        // Handle error
    }
}

fn run_service(_arguments: Vec&lt;std::ffi::OsString&gt;) -&gt; Result&lt;()&gt; {
    let event_handler = move |control_event| -&gt; ServiceControlHandlerResult {
        match control_event {
            ServiceControl::Stop =&gt; {
                // Stop the workflow
                ServiceControlHandlerResult::NoError
            }
            ServiceControl::Interrogate =&gt; ServiceControlHandlerResult::NoError,
            _ =&gt; ServiceControlHandlerResult::NotImplemented,
        }
    };

    let status_handle = service_control_handler::register("reflow", event_handler)?;

    // Start workflow
    start_workflow();

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-management-1"><a class="header" href="#configuration-management-1">Configuration Management</a></h2>
<h3 id="configuration-files"><a class="header" href="#configuration-files">Configuration Files</a></h3>
<p>Create hierarchical configuration:</p>
<pre><code class="language-toml"># /etc/reflow/config.toml (system-wide)
[runtime]
thread_pool_size = 8
max_memory_mb = 1024

[logging]
level = "info"
output = "/var/log/reflow/app.log"

[network]
bind_address = "0.0.0.0:8080"
</code></pre>
<pre><code class="language-toml"># ~/.config/reflow/config.toml (user-specific)
[runtime]
thread_pool_size = 4  # Override system setting

[development]
hot_reload = true
debug_mode = true
</code></pre>
<h3 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h3>
<p>Support environment variable overrides:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use config::{Config, Environment, File};

fn load_config() -&gt; Result&lt;AppConfig, config::ConfigError&gt; {
    let mut settings = Config::builder()
        // Start with default values
        .add_source(File::with_name("config/default"))
        // Add environment-specific config
        .add_source(File::with_name(&amp;format!("config/{}", env)).required(false))
        // Add local config
        .add_source(File::with_name("config/local").required(false))
        // Add environment variables with REFLOW_ prefix
        .add_source(Environment::with_prefix("REFLOW"))
        .build()?;

    settings.try_deserialize()
}

// Environment variables:
// REFLOW_RUNTIME__THREAD_POOL_SIZE=16
// REFLOW_LOGGING__LEVEL=debug
// REFLOW_NETWORK__BIND_ADDRESS=127.0.0.1:9090
<span class="boring">}</span></code></pre></pre>
<h2 id="resource-management-1"><a class="header" href="#resource-management-1">Resource Management</a></h2>
<h3 id="memory-configuration"><a class="header" href="#memory-configuration">Memory Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tikv_jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

fn configure_memory() {
    // Set memory limits
    std::env::set_var("MALLOC_CONF", "lg_dirty_mult:8,lg_muzzy_mult:8");
    
    // Configure actor memory limits
    let config = ActorSystemConfig {
        max_actors: 10000,
        max_memory_per_actor: 100 * 1024 * 1024, // 100MB
        gc_threshold: 0.8,
    };
}
<span class="boring">}</span></code></pre></pre>
<h3 id="file-descriptors"><a class="header" href="#file-descriptors">File Descriptors</a></h3>
<pre><code class="language-bash"># Increase file descriptor limits
echo "reflow soft nofile 65536" &gt;&gt; /etc/security/limits.conf
echo "reflow hard nofile 65536" &gt;&gt; /etc/security/limits.conf

# For systemd services
echo "LimitNOFILE=65536" &gt;&gt; /etc/systemd/system/reflow-workflow.service
</code></pre>
<h3 id="cpu-affinity"><a class="header" href="#cpu-affinity">CPU Affinity</a></h3>
<p>Pin actors to specific CPU cores:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core_affinity;

fn configure_cpu_affinity() {
    let core_ids = core_affinity::get_core_ids().unwrap();
    
    // Pin high-priority actors to specific cores
    for (i, actor) in high_priority_actors.iter().enumerate() {
        let core_id = core_ids[i % core_ids.len()];
        
        tokio::spawn(async move {
            core_affinity::set_for_current(core_id);
            actor.run().await;
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="monitoring-and-observability-1"><a class="header" href="#monitoring-and-observability-1">Monitoring and Observability</a></h2>
<h3 id="logging-configuration"><a class="header" href="#logging-configuration">Logging Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, warn, error};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

fn setup_logging() {
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "reflow=info".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .with(
            tracing_appender::rolling::daily("/var/log/reflow", "app.log")
        )
        .init();
}
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics-integration"><a class="header" href="#metrics-integration">Metrics Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{Encoder, TextEncoder, register_counter, register_histogram};

lazy_static! {
    static ref MESSAGES_PROCESSED: prometheus::Counter = register_counter!(
        "reflow_messages_processed_total",
        "Total number of messages processed"
    ).unwrap();
    
    static ref MESSAGE_PROCESSING_TIME: prometheus::Histogram = register_histogram!(
        "reflow_message_processing_seconds",
        "Time spent processing messages"
    ).unwrap();
}

// Expose metrics endpoint
async fn metrics_handler() -&gt; impl warp::Reply {
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    let mut buffer = Vec::new();
    encoder.encode(&amp;metric_families, &amp;mut buffer).unwrap();
    
    warp::reply::with_header(buffer, "content-type", "text/plain")
}
<span class="boring">}</span></code></pre></pre>
<h3 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use warp::Filter;

#[derive(Serialize)]
struct HealthStatus {
    status: String,
    actors: usize,
    uptime: u64,
    memory_usage: u64,
}

async fn health_check() -&gt; Result&lt;impl warp::Reply, warp::Rejection&gt; {
    let status = HealthStatus {
        status: "healthy".to_string(),
        actors: get_active_actor_count(),
        uptime: get_uptime_seconds(),
        memory_usage: get_memory_usage(),
    };
    
    Ok(warp::reply::json(&amp;status))
}

let health = warp::path("health")
    .and(warp::get())
    .and_then(health_check);
<span class="boring">}</span></code></pre></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="user-permissions"><a class="header" href="#user-permissions">User Permissions</a></h3>
<p>Run with minimal privileges:</p>
<pre><code class="language-bash"># Create dedicated user
sudo useradd -r -s /bin/false reflow
sudo mkdir -p /var/lib/reflow /var/log/reflow
sudo chown reflow:reflow /var/lib/reflow /var/log/reflow
</code></pre>
<h3 id="file-system-sandboxing"><a class="header" href="#file-system-sandboxing">File System Sandboxing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::os::unix::fs::PermissionsExt;

fn setup_sandbox() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create chroot environment
    let sandbox_dir = "/var/lib/reflow/sandbox";
    std::fs::create_dir_all(sandbox_dir)?;
    
    // Set restrictive permissions
    let mut perms = std::fs::metadata(sandbox_dir)?.permissions();
    perms.set_mode(0o700);
    std::fs::set_permissions(sandbox_dir, perms)?;
    
    // Change root directory (requires root privileges)
    // unsafe { libc::chroot(sandbox_dir.as_ptr()) };
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="network-security"><a class="header" href="#network-security">Network Security</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpListener;
use rustls::{Certificate, PrivateKey, ServerConfig};

async fn start_secure_server() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load TLS certificates
    let certs = load_certs("cert.pem")?;
    let key = load_private_key("key.pem")?;
    
    let config = ServerConfig::builder()
        .with_safe_defaults()
        .with_no_client_auth()
        .with_single_cert(certs, key)?;
    
    let acceptor = tokio_rustls::TlsAcceptor::from(Arc::new(config));
    let listener = TcpListener::bind("0.0.0.0:8443").await?;
    
    while let Ok((stream, _)) = listener.accept().await {
        let acceptor = acceptor.clone();
        
        tokio::spawn(async move {
            if let Ok(tls_stream) = acceptor.accept(stream).await {
                handle_connection(tls_stream).await;
            }
        });
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-optimization-5"><a class="header" href="#performance-optimization-5">Performance Optimization</a></h2>
<h3 id="profile-guided-optimization"><a class="header" href="#profile-guided-optimization">Profile-Guided Optimization</a></h3>
<pre><code class="language-bash"># Build with instrumentation
RUSTFLAGS="-Cprofile-generate=/tmp/pgo-data" \
    cargo build --release

# Run with representative workload
./target/release/my-workflow --benchmark

# Rebuild with optimization data
RUSTFLAGS="-Cprofile-use=/tmp/pgo-data" \
    cargo build --release
</code></pre>
<h3 id="link-time-optimization"><a class="header" href="#link-time-optimization">Link-Time Optimization</a></h3>
<pre><code class="language-toml"># Cargo.toml
[profile.release]
lto = true
codegen-units = 1
panic = "abort"
</code></pre>
<h3 id="memory-pool-configuration"><a class="header" href="#memory-pool-configuration">Memory Pool Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use object_pool::Pool;

lazy_static! {
    static ref MESSAGE_POOL: Pool&lt;HashMap&lt;String, Message&gt;&gt; = Pool::new(1000, || {
        HashMap::with_capacity(16)
    });
}

fn get_message_buffer() -&gt; object_pool::Reusable&lt;HashMap&lt;String, Message&gt;&gt; {
    MESSAGE_POOL.try_pull().unwrap_or_else(|| {
        MESSAGE_POOL.attach(HashMap::with_capacity(16))
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="deployment-scripts"><a class="header" href="#deployment-scripts">Deployment Scripts</a></h2>
<h3 id="automated-deployment"><a class="header" href="#automated-deployment">Automated Deployment</a></h3>
<pre><code class="language-bash">#!/bin/bash
# deploy.sh

set -e

APP_NAME="reflow-workflow"
SERVICE_USER="reflow"
INSTALL_DIR="/opt/reflow"
CONFIG_DIR="/etc/reflow"
LOG_DIR="/var/log/reflow"

echo "Deploying $APP_NAME..."

# Stop existing service
sudo systemctl stop $APP_NAME || true

# Create directories
sudo mkdir -p $INSTALL_DIR/bin $CONFIG_DIR $LOG_DIR
sudo chown $SERVICE_USER:$SERVICE_USER $LOG_DIR

# Copy binary
sudo cp target/release/$APP_NAME $INSTALL_DIR/bin/
sudo chmod +x $INSTALL_DIR/bin/$APP_NAME

# Copy configuration
sudo cp config/production.toml $CONFIG_DIR/config.toml
sudo chown root:$SERVICE_USER $CONFIG_DIR/config.toml
sudo chmod 640 $CONFIG_DIR/config.toml

# Install service file
sudo cp scripts/$APP_NAME.service /etc/systemd/system/
sudo systemctl daemon-reload

# Start service
sudo systemctl enable $APP_NAME
sudo systemctl start $APP_NAME

echo "Deployment complete. Checking status..."
sudo systemctl status $APP_NAME
</code></pre>
<h3 id="rollback-script"><a class="header" href="#rollback-script">Rollback Script</a></h3>
<pre><code class="language-bash">#!/bin/bash
# rollback.sh

APP_NAME="reflow-workflow"
BACKUP_DIR="/opt/reflow/backups"

echo "Rolling back $APP_NAME..."

# Stop current service
sudo systemctl stop $APP_NAME

# Restore previous version
LATEST_BACKUP=$(ls -t $BACKUP_DIR/*.tar.gz | head -n1)
sudo tar -xzf $LATEST_BACKUP -C /opt/reflow/

# Restart service
sudo systemctl start $APP_NAME
sudo systemctl status $APP_NAME

echo "Rollback complete."
</code></pre>
<h2 id="troubleshooting-3"><a class="header" href="#troubleshooting-3">Troubleshooting</a></h2>
<h3 id="common-issues-2"><a class="header" href="#common-issues-2">Common Issues</a></h3>
<p><strong>High Memory Usage:</strong></p>
<pre><code class="language-bash"># Check memory allocation
echo "Memory usage by process:"
ps aux --sort=-%mem | grep reflow

# Monitor real-time usage
top -p $(pgrep reflow)

# Check for memory leaks
valgrind --tool=memcheck --leak-check=full ./my-workflow
</code></pre>
<p><strong>Performance Issues:</strong></p>
<pre><code class="language-bash"># Profile CPU usage
perf record -g ./my-workflow
perf report

# Check system resources
iostat -x 1
vmstat 1
</code></pre>
<p><strong>File Descriptor Limits:</strong></p>
<pre><code class="language-bash"># Check current limits
ulimit -n

# Check process usage
lsof -p $(pgrep reflow) | wc -l

# Monitor file descriptor usage
watch -n 1 'ls /proc/$(pgrep reflow)/fd | wc -l'
</code></pre>
<h3 id="log-analysis"><a class="header" href="#log-analysis">Log Analysis</a></h3>
<pre><code class="language-bash"># Real-time log monitoring
tail -f /var/log/reflow/app.log

# Search for errors
grep -i error /var/log/reflow/app.log

# Analyze performance patterns
awk '/processing_time/ {sum += $3; count++} END {print "Average:", sum/count}' app.log
</code></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<h3 id="deployment-checklist"><a class="header" href="#deployment-checklist">Deployment Checklist</a></h3>
<ul>
<li><input disabled="" type="checkbox"/>
Resource limits configured</li>
<li><input disabled="" type="checkbox"/>
Security permissions set</li>
<li><input disabled="" type="checkbox"/>
Monitoring enabled</li>
<li><input disabled="" type="checkbox"/>
Health checks implemented</li>
<li><input disabled="" type="checkbox"/>
Backup strategy defined</li>
<li><input disabled="" type="checkbox"/>
Rollback procedure tested</li>
<li><input disabled="" type="checkbox"/>
Documentation updated</li>
</ul>
<h3 id="production-readiness"><a class="header" href="#production-readiness">Production Readiness</a></h3>
<ol>
<li><strong>Load Testing</strong> - Validate performance under expected load</li>
<li><strong>Failure Testing</strong> - Test recovery from various failure scenarios</li>
<li><strong>Security Audit</strong> - Review permissions and access controls</li>
<li><strong>Monitoring Setup</strong> - Ensure comprehensive observability</li>
<li><strong>Backup Verification</strong> - Test backup and restore procedures</li>
</ol>
<h2 id="next-steps-18"><a class="header" href="#next-steps-18">Next Steps</a></h2>
<ul>
<li><a href="deployment/./container-deployment.html">Container Deployment</a> - Docker and Kubernetes</li>
<li><a href="deployment/./cloud-deployment.html">Cloud Deployment</a> - AWS, GCP, Azure</li>
<li><a href="deployment/./monitoring-setup.html">Monitoring Setup</a> - Comprehensive observability</li>
<li><a href="deployment/./security-hardening.html">Security Hardening</a> - Production security</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-and-tutorials"><a class="header" href="#examples-and-tutorials">Examples and Tutorials</a></h1>
<p>This section provides practical examples and tutorials for building workflows with Reflow.</p>
<h2 id="quick-reference"><a class="header" href="#quick-reference">Quick Reference</a></h2>
<h3 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h3>
<ul>
<li><strong><a href="examples/./tutorials/audio-processing-flow.html">Audio Processing Flow</a></strong> - Real-time audio processing pipeline</li>
<li><strong><a href="examples/./tutorials/data-etl-pipeline.html">Data ETL Pipeline</a></strong> - Extract, transform, load workflow</li>
<li><strong><a href="examples/./tutorials/web-api-integration.html">Web API Integration</a></strong> - REST API consumption and processing</li>
<li><strong><a href="examples/./tutorials/real-time-analytics.html">Real-time Analytics</a></strong> - Stream processing and aggregation</li>
</ul>
<h3 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h3>
<ul>
<li><strong><a href="examples/./use-cases/iot-data-processing.html">IoT Data Processing</a></strong> - Sensor data collection and analysis</li>
<li><strong><a href="examples/./use-cases/log-processing.html">Log Processing</a></strong> - Log aggregation and monitoring</li>
<li><strong><a href="examples/./use-cases/image-processing.html">Image Processing</a></strong> - Computer vision workflows</li>
<li><strong><a href="examples/./use-cases/financial-trading.html">Financial Trading</a></strong> - Trading algorithms and risk management</li>
</ul>
<h3 id="code-samples"><a class="header" href="#code-samples">Code Samples</a></h3>
<ul>
<li><strong><a href="examples/./code-samples/simple-examples.html">Simple Examples</a></strong> - Basic workflow patterns</li>
<li><strong><a href="examples/./code-samples/advanced-patterns.html">Advanced Patterns</a></strong> - Complex workflow compositions</li>
<li><strong><a href="examples/./code-samples/error-handling.html">Error Handling</a></strong> - Robust error management</li>
<li><strong><a href="examples/./code-samples/performance-optimization.html">Performance Optimization</a></strong> - High-throughput workflows</li>
</ul>
<h2 id="getting-started-examples"><a class="header" href="#getting-started-examples">Getting Started Examples</a></h2>
<h3 id="hello-world-workflow"><a class="header" href="#hello-world-workflow">Hello World Workflow</a></h3>
<p>The simplest possible workflow:</p>
<pre><pre class="playground"><code class="language-rust">use reflow_network::Network;
use reflow_components::{utility::LoggerActor, data_operations::MapActor};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut network = Network::new();
    
    // Create a simple transformer
    let transformer = MapActor::new(|payload| {
        let mut result = HashMap::new();
        result.insert("message".to_string(), 
                     Message::String("Hello, World!".to_string()));
        Ok(result)
    });
    
    // Create a logger
    let logger = LoggerActor::new()
        .level(LogLevel::Info)
        .format(LogFormat::Pretty);
    
    // Add to network
    network.add_actor("transformer", Box::new(transformer)).await?;
    network.add_actor("logger", Box::new(logger)).await?;
    
    // Connect them
    network.connect("transformer", "output", "logger", "input").await?;
    
    // Start the network
    network.start().await?;
    
    Ok(())
}</code></pre></pre>
<h3 id="basic-data-processing"><a class="header" href="#basic-data-processing">Basic Data Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::*;

async fn create_basic_pipeline() -&gt; Result&lt;Network, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut network = Network::new();
    
    // 1. Data source (HTTP endpoint)
    let source = integration::HttpRequestActor::new()
        .timeout(Duration::from_secs(30));
    
    // 2. Data validation
    let validator = data_operations::ValidatorActor::new()
        .add_rule("required", |v| !matches!(v, Message::Null))
        .add_rule("positive", |v| {
            if let Message::Integer(n) = v { *n &gt; 0 } else { true }
        });
    
    // 3. Data transformation
    let transformer = data_operations::MapActor::new(|payload| {
        let mut result = HashMap::new();
        
        // Transform each field
        for (key, value) in payload {
            let transformed = match value {
                Message::String(s) =&gt; Message::String(s.to_uppercase()),
                Message::Integer(n) =&gt; Message::Integer(n * 2),
                other =&gt; other.clone(),
            };
            result.insert(format!("transformed_{}", key), transformed);
        }
        
        Ok(result)
    });
    
    // 4. Output logging
    let logger = utility::LoggerActor::new();
    
    // Build network
    network.add_actor("source", Box::new(source)).await?;
    network.add_actor("validator", Box::new(validator)).await?;
    network.add_actor("transformer", Box::new(transformer)).await?;
    network.add_actor("logger", Box::new(logger)).await?;
    
    // Connect pipeline
    network.connect("source", "output", "validator", "input").await?;
    network.connect("validator", "valid", "transformer", "input").await?;
    network.connect("transformer", "output", "logger", "input").await?;
    
    Ok(network)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="javascript-integration-1"><a class="header" href="#javascript-integration-1">JavaScript Integration</a></h2>
<h3 id="deno-script-actor"><a class="header" href="#deno-script-actor">Deno Script Actor</a></h3>
<pre><code class="language-javascript">// scripts/data_processor.js
function process(inputs, context) {
    const data = inputs.data;
    
    if (!Array.isArray(data)) {
        return { error: "Expected array input" };
    }
    
    // Process data
    const processed = data
        .filter(item =&gt; item.value &gt; 0)
        .map(item =&gt; ({
            ...item,
            processed: true,
            timestamp: new Date().toISOString(),
            hash: calculateHash(item)
        }))
        .sort((a, b) =&gt; b.value - a.value);
    
    return {
        processed_data: processed,
        count: processed.length,
        max_value: processed[0]?.value || 0
    };
}

function calculateHash(item) {
    // Simple hash function
    return btoa(JSON.stringify(item)).slice(0, 8);
}

exports.process = process;
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust integration
use reflow_script::{ScriptActor, ScriptConfig, ScriptRuntime, ScriptEnvironment};

let script_config = ScriptConfig {
    environment: ScriptEnvironment::SYSTEM,
    runtime: ScriptRuntime::JavaScript,
    source: std::fs::read("scripts/data_processor.js")?,
    entry_point: "process".to_string(),
    packages: None,
};

let script_actor = ScriptActor::new(script_config);
<span class="boring">}</span></code></pre></pre>
<h2 id="real-world-patterns"><a class="header" href="#real-world-patterns">Real-World Patterns</a></h2>
<h3 id="error-handling-with-retry"><a class="header" href="#error-handling-with-retry">Error Handling with Retry</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::{flow_control::ConditionalActor, utility::RetryActor};

async fn create_robust_pipeline() -&gt; Result&lt;Network, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut network = Network::new();
    
    // Main processor (might fail)
    let processor = data_operations::MapActor::new(|payload| {
        // Simulate occasional failures
        if payload.contains_key("trigger_error") {
            return Err(anyhow::anyhow!("Simulated processing error"));
        }
        
        // Normal processing
        Ok(payload.clone())
    });
    
    // Error detector
    let error_detector = ConditionalActor::new(|payload| {
        payload.contains_key("error")
    });
    
    // Retry actor
    let retry_actor = RetryActor::new()
        .max_attempts(3)
        .backoff_strategy(BackoffStrategy::Exponential)
        .base_delay(Duration::from_millis(100));
    
    // Success logger
    let success_logger = utility::LoggerActor::new()
        .level(LogLevel::Info);
    
    // Error logger
    let error_logger = utility::LoggerActor::new()
        .level(LogLevel::Error);
    
    // Build network
    network.add_actor("processor", Box::new(processor)).await?;
    network.add_actor("error_detector", Box::new(error_detector)).await?;
    network.add_actor("retry_actor", Box::new(retry_actor)).await?;
    network.add_actor("success_logger", Box::new(success_logger)).await?;
    network.add_actor("error_logger", Box::new(error_logger)).await?;
    
    // Connect main flow
    network.connect("processor", "output", "error_detector", "input").await?;
    network.connect("error_detector", "false", "success_logger", "input").await?;
    network.connect("error_detector", "true", "retry_actor", "input").await?;
    
    // Retry loop
    network.connect("retry_actor", "retry", "processor", "input").await?;
    network.connect("retry_actor", "failed", "error_logger", "input").await?;
    
    Ok(network)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="high-throughput-processing"><a class="header" href="#high-throughput-processing">High-Throughput Processing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::{flow_control::LoadBalancerActor, synchronization::BatchActor};

async fn create_high_throughput_pipeline() -&gt; Result&lt;Network, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut network = Network::new();
    
    // Input batching
    let batcher = BatchActor::new()
        .batch_size(100)
        .timeout(Duration::from_millis(50));
    
    // Load balancer
    let load_balancer = LoadBalancerActor::new()
        .strategy(LoadBalanceStrategy::RoundRobin)
        .worker_count(4);
    
    // Worker actors (parallel processing)
    for i in 0..4 {
        let worker = data_operations::MapActor::new(|payload| {
            // CPU-intensive processing
            process_batch(payload)
        });
        
        network.add_actor(&amp;format!("worker_{}", i), Box::new(worker)).await?;
        network.connect("load_balancer", &amp;format!("output_{}", i),
                       &amp;format!("worker_{}", i), "input").await?;
    }
    
    // Result aggregator
    let aggregator = data_operations::AggregateActor::new()
        .window_size(4) // Collect from all workers
        .timeout(Duration::from_secs(1))
        .aggregation_fn(|results| {
            // Combine results from all workers
            combine_worker_results(results)
        });
    
    // Connect workers to aggregator
    for i in 0..4 {
        network.connect(&amp;format!("worker_{}", i), "output",
                       "aggregator", "input").await?;
    }
    
    network.add_actor("batcher", Box::new(batcher)).await?;
    network.add_actor("load_balancer", Box::new(load_balancer)).await?;
    network.add_actor("aggregator", Box::new(aggregator)).await?;
    
    network.connect("batcher", "output", "load_balancer", "input").await?;
    
    Ok(network)
}

fn process_batch(payload: &amp;HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, anyhow::Error&gt; {
    // Simulate CPU-intensive work
    thread::sleep(Duration::from_millis(10));
    Ok(payload.clone())
}

fn combine_worker_results(results: &amp;[HashMap&lt;String, Message&gt;]) -&gt; HashMap&lt;String, Message&gt; {
    let mut combined = HashMap::new();
    
    let total_processed = results.len() as i64;
    combined.insert("total_processed".to_string(), Message::Integer(total_processed));
    combined.insert("timestamp".to_string(), 
                   Message::String(chrono::Utc::now().to_rfc3339()));
    
    combined
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-workflows"><a class="header" href="#testing-workflows">Testing Workflows</a></h2>
<h3 id="unit-testing-2"><a class="header" href="#unit-testing-2">Unit Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use tokio::time::{timeout, Duration};
    
    #[tokio::test]
    async fn test_data_pipeline() {
        let network = create_basic_pipeline().await.unwrap();
        
        // Send test data
        let test_data = HashMap::from([
            ("value".to_string(), Message::Integer(42)),
            ("name".to_string(), Message::String("test".to_string())),
        ]);
        
        // Get input port and send data
        let input_port = network.get_actor_input("source").unwrap();
        input_port.send_async(test_data).await.unwrap();
        
        // Wait for processing
        timeout(Duration::from_secs(5), async {
            // Check that data was processed
            // This would require network introspection capabilities
        }).await.unwrap();
    }
    
    #[tokio::test]
    async fn test_error_handling() {
        let network = create_robust_pipeline().await.unwrap();
        
        // Send data that triggers error
        let error_data = HashMap::from([
            ("trigger_error".to_string(), Message::Boolean(true)),
        ]);
        
        // Verify error handling works correctly
        // Implementation depends on network monitoring capabilities
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing-3"><a class="header" href="#integration-testing-3">Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::sync::Mutex;

#[tokio::test]
async fn test_full_workflow_integration() {
    // Shared state for test validation
    let results = Arc::new(Mutex::new(Vec::new()));
    let results_clone = results.clone();
    
    // Create custom sink actor for testing
    let test_sink = TestSinkActor::new(move |payload| {
        let results = results_clone.clone();
        Box::pin(async move {
            let mut results_guard = results.lock().await;
            results_guard.push(payload.clone());
            Ok(HashMap::new())
        })
    });
    
    let mut network = Network::new();
    
    // Build test network
    let source = create_test_source();
    let processor = create_test_processor();
    
    network.add_actor("source", Box::new(source)).await.unwrap();
    network.add_actor("processor", Box::new(processor)).await.unwrap();
    network.add_actor("sink", Box::new(test_sink)).await.unwrap();
    
    network.connect("source", "output", "processor", "input").await.unwrap();
    network.connect("processor", "output", "sink", "input").await.unwrap();
    
    // Start network
    let handle = tokio::spawn(async move {
        network.start().await
    });
    
    // Send test data
    // ... implementation details
    
    // Wait and verify results
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    let final_results = results.lock().await;
    assert!(!final_results.is_empty());
    assert_eq!(final_results.len(), 3); // Expected number of processed messages
    
    handle.abort();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-examples"><a class="header" href="#performance-examples">Performance Examples</a></h2>
<h3 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_message_processing(c: &amp;mut Criterion) {
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    c.bench_function("process_1000_messages", |b| {
        b.iter(|| {
            rt.block_on(async {
                let network = create_high_throughput_pipeline().await.unwrap();
                
                // Send 1000 messages
                for i in 0..1000 {
                    let message = HashMap::from([
                        ("id".to_string(), Message::Integer(i)),
                        ("data".to_string(), Message::String(format!("data_{}", i))),
                    ]);
                    
                    // Send message
                    black_box(send_message(&amp;network, message).await);
                }
                
                // Wait for completion
                wait_for_completion(&amp;network).await;
            })
        })
    });
}

criterion_group!(benches, benchmark_message_processing);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-profiling"><a class="header" href="#memory-profiling">Memory Profiling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use memory_stats::memory_stats;

async fn profile_memory_usage() {
    let initial_memory = memory_stats().unwrap().physical_mem;
    println!("Initial memory: {} bytes", initial_memory);
    
    // Create large workflow
    let network = create_memory_intensive_workflow().await.unwrap();
    
    let after_creation = memory_stats().unwrap().physical_mem;
    println!("After creation: {} bytes", after_creation);
    println!("Creation overhead: {} bytes", after_creation - initial_memory);
    
    // Process data
    for batch in 0..10 {
        process_large_batch(&amp;network, batch).await;
        
        let current_memory = memory_stats().unwrap().physical_mem;
        println!("After batch {}: {} bytes", batch, current_memory);
    }
    
    // Cleanup
    drop(network);
    tokio::time::sleep(Duration::from_secs(1)).await; // Allow GC
    
    let final_memory = memory_stats().unwrap().physical_mem;
    println!("Final memory: {} bytes", final_memory);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-examples-1"><a class="header" href="#configuration-examples-1">Configuration Examples</a></h2>
<h3 id="environment-based-configuration"><a class="header" href="#environment-based-configuration">Environment-Based Configuration</a></h3>
<pre><code class="language-toml"># config/development.toml
[runtime]
thread_pool_size = 2
log_level = "debug"
hot_reload = true

[performance]
batch_size = 10
timeout_ms = 1000

[scripts]
enable_deno = true
enable_python = false
</code></pre>
<pre><code class="language-toml"># config/production.toml
[runtime]
thread_pool_size = 16
log_level = "info"
hot_reload = false

[performance]
batch_size = 1000
timeout_ms = 5000

[scripts]
enable_deno = true
enable_python = true
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configuration loading
use config::{Config, Environment, File};

#[derive(Debug, Deserialize)]
struct AppConfig {
    runtime: RuntimeConfig,
    performance: PerformanceConfig,
    scripts: ScriptConfig,
}

fn load_configuration() -&gt; Result&lt;AppConfig, config::ConfigError&gt; {
    let env = std::env::var("REFLOW_ENV").unwrap_or_else(|_| "development".into());
    
    let settings = Config::builder()
        .add_source(File::with_name("config/default"))
        .add_source(File::with_name(&amp;format!("config/{}", env)).required(false))
        .add_source(File::with_name("config/local").required(false))
        .add_source(Environment::with_prefix("REFLOW").separator("__"))
        .build()?;
    
    settings.try_deserialize()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="deployment-examples"><a class="header" href="#deployment-examples">Deployment Examples</a></h2>
<h3 id="docker-composition"><a class="header" href="#docker-composition">Docker Composition</a></h3>
<pre><code class="language-yaml"># docker-compose.yml
version: '3.8'

services:
  reflow-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - REFLOW_ENV=production
      - RUST_LOG=info
    volumes:
      - ./config:/app/config:ro
      - ./data:/app/data
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    
  postgres:
    image: postgres:13
    environment:
      POSTGRES_DB: reflow
      POSTGRES_USER: reflow
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    
  redis:
    image: redis:6-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
</code></pre>
<h3 id="kubernetes-deployment"><a class="header" href="#kubernetes-deployment">Kubernetes Deployment</a></h3>
<pre><code class="language-yaml"># k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: reflow-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: reflow-app
  template:
    metadata:
      labels:
        app: reflow-app
    spec:
      containers:
      - name: reflow-app
        image: reflow:latest
        ports:
        - containerPort: 8080
        env:
        - name: REFLOW_ENV
          value: "production"
        - name: RUST_LOG
          value: "info"
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
</code></pre>
<h2 id="next-steps-19"><a class="header" href="#next-steps-19">Next Steps</a></h2>
<p>Explore specific tutorials and use cases:</p>
<ul>
<li><strong><a href="examples/./tutorials/audio-processing-flow.html">Audio Processing Tutorial</a></strong> - Build a real-time audio pipeline</li>
<li><strong><a href="examples/./tutorials/data-etl-pipeline.html">Data ETL Tutorial</a></strong> - Create a data processing workflow</li>
<li><strong><a href="examples/./tutorials/web-api-integration.html">API Integration Tutorial</a></strong> - Connect to external services</li>
<li><strong><a href="examples/./use-cases/iot-data-processing.html">IoT Use Case</a></strong> - Process sensor data streams</li>
</ul>
<p>For more advanced topics:</p>
<ul>
<li><strong><a href="examples/../architecture/performance-considerations.html">Performance Optimization</a></strong></li>
<li><strong><a href="examples/./code-samples/advanced-patterns.html">Advanced Patterns</a></strong></li>
<li><strong><a href="examples/../components/custom-components.html">Custom Components</a></strong></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>Complete API reference for Reflow components and systems.</p>
<h2 id="core-apis"><a class="header" href="#core-apis">Core APIs</a></h2>
<h3 id="graph-api"><a class="header" href="#graph-api">Graph API</a></h3>
<ul>
<li><a href="reference/../api/graph/creating-graphs.html">Creating Graphs</a> - Basic graph operations and management</li>
<li><a href="reference/../api/graph/analysis.html">Graph Analysis</a> - Validation and performance analysis</li>
<li><a href="reference/../api/graph/layout.html">Graph Layout</a> - Positioning and visualization</li>
<li><a href="reference/../api/graph/advanced.html">Advanced Features</a> - History, optimization, and extensions</li>
</ul>
<h3 id="actor-api"><a class="header" href="#actor-api">Actor API</a></h3>
<ul>
<li><a href="reference/../api/actors/creating-actors.html">Creating Actors</a> - Actor implementation and lifecycle</li>
<li><a href="reference/../architecture/message-passing.html">Message Passing</a> - Communication patterns</li>
<li><a href="reference/../architecture/actor-model.html">Actor Model</a> - Architectural concepts</li>
</ul>
<h3 id="network-api"><a class="header" href="#network-api">Network API</a></h3>
<ul>
<li><a href="reference/../api/networking/network-management.html">Network Management</a> - Network creation and control</li>
<li><a href="reference/../api/networking/connections.html">Connection Handling</a> - Connection management</li>
<li><a href="reference/../api/networking/events.html">Event System</a> - Network events and monitoring</li>
</ul>
<h3 id="messaging-api"><a class="header" href="#messaging-api">Messaging API</a></h3>
<ul>
<li><a href="reference/../api/messaging/message-types.html">Message Types</a> - Supported message formats</li>
<li><a href="reference/../api/messaging/ports.html">Port Management</a> - Input/output port handling</li>
<li><a href="reference/../api/messaging/routing.html">Message Routing</a> - Message routing and delivery</li>
</ul>
<h2 id="runtime-apis"><a class="header" href="#runtime-apis">Runtime APIs</a></h2>
<h3 id="javascriptdeno-runtime"><a class="header" href="#javascriptdeno-runtime">JavaScript/Deno Runtime</a></h3>
<ul>
<li><a href="reference/../scripting/javascript/deno-runtime.html">Deno Runtime</a> - JavaScript execution environment</li>
<li><a href="reference/../scripting/javascript/modules.html">Module System</a> - Module loading and management</li>
<li><a href="reference/../scripting/javascript/permissions.html">Permissions</a> - Security and sandboxing</li>
</ul>
<h3 id="python-runtime-1"><a class="header" href="#python-runtime-1">Python Runtime</a></h3>
<ul>
<li><a href="reference/../scripting/python/python-runtime.html">Python Runtime</a> - Python execution environment</li>
<li><a href="reference/../scripting/python/packages.html">Package Management</a> - Python package handling</li>
<li><a href="reference/../scripting/python/environments.html">Virtual Environments</a> - Isolation and dependencies</li>
</ul>
<h3 id="webassembly-runtime-1"><a class="header" href="#webassembly-runtime-1">WebAssembly Runtime</a></h3>
<ul>
<li><a href="reference/../scripting/wasm/wasm-runtime.html">WASM Runtime</a> - WebAssembly execution</li>
<li><a href="reference/../scripting/wasm/modules.html">Module Loading</a> - WASM module management</li>
<li><a href="reference/../scripting/wasm/memory.html">Memory Management</a> - Memory allocation and cleanup</li>
</ul>
<h2 id="component-apis"><a class="header" href="#component-apis">Component APIs</a></h2>
<h3 id="standard-library-1"><a class="header" href="#standard-library-1">Standard Library</a></h3>
<ul>
<li><a href="reference/../components/standard-library.html">Component Library</a> - Built-in components</li>
<li><a href="reference/../components/custom-components.html">Custom Components</a> - Creating custom components</li>
<li><a href="reference/../components/lifecycle.html">Component Lifecycle</a> - Component management</li>
</ul>
<h3 id="data-operations-1"><a class="header" href="#data-operations-1">Data Operations</a></h3>
<ul>
<li><a href="reference/../components/data-operations.html">Data Transformation</a> - Data processing components</li>
<li><a href="reference/../components/validation.html">Validation</a> - Data validation components</li>
<li><a href="reference/../components/aggregation.html">Aggregation</a> - Data aggregation operations</li>
</ul>
<h3 id="flow-control-1"><a class="header" href="#flow-control-1">Flow Control</a></h3>
<ul>
<li><a href="reference/../components/flow-control.html">Conditional Logic</a> - Branching and conditions</li>
<li><a href="reference/../components/loops.html">Loops and Iteration</a> - Iterative processing</li>
<li><a href="reference/../components/error-handling.html">Error Handling</a> - Error management</li>
</ul>
<h2 id="configuration-reference"><a class="header" href="#configuration-reference">Configuration Reference</a></h2>
<h3 id="runtime-configuration-1"><a class="header" href="#runtime-configuration-1">Runtime Configuration</a></h3>
<pre><code class="language-toml">[runtime]
thread_pool_size = 8      # Number of worker threads
log_level = "info"        # Logging level: trace, debug, info, warn, error
hot_reload = false        # Enable hot reloading in development

[memory]
max_heap_size = "1GB"     # Maximum heap size
gc_frequency = 100        # Garbage collection frequency
</code></pre>
<h3 id="network-configuration-1"><a class="header" href="#network-configuration-1">Network Configuration</a></h3>
<pre><code class="language-toml">[network]
max_connections = 1000    # Maximum concurrent connections
timeout_ms = 5000        # Connection timeout in milliseconds
buffer_size = 8192       # Message buffer size

[websocket]
enable = true            # Enable WebSocket support
port = 8080             # WebSocket port
max_frame_size = 65536  # Maximum frame size
</code></pre>
<h3 id="script-configuration"><a class="header" href="#script-configuration">Script Configuration</a></h3>
<pre><code class="language-toml">[scripts.deno]
enable = true
allow_net = false        # Network access permission
allow_read = true        # File read permission
allow_write = false      # File write permission

[scripts.python]
enable = true
virtual_env = "venv"     # Virtual environment path
requirements = "requirements.txt"

[scripts.wasm]
enable = true
max_memory = "64MB"      # Maximum WASM memory
stack_size = "1MB"       # Stack size
</code></pre>
<h2 id="error-codes"><a class="header" href="#error-codes">Error Codes</a></h2>
<h3 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h3>
<ul>
<li><code>E001</code> - Actor initialization failed</li>
<li><code>E002</code> - Message routing error</li>
<li><code>E003</code> - Network connection failed</li>
<li><code>E004</code> - Script execution error</li>
<li><code>E005</code> - Memory allocation failed</li>
</ul>
<h3 id="graph-errors"><a class="header" href="#graph-errors">Graph Errors</a></h3>
<ul>
<li><code>G001</code> - Invalid graph structure</li>
<li><code>G002</code> - Cycle detected in graph</li>
<li><code>G003</code> - Port type mismatch</li>
<li><code>G004</code> - Orphaned node detected</li>
<li><code>G005</code> - Invalid connection</li>
</ul>
<h3 id="component-errors"><a class="header" href="#component-errors">Component Errors</a></h3>
<ul>
<li><code>C001</code> - Component not found</li>
<li><code>C002</code> - Invalid component configuration</li>
<li><code>C003</code> - Component lifecycle error</li>
<li><code>C004</code> - Port compatibility error</li>
<li><code>C005</code> - Component execution timeout</li>
</ul>
<h2 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h2>
<h3 id="core-types"><a class="header" href="#core-types">Core Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Graph types
pub struct Graph {
    pub name: String,
    pub directed: bool,
    pub metadata: HashMap&lt;String, Value&gt;,
}

pub struct GraphNode {
    pub id: String,
    pub component: String,
    pub metadata: HashMap&lt;String, Value&gt;,
}

pub struct GraphConnection {
    pub from_node: String,
    pub from_port: String,
    pub to_node: String,
    pub to_port: String,
    pub metadata: Option&lt;HashMap&lt;String, Value&gt;&gt;,
}

// Message types
pub enum Message {
    Null,
    Boolean(bool),
    Integer(i64),
    Float(f64),
    String(String),
    Array(Vec&lt;Message&gt;),
    Object(HashMap&lt;String, Message&gt;),
    Binary(Vec&lt;u8&gt;),
}

// Actor types
pub trait Actor: Send + Sync {
    fn process(&amp;mut self, inputs: HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, ActorError&gt;;
    fn get_input_ports(&amp;self) -&gt; Vec&lt;PortDefinition&gt;;
    fn get_output_ports(&amp;self) -&gt; Vec&lt;PortDefinition&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-types"><a class="header" href="#configuration-types">Configuration Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RuntimeConfig {
    pub thread_pool_size: usize,
    pub log_level: String,
    pub hot_reload: bool,
}

pub struct NetworkConfig {
    pub max_connections: usize,
    pub timeout_ms: u64,
    pub buffer_size: usize,
}

pub struct ScriptConfig {
    pub runtime: ScriptRuntime,
    pub source: String,
    pub entry_point: String,
    pub permissions: ScriptPermissions,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="webassembly-exports"><a class="header" href="#webassembly-exports">WebAssembly Exports</a></h2>
<h3 id="graph-management"><a class="header" href="#graph-management">Graph Management</a></h3>
<pre><code class="language-javascript">// Create and manage graphs
const graph = new Graph("MyGraph", true, {});
graph.addNode("node1", "Component", {});
graph.addConnection("node1", "out", "node2", "in", {});

// Graph analysis
const validation = graph.validate();
const cycles = graph.detectCycles();
const layout = graph.calculateLayout();
</code></pre>
<h3 id="network-operations"><a class="header" href="#network-operations">Network Operations</a></h3>
<pre><code class="language-javascript">// Network management
const network = new Network();
network.addActor("processor", processorActor);
network.connect("source", "output", "processor", "input");
await network.start();
</code></pre>
<h3 id="message-handling"><a class="header" href="#message-handling">Message Handling</a></h3>
<pre><code class="language-javascript">// Message creation and handling
const message = Message.fromJson({"key": "value"});
const result = await actor.process({"input": message});
</code></pre>
<h2 id="environment-variables-2"><a class="header" href="#environment-variables-2">Environment Variables</a></h2>
<h3 id="runtime-environment"><a class="header" href="#runtime-environment">Runtime Environment</a></h3>
<ul>
<li><code>REFLOW_LOG_LEVEL</code> - Override logging level</li>
<li><code>REFLOW_THREAD_POOL_SIZE</code> - Override thread pool size</li>
<li><code>REFLOW_CONFIG_PATH</code> - Configuration file path</li>
</ul>
<h3 id="development-environment-1"><a class="header" href="#development-environment-1">Development Environment</a></h3>
<ul>
<li><code>REFLOW_DEV_MODE</code> - Enable development features</li>
<li><code>REFLOW_HOT_RELOAD</code> - Enable hot reloading</li>
<li><code>REFLOW_DEBUG_ACTORS</code> - Enable actor debugging</li>
</ul>
<h3 id="production-environment"><a class="header" href="#production-environment">Production Environment</a></h3>
<ul>
<li><code>REFLOW_PRODUCTION</code> - Enable production optimizations</li>
<li><code>REFLOW_METRICS_ENDPOINT</code> - Metrics collection endpoint</li>
<li><code>REFLOW_HEALTH_CHECK_PORT</code> - Health check port</li>
</ul>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="memory-management-4"><a class="header" href="#memory-management-4">Memory Management</a></h3>
<ul>
<li>Use memory pooling for frequently allocated objects</li>
<li>Configure appropriate garbage collection settings</li>
<li>Monitor memory usage with built-in profiling tools</li>
</ul>
<h3 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h3>
<ul>
<li>Balance thread pool size with available CPU cores</li>
<li>Use async operations for I/O bound tasks</li>
<li>Implement backpressure for high-throughput scenarios</li>
</ul>
<h3 id="optimization"><a class="header" href="#optimization">Optimization</a></h3>
<ul>
<li>Enable compiler optimizations for production builds</li>
<li>Use profile-guided optimization when available</li>
<li>Monitor performance metrics and bottlenecks</li>
</ul>
<h2 id="next-steps-20"><a class="header" href="#next-steps-20">Next Steps</a></h2>
<ul>
<li><a href="reference/troubleshooting-guide.html">Troubleshooting Guide</a> - Common issues and solutions</li>
<li><a href="reference/../tutorials/performance-optimization.html">Performance Optimization</a> - Advanced optimization techniques</li>
<li><a href="reference/../advanced/extending-reflow/custom-runtimes.html">Extended APIs</a> - Creating custom extensions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-guide"><a class="header" href="#troubleshooting-guide">Troubleshooting Guide</a></h1>
<p>Common issues and solutions when working with Reflow.</p>
<h2 id="installation-issues"><a class="header" href="#installation-issues">Installation Issues</a></h2>
<h3 id="rust-compilation-errors"><a class="header" href="#rust-compilation-errors">Rust Compilation Errors</a></h3>
<p><strong>Problem</strong>: Build fails with compiler errors</p>
<pre><code>error[E0432]: unresolved import `reflow_network::Graph`
</code></pre>
<p><strong>Solution</strong>:</p>
<ol>
<li>Ensure you have the latest Rust version (1.70+)</li>
<li>Update dependencies: <code>cargo update</code></li>
<li>Clean build cache: <code>cargo clean &amp;&amp; cargo build</code></li>
</ol>
<p><strong>Problem</strong>: Missing system dependencies</p>
<pre><code>error: linking with `cc` failed: exit status: 1
</code></pre>
<p><strong>Solution</strong>:</p>
<ul>
<li><strong>Linux</strong>: Install build essentials: <code>sudo apt-get install build-essential</code></li>
<li><strong>macOS</strong>: Install Xcode command line tools: <code>xcode-select --install</code></li>
<li><strong>Windows</strong>: Install Visual Studio Build Tools</li>
</ul>
<h3 id="webassembly-build-issues"><a class="header" href="#webassembly-build-issues">WebAssembly Build Issues</a></h3>
<p><strong>Problem</strong>: wasm-pack fails to build</p>
<pre><code>Error: failed to execute `wasm-pack build`: No such file or directory
</code></pre>
<p><strong>Solution</strong>:</p>
<ol>
<li>Install wasm-pack: <code>curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh</code></li>
<li>Add wasm target: <code>rustup target add wasm32-unknown-unknown</code></li>
<li>Verify installation: <code>wasm-pack --version</code></li>
</ol>
<h2 id="runtime-issues"><a class="header" href="#runtime-issues">Runtime Issues</a></h2>
<h3 id="actor-initialization-failures"><a class="header" href="#actor-initialization-failures">Actor Initialization Failures</a></h3>
<p><strong>Problem</strong>: Actors fail to start</p>
<pre><code>Error: Actor 'data_processor' failed to initialize: E001
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Check actor configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify all required ports are defined
fn get_input_ports(&amp;self) -&gt; Vec&lt;PortDefinition&gt; {
    vec![
        PortDefinition::new("input", PortType::Any),
    ]
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Validate actor state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ensure actor is in valid initial state
impl Actor for MyActor {
    fn process(&amp;mut self, inputs: HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, ActorError&gt; {
        if !self.initialized {
            return Err(ActorError::NotInitialized);
        }
        // ... processing logic
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Check dependencies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Verify all dependencies are available
impl MyActor {
    pub fn new() -&gt; Result&lt;Self, ActorError&gt; {
        let dependency = SomeDependency::connect()
            .map_err(|_| ActorError::DependencyUnavailable)?;
        
        Ok(Self { dependency, initialized: true })
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="message-routing-errors"><a class="header" href="#message-routing-errors">Message Routing Errors</a></h3>
<p><strong>Problem</strong>: Messages not reaching destination actors</p>
<pre><code>Warning: Message dropped - no route to 'processor.input'
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Verify connections:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check connection exists
network.connect("source", "output", "processor", "input").await?;

// Verify actor and port names
let actors = network.list_actors();
println!("Available actors: {:?}", actors);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Check port compatibility:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Ensure port types match
source_actor.get_output_ports(); // Returns Vec&lt;PortDefinition&gt;
processor_actor.get_input_ports(); // Should have compatible types
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Monitor message flow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>network.enable_message_tracing(true);
// Check logs for message routing information
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="memory-issues"><a class="header" href="#memory-issues">Memory Issues</a></h3>
<p><strong>Problem</strong>: Out of memory errors</p>
<pre><code>Error: Memory allocation failed: E005
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Configure memory limits:</p>
<pre><code class="language-toml">[memory]
max_heap_size = "2GB"
gc_frequency = 50
enable_memory_pooling = true
</code></pre>
</li>
<li>
<p>Implement proper cleanup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Drop for MyActor {
    fn drop(&amp;mut self) {
        // Clean up resources
        self.cleanup_connections();
        self.release_buffers();
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Use memory profiling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use memory_stats::memory_stats;

if let Some(usage) = memory_stats() {
    println!("Memory usage: {} bytes", usage.physical_mem);
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="network-issues"><a class="header" href="#network-issues">Network Issues</a></h2>
<h3 id="connection-timeouts"><a class="header" href="#connection-timeouts">Connection Timeouts</a></h3>
<p><strong>Problem</strong>: Network operations timeout</p>
<pre><code>Error: Connection timeout after 5000ms: E003
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Increase timeout values:</p>
<pre><code class="language-toml">[network]
timeout_ms = 30000  # Increase to 30 seconds
</code></pre>
</li>
<li>
<p>Implement retry logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::utility::RetryActor;

let retry_actor = RetryActor::new()
    .max_attempts(3)
    .backoff_strategy(BackoffStrategy::Exponential)
    .base_delay(Duration::from_millis(100));
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Check network connectivity:</p>
<pre><code class="language-bash"># Test connectivity
curl -I http://your-endpoint
ping your-server
</code></pre>
</li>
</ol>
<h3 id="websocket-connection-issues"><a class="header" href="#websocket-connection-issues">WebSocket Connection Issues</a></h3>
<p><strong>Problem</strong>: WebSocket connections fail</p>
<pre><code>Error: WebSocket connection failed: Connection refused
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Verify server configuration:</p>
<pre><code class="language-toml">[websocket]
enable = true
port = 8080
bind_address = "0.0.0.0"
</code></pre>
</li>
<li>
<p>Check firewall settings:</p>
<pre><code class="language-bash"># Linux
sudo ufw allow 8080

# macOS
sudo pfctl -f /etc/pf.conf
</code></pre>
</li>
<li>
<p>Test WebSocket endpoint:</p>
<pre><code class="language-javascript">// Test in browser console
const ws = new WebSocket('ws://localhost:8080');
ws.onopen = () =&gt; console.log('Connected');
ws.onerror = (error) =&gt; console.error('Error:', error);
</code></pre>
</li>
</ol>
<h2 id="script-runtime-issues"><a class="header" href="#script-runtime-issues">Script Runtime Issues</a></h2>
<h3 id="deno-permission-errors"><a class="header" href="#deno-permission-errors">Deno Permission Errors</a></h3>
<p><strong>Problem</strong>: Deno scripts fail due to permissions</p>
<pre><code>Error: Requires read access to "./data", run again with --allow-read
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Configure permissions:</p>
<pre><code class="language-toml">[scripts.deno]
allow_read = true
allow_net = false
allow_write = false
</code></pre>
</li>
<li>
<p>Specify allowed paths:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = ScriptConfig {
    runtime: ScriptRuntime::JavaScript,
    permissions: ScriptPermissions {
        allow_read: Some(vec!["./data".to_string(), "./config".to_string()]),
        allow_net: Some(vec!["api.example.com".to_string()]),
        allow_write: None,
    },
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="python-import-errors"><a class="header" href="#python-import-errors">Python Import Errors</a></h3>
<p><strong>Problem</strong>: Python modules not found</p>
<pre><code>ModuleNotFoundError: No module named 'requests'
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Install dependencies:</p>
<pre><code class="language-bash">pip install -r requirements.txt
</code></pre>
</li>
<li>
<p>Configure virtual environment:</p>
<pre><code class="language-toml">[scripts.python]
virtual_env = "./venv"
requirements = "requirements.txt"
</code></pre>
</li>
<li>
<p>Verify Python path:</p>
<pre><code class="language-python">import sys
print(sys.path)
</code></pre>
</li>
</ol>
<h3 id="webassembly-module-loading"><a class="header" href="#webassembly-module-loading">WebAssembly Module Loading</a></h3>
<p><strong>Problem</strong>: WASM modules fail to load</p>
<pre><code>Error: Invalid WASM module format
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Verify WASM file:</p>
<pre><code class="language-bash">wasm-objdump -h module.wasm
</code></pre>
</li>
<li>
<p>Check module exports:</p>
<pre><code class="language-bash">wasm-objdump -x module.wasm | grep Export
</code></pre>
</li>
<li>
<p>Validate memory configuration:</p>
<pre><code class="language-toml">[scripts.wasm]
max_memory = "64MB"
stack_size = "1MB"
</code></pre>
</li>
</ol>
<h2 id="graph-issues"><a class="header" href="#graph-issues">Graph Issues</a></h2>
<h3 id="cycle-detection-errors"><a class="header" href="#cycle-detection-errors">Cycle Detection Errors</a></h3>
<p><strong>Problem</strong>: Graph contains cycles</p>
<pre><code>Error: Cycle detected in graph: node1 -&gt; node2 -&gt; node3 -&gt; node1
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Analyze graph structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let analysis = graph.analyze_structure();
if analysis.has_cycles {
    println!("Cycles found: {:?}", analysis.cycles);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Remove problematic connections:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Remove cycle-causing connection
graph.remove_connection("node3", "output", "node1", "input")?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Implement cycle breaking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cycles = graph.detect_cycles();
for cycle in cycles {
    // Break cycle by removing weakest connection
    let weakest_connection = find_weakest_connection(&amp;cycle);
    graph.remove_connection_by_id(&amp;weakest_connection.id)?;
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="port-type-mismatches"><a class="header" href="#port-type-mismatches">Port Type Mismatches</a></h3>
<p><strong>Problem</strong>: Incompatible port types</p>
<pre><code>Error: Port type mismatch: Cannot connect String output to Integer input
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Add type conversion:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::data_operations::ConverterActor;

let converter = ConverterActor::new()
    .add_conversion(PortType::String, PortType::Integer, |value| {
        if let Message::String(s) = value {
            s.parse::&lt;i64&gt;().map(Message::Integer).ok()
        } else {
            None
        }
    });
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Use flexible port types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>PortDefinition::new("input", PortType::Any)
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Implement custom validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_connection(&amp;self, output_type: &amp;PortType, input_type: &amp;PortType) -&gt; bool {
    match (output_type, input_type) {
        (PortType::String, PortType::Integer) =&gt; true, // Allow with conversion
        (PortType::Any, _) =&gt; true,
        (_, PortType::Any) =&gt; true,
        (a, b) =&gt; a == b,
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="high-cpu-usage"><a class="header" href="#high-cpu-usage">High CPU Usage</a></h3>
<p><strong>Problem</strong>: Actors consuming excessive CPU</p>
<pre><code>Warning: Actor 'data_processor' CPU usage: 95%
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Profile actor performance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;

impl Actor for MyActor {
    fn process(&amp;mut self, inputs: HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, ActorError&gt; {
        let start = Instant::now();
        
        // ... processing logic
        
        let duration = start.elapsed();
        if duration.as_millis() &gt; 100 {
            log::warn!("Slow processing: {:?}", duration);
        }
        
        Ok(result)
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Implement batching:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_components::synchronization::BatchActor;

let batcher = BatchActor::new()
    .batch_size(100)
    .timeout(Duration::from_millis(50));
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Use async processing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn process_async(&amp;mut self, inputs: HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, ActorError&gt; {
    // Use tokio::task::yield_now() to yield control
    tokio::task::yield_now().await;
    
    // CPU-intensive work
    let result = heavy_computation(inputs).await;
    
    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="memory-leaks"><a class="header" href="#memory-leaks">Memory Leaks</a></h3>
<p><strong>Problem</strong>: Memory usage continuously increases</p>
<pre><code>Warning: Memory usage increased to 2.1GB (threshold: 2GB)
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Monitor memory allocation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reflow_network::profiling::MemoryProfiler;

let profiler = MemoryProfiler::new();
profiler.start_monitoring();

// ... run workflows

let report = profiler.generate_report();
println!("Memory hotspots: {:?}", report.hotspots);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Implement proper cleanup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Actor for MyActor {
    fn process(&amp;mut self, inputs: HashMap&lt;String, Message&gt;) -&gt; Result&lt;HashMap&lt;String, Message&gt;, ActorError&gt; {
        // Process inputs
        let result = self.do_processing(inputs)?;
        
        // Clean up temporary data
        self.cleanup_temp_data();
        
        Ok(result)
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Use memory limits:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = ActorConfig {
    memory_limit: Some(100 * 1024 * 1024), // 100MB limit
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="debugging-tips"><a class="header" href="#debugging-tips">Debugging Tips</a></h2>
<h3 id="enable-debug-logging"><a class="header" href="#enable-debug-logging">Enable Debug Logging</a></h3>
<pre><code class="language-toml">[logging]
level = "debug"
targets = [
    "reflow_network=debug",
    "reflow_components=info",
    "my_app=trace"
]
</code></pre>
<h3 id="use-network-introspection"><a class="header" href="#use-network-introspection">Use Network Introspection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable network monitoring
network.enable_monitoring(true);

// Get network statistics
let stats = network.get_statistics();
println!("Messages processed: {}", stats.total_messages);
println!("Average latency: {:?}", stats.average_latency);

// List active actors
let actors = network.list_active_actors();
for (id, status) in actors {
    println!("Actor {}: {:?}", id, status);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="actor-state-inspection"><a class="header" href="#actor-state-inspection">Actor State Inspection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable actor introspection
actor.enable_introspection(true);

// Get actor state
let state = actor.get_internal_state();
println!("Actor state: {:?}", state);

// Monitor port activity
let port_stats = actor.get_port_statistics();
for (port, stats) in port_stats {
    println!("Port {}: {} messages", port, stats.message_count);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="graph-visualization"><a class="header" href="#graph-visualization">Graph Visualization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Export graph for visualization
let dot_format = graph.export_dot();
std::fs::write("graph.dot", dot_format)?;

// Generate SVG visualization
// Use graphviz: dot -Tsvg graph.dot -o graph.svg
<span class="boring">}</span></code></pre></pre>
<h2 id="common-error-patterns"><a class="header" href="#common-error-patterns">Common Error Patterns</a></h2>
<h3 id="error-e001-actor-initialization-failed"><a class="header" href="#error-e001-actor-initialization-failed">Error E001: Actor Initialization Failed</a></h3>
<ul>
<li>Check actor dependencies</li>
<li>Verify configuration parameters</li>
<li>Ensure required resources are available</li>
</ul>
<h3 id="error-e002-message-routing-error"><a class="header" href="#error-e002-message-routing-error">Error E002: Message Routing Error</a></h3>
<ul>
<li>Verify connection exists</li>
<li>Check port names and types</li>
<li>Ensure target actor is running</li>
</ul>
<h3 id="error-e003-network-connection-failed"><a class="header" href="#error-e003-network-connection-failed">Error E003: Network Connection Failed</a></h3>
<ul>
<li>Check network connectivity</li>
<li>Verify server endpoints</li>
<li>Review firewall settings</li>
</ul>
<h3 id="error-g002-cycle-detected"><a class="header" href="#error-g002-cycle-detected">Error G002: Cycle Detected</a></h3>
<ul>
<li>Analyze graph structure</li>
<li>Remove cycle-causing connections</li>
<li>Consider using async patterns</li>
</ul>
<h3 id="error-c004-port-compatibility-error"><a class="header" href="#error-c004-port-compatibility-error">Error C004: Port Compatibility Error</a></h3>
<ul>
<li>Check port type definitions</li>
<li>Add type conversion actors</li>
<li>Use flexible port types</li>
</ul>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<ol>
<li><strong>Check logs</strong>: Enable debug logging for detailed information</li>
<li><strong>Use monitoring tools</strong>: Enable network and actor monitoring</li>
<li><strong>Review configuration</strong>: Verify all configuration parameters</li>
<li><strong>Test in isolation</strong>: Create minimal test cases</li>
<li><strong>Community support</strong>: Open issues on GitHub with detailed error information</li>
</ol>
<h2 id="diagnostic-tools"><a class="header" href="#diagnostic-tools">Diagnostic Tools</a></h2>
<h3 id="health-check-endpoint"><a class="header" href="#health-check-endpoint">Health Check Endpoint</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add health check to your application
use warp::Filter;

let health = warp::path("health")
    .map(|| {
        let status = check_system_health();
        warp::reply::json(&amp;status)
    });

warp::serve(health)
    .run(([127, 0, 0, 1], 8080))
    .await;
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{Counter, Histogram, register_counter, register_histogram};

let message_counter = register_counter!("reflow_messages_total", "Total messages processed").unwrap();
let processing_time = register_histogram!("reflow_processing_duration_seconds", "Processing time").unwrap();

// In actor processing
message_counter.inc();
let _timer = processing_time.start_timer();
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-profiling-1"><a class="header" href="#performance-profiling-1">Performance Profiling</a></h3>
<pre><code class="language-bash"># CPU profiling
cargo install flamegraph
cargo flamegraph --bin reflow-app

# Memory profiling  
cargo install heaptrack
heaptrack target/release/reflow-app
</code></pre>
<p>For additional help, see:</p>
<ul>
<li><a href="reference/api-reference.html">API Reference</a> - Complete API documentation</li>
<li><a href="reference/../architecture/overview.html">Architecture Overview</a> - System architecture</li>
<li><a href="reference/../tutorials/performance-optimization.html">Performance Optimization</a> - Optimization techniques</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="a"><a class="header" href="#a">A</a></h2>
<p><strong>Actor</strong>
: A fundamental unit of computation in Reflow that processes messages and can create other actors, send messages, or designate behavior for the next message.</p>
<p><strong>Actor Model</strong>
: A mathematical model of concurrent computation that treats actors as the universal primitives of concurrent computation.</p>
<p><strong>API</strong>
: Application Programming Interface - A set of protocols and tools for building software applications.</p>
<h2 id="c"><a class="header" href="#c">C</a></h2>
<p><strong>Component</strong>
: A reusable unit of functionality in Reflow that can be connected to other components to build workflows.</p>
<p><strong>Connection</strong>
: A link between two components that allows data or control flow to pass from one component to another.</p>
<p><strong>Concurrent Computation</strong>
: Multiple computations executing at the same time, potentially interacting with each other.</p>
<h2 id="d"><a class="header" href="#d">D</a></h2>
<p><strong>Deno</strong>
: A secure runtime for JavaScript and TypeScript built on V8, Chrome's JavaScript engine.</p>
<p><strong>Deployment</strong>
: The process of releasing and configuring a Reflow application to run in a production environment.</p>
<h2 id="e"><a class="header" href="#e">E</a></h2>
<p><strong>Edge</strong>
: In graph terminology, a connection between two nodes (components) that represents data or control flow.</p>
<p><strong>Event</strong>
: A signal or message that indicates something has happened in the system.</p>
<h2 id="f"><a class="header" href="#f">F</a></h2>
<p><strong>Flow-Based Programming (FBP)</strong>
: A programming paradigm that defines applications as networks of "black box" processes exchanging data across predefined connections.</p>
<h2 id="g"><a class="header" href="#g">G</a></h2>
<p><strong>Graph</strong>
: A data structure consisting of nodes (vertices) and edges that represent the connections between them. In Reflow, graphs represent workflows.</p>
<p><strong>GraphQL</strong>
: A query language and runtime for APIs that provides a complete description of data in your API.</p>
<h2 id="i"><a class="header" href="#i">I</a></h2>
<p><strong>Inport</strong>
: An input connection point on a component that receives data or control signals.</p>
<p><strong>Initial Information Packet (IIP)</strong>
: A data packet that provides initial values to component inputs at the start of execution.</p>
<h2 id="m"><a class="header" href="#m">M</a></h2>
<p><strong>Message</strong>
: A unit of communication between actors containing data and metadata.</p>
<p><strong>Message Passing</strong>
: The primary means of communication between actors, where information is sent via discrete messages.</p>
<p><strong>Metadata</strong>
: Data that provides information about other data, such as component properties or connection details.</p>
<h2 id="n"><a class="header" href="#n">N</a></h2>
<p><strong>Node</strong>
: In graph terminology, a vertex that represents a component or processing unit in a workflow.</p>
<p><strong>Network</strong>
: A collection of connected components that form a complete workflow or application.</p>
<h2 id="o"><a class="header" href="#o">O</a></h2>
<p><strong>Outport</strong>
: An output connection point on a component that sends data or control signals to other components.</p>
<h2 id="p"><a class="header" href="#p">P</a></h2>
<p><strong>Port</strong>
: A connection point on a component, either an inport (input) or outport (output).</p>
<p><strong>Process</strong>
: A running instance of a component that can receive and send messages.</p>
<p><strong>Protocol</strong>
: A set of rules that define how actors communicate with each other.</p>
<h2 id="r"><a class="header" href="#r">R</a></h2>
<p><strong>ReactFlow</strong>
: A library for building node-based editors and interactive diagrams with React.</p>
<p><strong>Runtime</strong>
: The execution environment where Reflow applications run, including the JavaScript/Deno runtime.</p>
<h2 id="s"><a class="header" href="#s">S</a></h2>
<p><strong>Serialization</strong>
: The process of converting data structures or objects into a format that can be stored or transmitted.</p>
<p><strong>Subgraph</strong>
: A subset of a larger graph that can be treated as a single component.</p>
<h2 id="t"><a class="header" href="#t">T</a></h2>
<p><strong>TypeScript</strong>
: A strongly typed programming language that builds on JavaScript by adding static type definitions.</p>
<p><strong>Trait</strong>
: A characteristic or property that defines the behavior or type of a port or component.</p>
<h2 id="v"><a class="header" href="#v">V</a></h2>
<p><strong>Visual Editor</strong>
: A graphical user interface that allows users to create and modify workflows by dragging and dropping components.</p>
<h2 id="w"><a class="header" href="#w">W</a></h2>
<p><strong>WebAssembly (WASM)</strong>
: A binary instruction format for a stack-based virtual machine, designed to be fast and portable.</p>
<p><strong>Workflow</strong>
: A sequence of connected components that process data or perform tasks in a specific order.</p>
<p><strong>Web Worker</strong>
: A JavaScript API that allows web pages to run scripts in background threads separate from the main execution thread.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-reflow"><a class="header" href="#contributing-to-reflow">Contributing to Reflow</a></h1>
<p>Thank you for your interest in contributing to Reflow! This document provides guidelines and information for contributors.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<h3 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h3>
<p>Before contributing, ensure you have:</p>
<ul>
<li><strong>Rust</strong> (latest stable version)</li>
<li><strong>Node.js</strong> (version 18 or higher)</li>
<li><strong>Git</strong> for version control</li>
<li><strong>mdBook</strong> for documentation (optional)</li>
</ul>
<h3 id="setting-up-the-development-environment"><a class="header" href="#setting-up-the-development-environment">Setting Up the Development Environment</a></h3>
<ol>
<li>
<p><strong>Clone the repository:</strong></p>
<pre><code class="language-bash">git clone https://github.com/your-org/reflow.git
cd reflow
</code></pre>
</li>
<li>
<p><strong>Install Rust dependencies:</strong></p>
<pre><code class="language-bash">cargo build
</code></pre>
</li>
<li>
<p><strong>Install Node.js dependencies:</strong></p>
<pre><code class="language-bash">cd examples/audio-flow
npm install
</code></pre>
</li>
<li>
<p><strong>Run tests:</strong></p>
<pre><code class="language-bash">cargo test
</code></pre>
</li>
</ol>
<h2 id="how-to-contribute"><a class="header" href="#how-to-contribute">How to Contribute</a></h2>
<h3 id="reporting-issues"><a class="header" href="#reporting-issues">Reporting Issues</a></h3>
<ul>
<li>Use the <a href="https://github.com/your-org/reflow/issues">GitHub Issues</a> page</li>
<li>Provide detailed information about the bug or feature request</li>
<li>Include relevant code examples and error messages</li>
<li>Search existing issues before creating new ones</li>
</ul>
<h3 id="submitting-pull-requests"><a class="header" href="#submitting-pull-requests">Submitting Pull Requests</a></h3>
<ol>
<li><strong>Fork the repository</strong> and create a new branch</li>
<li><strong>Make your changes</strong> with clear, descriptive commits</li>
<li><strong>Add tests</strong> for new functionality</li>
<li><strong>Update documentation</strong> as needed</li>
<li><strong>Submit a pull request</strong> with a clear description</li>
</ol>
<h3 id="code-style-guidelines"><a class="header" href="#code-style-guidelines">Code Style Guidelines</a></h3>
<h4 id="rust-code"><a class="header" href="#rust-code">Rust Code</a></h4>
<ul>
<li>Follow the <a href="https://doc.rust-lang.org/nightly/style-guide/">Rust Style Guide</a></li>
<li>Use <code>cargo fmt</code> to format code</li>
<li>Use <code>cargo clippy</code> to catch common mistakes</li>
<li>Write comprehensive documentation comments (<code>///</code>)</li>
</ul>
<h4 id="javascripttypescript-code"><a class="header" href="#javascripttypescript-code">JavaScript/TypeScript Code</a></h4>
<ul>
<li>Use Prettier for formatting</li>
<li>Follow ESLint recommendations</li>
<li>Use meaningful variable and function names</li>
<li>Write JSDoc comments for public APIs</li>
</ul>
<h4 id="documentation"><a class="header" href="#documentation">Documentation</a></h4>
<ul>
<li>Use clear, concise language</li>
<li>Include code examples where appropriate</li>
<li>Test all code examples to ensure they work</li>
<li>Follow the existing documentation structure</li>
</ul>
<h2 id="development-workflow-1"><a class="header" href="#development-workflow-1">Development Workflow</a></h2>
<h3 id="branch-naming-convention"><a class="header" href="#branch-naming-convention">Branch Naming Convention</a></h3>
<ul>
<li><code>feature/description</code> - for new features</li>
<li><code>fix/description</code> - for bug fixes</li>
<li><code>docs/description</code> - for documentation updates</li>
<li><code>refactor/description</code> - for code refactoring</li>
</ul>
<h3 id="commit-message-format"><a class="header" href="#commit-message-format">Commit Message Format</a></h3>
<pre><code>type(scope): brief description

Detailed explanation of the change, if necessary.

Fixes #123
</code></pre>
<p><strong>Types:</strong></p>
<ul>
<li><code>feat</code>: New feature</li>
<li><code>fix</code>: Bug fix</li>
<li><code>docs</code>: Documentation changes</li>
<li><code>style</code>: Code style changes (formatting, etc.)</li>
<li><code>refactor</code>: Code refactoring</li>
<li><code>test</code>: Adding or updating tests</li>
<li><code>chore</code>: Maintenance tasks</li>
</ul>
<h3 id="testing"><a class="header" href="#testing">Testing</a></h3>
<h4 id="unit-tests-1"><a class="header" href="#unit-tests-1">Unit Tests</a></h4>
<pre><code class="language-bash">cargo test
</code></pre>
<h4 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration Tests</a></h4>
<pre><code class="language-bash">cargo test --test integration
</code></pre>
<h4 id="documentation-tests"><a class="header" href="#documentation-tests">Documentation Tests</a></h4>
<pre><code class="language-bash">cargo test --doc
</code></pre>
<h4 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-End Tests</a></h4>
<pre><code class="language-bash">cd examples/audio-flow
npm test
</code></pre>
<h2 id="documentation-guidelines"><a class="header" href="#documentation-guidelines">Documentation Guidelines</a></h2>
<h3 id="writing-style"><a class="header" href="#writing-style">Writing Style</a></h3>
<ul>
<li>Use active voice</li>
<li>Write in present tense</li>
<li>Be clear and concise</li>
<li>Include practical examples</li>
<li>Explain the "why" not just the "how"</li>
</ul>
<h3 id="code-examples"><a class="header" href="#code-examples">Code Examples</a></h3>
<ul>
<li>Test all code examples</li>
<li>Include imports and setup code</li>
<li>Show expected output where relevant</li>
<li>Use realistic, meaningful examples</li>
</ul>
<h3 id="api-documentation"><a class="header" href="#api-documentation">API Documentation</a></h3>
<ul>
<li>Document all public functions and types</li>
<li>Include parameter descriptions</li>
<li>Provide return value information</li>
<li>Add usage examples</li>
</ul>
<h2 id="community-guidelines"><a class="header" href="#community-guidelines">Community Guidelines</a></h2>
<h3 id="code-of-conduct"><a class="header" href="#code-of-conduct">Code of Conduct</a></h3>
<p>We are committed to providing a welcoming and inclusive environment for all contributors. Please:</p>
<ul>
<li>Be respectful and considerate</li>
<li>Focus on constructive feedback</li>
<li>Help others learn and grow</li>
<li>Celebrate diverse perspectives</li>
</ul>
<h3 id="communication-channels-1"><a class="header" href="#communication-channels-1">Communication Channels</a></h3>
<ul>
<li><strong>GitHub Issues</strong>: Bug reports and feature requests</li>
<li><strong>GitHub Discussions</strong>: General questions and community discussion</li>
<li><strong>Discord</strong>: Real-time chat (invite link in README)</li>
</ul>
<h2 id="release-process"><a class="header" href="#release-process">Release Process</a></h2>
<h3 id="versioning"><a class="header" href="#versioning">Versioning</a></h3>
<p>We follow <a href="https://semver.org/">Semantic Versioning</a>:</p>
<ul>
<li><code>MAJOR.MINOR.PATCH</code></li>
<li>Breaking changes increment MAJOR</li>
<li>New features increment MINOR</li>
<li>Bug fixes increment PATCH</li>
</ul>
<h3 id="release-checklist"><a class="header" href="#release-checklist">Release Checklist</a></h3>
<ol>
<li>Update version numbers in <code>Cargo.toml</code></li>
<li>Update <code>CHANGELOG.md</code></li>
<li>Run full test suite</li>
<li>Update documentation</li>
<li>Create GitHub release</li>
<li>Publish to crates.io (maintainers only)</li>
</ol>
<h2 id="architecture-guidelines"><a class="header" href="#architecture-guidelines">Architecture Guidelines</a></h2>
<h3 id="actor-design-principles"><a class="header" href="#actor-design-principles">Actor Design Principles</a></h3>
<p>When creating new actors:</p>
<ul>
<li><strong>Single Responsibility</strong>: Each actor should have one clear purpose</li>
<li><strong>Immutable Messages</strong>: Messages should be immutable data structures</li>
<li><strong>Error Handling</strong>: Handle errors gracefully and provide meaningful messages</li>
<li><strong>Documentation</strong>: Include comprehensive examples and usage guidelines</li>
</ul>
<h3 id="component-design"><a class="header" href="#component-design">Component Design</a></h3>
<p>For new components:</p>
<ul>
<li><strong>Composability</strong>: Components should work well with others</li>
<li><strong>Configuration</strong>: Use clear, typed configuration options</li>
<li><strong>Performance</strong>: Consider memory usage and execution speed</li>
<li><strong>Testing</strong>: Include unit tests and integration tests</li>
</ul>
<h3 id="api-design"><a class="header" href="#api-design">API Design</a></h3>
<p>When designing APIs:</p>
<ul>
<li><strong>Consistency</strong>: Follow existing patterns and conventions</li>
<li><strong>Type Safety</strong>: Use strong typing where possible</li>
<li><strong>Documentation</strong>: Provide clear documentation and examples</li>
<li><strong>Backwards Compatibility</strong>: Consider impact on existing users</li>
</ul>
<h2 id="getting-help-2"><a class="header" href="#getting-help-2">Getting Help</a></h2>
<p>If you need help with contributing:</p>
<ol>
<li>Check the <a href="appendices/../README.html">documentation</a></li>
<li>Search <a href="https://github.com/your-org/reflow/issues">existing issues</a></li>
<li>Ask in <a href="https://github.com/your-org/reflow/discussions">GitHub Discussions</a></li>
<li>Join our <a href="appendices/discord-invite-link">Discord community</a></li>
</ol>
<h2 id="recognition"><a class="header" href="#recognition">Recognition</a></h2>
<p>Contributors are recognized in:</p>
<ul>
<li>The project README</li>
<li>Release notes</li>
<li>Annual contributor reports</li>
</ul>
<p>We appreciate all contributions, whether they're code, documentation, testing, or community support!</p>
<h2 id="license-1"><a class="header" href="#license-1">License</a></h2>
<p>By contributing to Reflow, you agree that your contributions will be licensed under the same license as the project (see <a href="appendices/../../LICENSE">LICENSE</a> file).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
